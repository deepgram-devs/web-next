import { c as createAstro, a as createComponent, r as renderTemplate, b as renderHead } from '../entry.mjs';
import Slugger from 'github-slugger';
import '@astrojs/netlify/netlify-functions.js';
import 'preact';
import 'preact-render-to-string';
import 'vue';
import 'vue/server-renderer';
import 'html-escaper';
import 'node-html-parser';
import 'axios';
/* empty css                           *//* empty css                           *//* empty css                           *//* empty css                           *//* empty css                          */import 'clone-deep';
import 'slugify';
import 'shiki';
/* empty css                           */import '@astrojs/rss';
/* empty css                           */import 'mime';
import 'cookie';
import 'kleur/colors';
import 'string-width';
import 'path-browserify';
import 'path-to-regexp';

const metadata = { "headings": [{ "depth": 2, "slug": "use-case", "text": "Use Case" }, { "depth": 2, "slug": "calling-the-api", "text": "Calling the API" }, { "depth": 2, "slug": "bring-your-own-logging", "text": "Bring Your Own Logging" }, { "depth": 2, "slug": "microsofts-cross-platform-recommendations", "text": "Microsoft\u2019s Cross-Platform Recommendations" }, { "depth": 2, "slug": "publishing-to-nuget-with-github-actions", "text": "Publishing to Nuget with GitHub Actions" }, { "depth": 3, "slug": "triggering-a-new-release", "text": "Triggering a New Release" }, { "depth": 3, "slug": "restoring-dependencies", "text": "Restoring Dependencies" }, { "depth": 3, "slug": "identifying-version-number", "text": "Identifying Version Number" }, { "depth": 3, "slug": "building--packaging-the-sdk", "text": "Building & Packaging the SDK" }, { "depth": 4, "slug": "configuration", "text": "\u2014configuration" }, { "depth": 4, "slug": "no-restore", "text": "\u2014no-restore" }, { "depth": 4, "slug": "output", "text": "\u2014output" }, { "depth": 4, "slug": "-p", "text": "-p" }, { "depth": 3, "slug": "archiving-packing-artifacts", "text": "Archiving Packing Artifacts" }, { "depth": 3, "slug": "publishing-to-nuget", "text": "Publishing to NuGet" }, { "depth": 4, "slug": "downloading-artifacts", "text": "Downloading Artifacts" }, { "depth": 4, "slug": "pushing-the-package", "text": "Pushing the Package" }, { "depth": 2, "slug": "announcing-the-deepgram-net-sdk", "text": "Announcing the Deepgram .NET SDK" }], "source": "\r\nI love the .NET ecosystem. My career started writing classic ASP applications in\r\nVisual Basic and transitioned to C# with .NET 2.0. I remember building my first\r\nASP.NET MVC application and feeling like I had just performed some kind of magic.\r\n\r\nOnce I joined Deepgram, I was very excited about the prospect of building a\r\n.NET SDK from scratch. During the process, I realized that there are certain\r\nthings to consider when building a .NET library to make it as accessible as\r\npossible to developers building with different versions of the .NET Framework\r\nand various platforms.\r\n\r\n> Happy holidays! This post is a contribution to [C# Advent 2021](https://www.csadvent.christmas/). Be\r\n> sure to visit and read all the excellent content focused on C# and the .NET community.\r\n\r\n## Use Case\r\n\r\nBefore we get too deep in the how-to, let's talk about the need I was trying to\r\naddress. Today, Deepgram has two fully supported SDKs; Node.js & Python.\r\nLike .NET, both are great languages with solid ecosystems, but I wanted to\r\nprovide that first-class citizen experience to my beloved .NET developers. \u{1F601}\r\n\r\nAfter a bit of planning, I landed on the following requirements for the SDK:\r\n\r\n*   Enable access to all the publicly available endpoints of the [Deepgram API](https://developers.deepgram.com/api-reference/)\r\n*   Allow users to provide their own logging by using the [LoggerFactory](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerfactory) provided in the `Microsoft.Extensions.Logging` library\r\n*   Ensure the library was accessible to as many frameworks & platforms as reasonably practical\r\n\r\n## Calling the API\r\n\r\nMost of the Deepgram API is accessible via HTTP requests, so the library handles\r\nthose as you'd expect with an HTTPClient. Requests to transcribe audio in\r\nreal-time are handled via WebSockets. Creating a reusable and well-managed\r\nWebSocket client was more challenging because I couldn't find any real-world\r\nexamples in the documentation. In most cases, the documentation would show\r\nconnecting to a socket, sending a message, receiving a message, and then\r\ndisconnecting. In the real world, I needed a client that would connect, then\r\nsend & receive messages on-demand, and disconnect at a later time that I\r\ndecide.\r\n\r\n## Bring Your Own Logging\r\n\r\nLogging, like tests, are one of those features that developers like to bypass.\r\nFor years, my projects were scarce on logging and, when included, it was\r\noften added as an afterthought. That said, I was very impressed by one of my\r\ncolleagues, [Steve Lorello](https://twitter.com/slorello), at Vonage, who worked\r\non their .NET SDK. Not only did he do a great job with logging throughout the\r\nSDK, he utilized the `LoggerFactory` to provide the ability for developers to\r\nchoose their own logging solution. I contacted him as I was getting started to\r\nwarn him that I was blatantly plagiarizing his work. \u{1F602}\r\n\r\nLuckily, Steve was super gracious and offered to help with any questions.\r\nSeriously, if you aren't following Steve on [Twitter](https://twitter.com/slorello),\r\nyou should. He's doing outstanding work at Redis now.\r\n\r\n## Microsoft's Cross-Platform Recommendations\r\n\r\nMicrosoft recommends starting with a `netstandard2.0` target. Since we only plan\r\non supporting platforms & frameworks that can use .NET Standard 2.0 or later,\r\nI started reviewing any dependencies I had added intending to strip it down\r\nto only those compliant with the .NET Standard 2.0.\r\n\r\nI did notice in [Microsoft's recommendations](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting)\r\nthat in some cases, you may have to shield your users depending on their platform\r\nand framework, as in the example below:\r\n\r\n```csharp\r\npublic static class GpsLocation\r\n{\r\n    // This project uses multi-targeting to expose device-specific APIs to .NET Standard.\r\n    public static async Task<(double latitude, double longitude)> GetCoordinatesAsync()\r\n    {\r\n#if NET461\r\n        return CallDotNetFramworkApi();\r\n#elif WINDOWS_UWP\r\n        return CallUwpApi();\r\n#else\r\n        throw new PlatformNotSupportedException();\r\n#endif\r\n    }\r\n\r\n    // Allows callers to check without having to catch PlatformNotSupportedException\r\n    // or replicating the OS check.\r\n    public static bool IsSupported\r\n    {\r\n        get\r\n        {\r\n#if NET461 || WINDOWS_UWP\r\n            return true;\r\n#else\r\n            return false;\r\n#endif\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFortunately, our SDK didn't require these types of workarounds.\r\n\r\n## Publishing to Nuget with GitHub Actions\r\n\r\nBecause I created the library in Visual Studio 2022 using the new class library\r\ntemplates, the configuration for building a NuGet package was as painless as\r\nproviding details like the name, description, etc. of the package. I had already\r\ncreated a [GitHub Action](https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CI.yml)\r\nto perform CI tasks, so I decided to add another GitHub Action to deploy the\r\npackage to NuGet.org when a new version was released.\r\n\r\nThe Continuous Deployment (CD) action contains two jobs: `build` and `publish`.\r\nThe `build` job creates the NuGet package, while the `publish` job\r\nhandles uploading the generated package to NuGet.org. The `publish` job will\r\nonly run if the `build` job completes successfully. You can review the entire\r\nCD workflow file [here](https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CD.yml).\r\n\r\n### Triggering a New Release\r\n\r\nOnce we're ready to release a new version of the SDK, we create a new GitHub\r\nrelease. The CD action is triggered when that new release is published. Once\r\nit begins, we use the `actions/checkout@v2` to check out the code based on the\r\nsha associated with the release.\r\n\r\n### Restoring Dependencies\r\n\r\nOnce the repository is retrieved, we install .NET 6 and install any\r\nrequired dependencies from NuGet.\r\n\r\n### Identifying Version Number\r\n\r\nOnce the dependencies are installed, the next step pulls the version number from\r\nthe GitHub release and outputs that value so that subsequent steps can access\r\nit.\r\n\r\n### Building & Packaging the SDK\r\n\r\nNext, the action calls `dotnet pack` and passes various parameters to configure\r\nthe build and packing process to ensure we've got the cleanest output\r\npossible.\r\n\r\n#### --configuration\r\n\r\nThe `--configuration` parameter tells the build process to run in `Release`\r\nmode rather than `Debug` mode.\r\n\r\n#### --no-restore\r\n\r\nBecause we previously ran `dotnet restore` in the action, there's no need to\r\nrestore packages from Nuget during the build process. The `--no-restore`\r\nparameter tells the build process to skip this step to save time.\r\n\r\n#### --output\r\n\r\nOnce we build the SDK with the various targets, we want that clean output saved\r\nto a specific directory. In our case, the `./dist` directory.\r\n\r\n#### -p\r\n\r\nThe `-p` parameter is used to pass additional parameters to the build process.\r\nIn our case, we are sending a parameter called `Version` and set it to the value of\r\nthe `get_version` step, which returned our version number based on the GitHub\r\nrelease.\r\n\r\n### Archiving Packing Artifacts\r\n\r\nThe generated package should live in the ./dist directory when the build and\r\npacking process completes. We use the `actions/upload-artifact@v2` action to\r\nsave the contents of that directory as an artifact of the action with the name\r\n`dist`. We'll access this artifact in the next step of the process.\r\n\r\n### Publishing to NuGet\r\n\r\nWith the package archived as an artifact, the `publish` job will send it\r\nto NuGet.\r\n\r\n#### Downloading Artifacts\r\n\r\nThe publish job will first download the artifact named dist that was created in\r\nthe build job. These artifacts are downloaded to the `./dist` directory.\r\n\r\n#### Pushing the Package\r\n\r\nNext, the job calls `dotnet nuget push` to send any .nupkg file in the `./dist`\r\ndirectory to NuGet.org. This requires an access token that NuGet provides.\r\nFor securities sake, we store that token in the repositories secrets and access\r\nit via `${{secrets.NUGET_API_KEY}}`.\r\n\r\nWith that step complete, the action is finished and stops. NuGet will review\r\nthe uploaded package and release it to the marketplace automatically.\r\n\r\n## Announcing the Deepgram .NET SDK\r\n\r\nOf course, with all this work completed, we can announce the new\r\n[Deepgram .NET SDK](https://www.nuget.org/packages/Deepgram/). Try it out, and\r\nlet us know if it helps you get up and running with Deepgram even faster.\r\n\r\nAlso, the entire project has been\r\n[built in the open on GitHub](https://github.com/deepgram-devs/deepgram-dotnet-sdk),\r\nand we'd love your input, feedback, and contributions to make it even better!\r\nHappy building!\r\n\r\n        ", "html": '<p>I love the .NET ecosystem. My career started writing classic ASP applications in\r\nVisual Basic and transitioned to C# with .NET 2.0. I remember building my first\r\nASP.NET MVC application and feeling like I had just performed some kind of magic.</p>\n<p>Once I joined Deepgram, I was very excited about the prospect of building a\r\n.NET SDK from scratch. During the process, I realized that there are certain\r\nthings to consider when building a .NET library to make it as accessible as\r\npossible to developers building with different versions of the .NET Framework\r\nand various platforms.</p>\n<blockquote>\n<p>Happy holidays! This post is a contribution to <a href="https://www.csadvent.christmas/">C# Advent 2021</a>. Be\r\nsure to visit and read all the excellent content focused on C# and the .NET community.</p>\n</blockquote>\n<h2 id="use-case">Use Case</h2>\n<p>Before we get too deep in the how-to, let\u2019s talk about the need I was trying to\r\naddress. Today, Deepgram has two fully supported SDKs; Node.js & Python.\r\nLike .NET, both are great languages with solid ecosystems, but I wanted to\r\nprovide that first-class citizen experience to my beloved .NET developers. \u{1F601}</p>\n<p>After a bit of planning, I landed on the following requirements for the SDK:</p>\n<ul>\n<li>Enable access to all the publicly available endpoints of the <a href="https://developers.deepgram.com/api-reference/">Deepgram API</a></li>\n<li>Allow users to provide their own logging by using the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerfactory">LoggerFactory</a> provided in the <code is:raw>Microsoft.Extensions.Logging</code> library</li>\n<li>Ensure the library was accessible to as many frameworks & platforms as reasonably practical</li>\n</ul>\n<h2 id="calling-the-api">Calling the API</h2>\n<p>Most of the Deepgram API is accessible via HTTP requests, so the library handles\r\nthose as you\u2019d expect with an HTTPClient. Requests to transcribe audio in\r\nreal-time are handled via WebSockets. Creating a reusable and well-managed\r\nWebSocket client was more challenging because I couldn\u2019t find any real-world\r\nexamples in the documentation. In most cases, the documentation would show\r\nconnecting to a socket, sending a message, receiving a message, and then\r\ndisconnecting. In the real world, I needed a client that would connect, then\r\nsend & receive messages on-demand, and disconnect at a later time that I\r\ndecide.</p>\n<h2 id="bring-your-own-logging">Bring Your Own Logging</h2>\n<p>Logging, like tests, are one of those features that developers like to bypass.\r\nFor years, my projects were scarce on logging and, when included, it was\r\noften added as an afterthought. That said, I was very impressed by one of my\r\ncolleagues, <a href="https://twitter.com/slorello">Steve Lorello</a>, at Vonage, who worked\r\non their .NET SDK. Not only did he do a great job with logging throughout the\r\nSDK, he utilized the <code is:raw>LoggerFactory</code> to provide the ability for developers to\r\nchoose their own logging solution. I contacted him as I was getting started to\r\nwarn him that I was blatantly plagiarizing his work. \u{1F602}</p>\n<p>Luckily, Steve was super gracious and offered to help with any questions.\r\nSeriously, if you aren\u2019t following Steve on <a href="https://twitter.com/slorello">Twitter</a>,\r\nyou should. He\u2019s doing outstanding work at Redis now.</p>\n<h2 id="microsofts-cross-platform-recommendations">Microsoft\u2019s Cross-Platform Recommendations</h2>\n<p>Microsoft recommends starting with a <code is:raw>netstandard2.0</code> target. Since we only plan\r\non supporting platforms & frameworks that can use .NET Standard 2.0 or later,\r\nI started reviewing any dependencies I had added intending to strip it down\r\nto only those compliant with the .NET Standard 2.0.</p>\n<p>I did notice in <a href="https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting">Microsoft\u2019s recommendations</a>\r\nthat in some cases, you may have to shield your users depending on their platform\r\nand framework, as in the example below:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">static</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">class</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">GpsLocation</span></span>\n<span class="line"><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// This project uses multi-targeting to expose device-specific APIs to .NET Standard.</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">static</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">Task</span><span style="color: #C9D1D9">&lt;(</span><span style="color: #FF7B72">double</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">latitude</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">double</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">longitude</span><span style="color: #C9D1D9">)&gt; </span><span style="color: #D2A8FF">GetCoordinatesAsync</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">    {</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">NET461</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">CallDotNetFramworkApi</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">elif</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">WINDOWS_UWP</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">CallUwpApi</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">else</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">throw</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">PlatformNotSupportedException</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">endif</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// Allows callers to check without having to catch PlatformNotSupportedException</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// or replicating the OS check.</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">static</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">bool</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">IsSupported</span></span>\n<span class="line"><span style="color: #C9D1D9">    {</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">get</span></span>\n<span class="line"><span style="color: #C9D1D9">        {</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">NET461</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">WINDOWS_UWP</span></span>\n<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">else</span></span>\n<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">endif</span></span>\n<span class="line"><span style="color: #C9D1D9">        }</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Fortunately, our SDK didn\u2019t require these types of workarounds.</p>\n<h2 id="publishing-to-nuget-with-github-actions">Publishing to Nuget with GitHub Actions</h2>\n<p>Because I created the library in Visual Studio 2022 using the new class library\r\ntemplates, the configuration for building a NuGet package was as painless as\r\nproviding details like the name, description, etc. of the package. I had already\r\ncreated a <a href="https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CI.yml">GitHub Action</a>\r\nto perform CI tasks, so I decided to add another GitHub Action to deploy the\r\npackage to NuGet.org when a new version was released.</p>\n<p>The Continuous Deployment (CD) action contains two jobs: <code is:raw>build</code> and <code is:raw>publish</code>.\r\nThe <code is:raw>build</code> job creates the NuGet package, while the <code is:raw>publish</code> job\r\nhandles uploading the generated package to NuGet.org. The <code is:raw>publish</code> job will\r\nonly run if the <code is:raw>build</code> job completes successfully. You can review the entire\r\nCD workflow file <a href="https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CD.yml">here</a>.</p>\n<h3 id="triggering-a-new-release">Triggering a New Release</h3>\n<p>Once we\u2019re ready to release a new version of the SDK, we create a new GitHub\r\nrelease. The CD action is triggered when that new release is published. Once\r\nit begins, we use the <code is:raw>actions/checkout@v2</code> to check out the code based on the\r\nsha associated with the release.</p>\n<h3 id="restoring-dependencies">Restoring Dependencies</h3>\n<p>Once the repository is retrieved, we install .NET 6 and install any\r\nrequired dependencies from NuGet.</p>\n<h3 id="identifying-version-number">Identifying Version Number</h3>\n<p>Once the dependencies are installed, the next step pulls the version number from\r\nthe GitHub release and outputs that value so that subsequent steps can access\r\nit.</p>\n<h3 id="building--packaging-the-sdk">Building & Packaging the SDK</h3>\n<p>Next, the action calls <code is:raw>dotnet pack</code> and passes various parameters to configure\r\nthe build and packing process to ensure we\u2019ve got the cleanest output\r\npossible.</p>\n<h4 id="configuration">\u2014configuration</h4>\n<p>The <code is:raw>--configuration</code> parameter tells the build process to run in <code is:raw>Release</code>\r\nmode rather than <code is:raw>Debug</code> mode.</p>\n<h4 id="no-restore">\u2014no-restore</h4>\n<p>Because we previously ran <code is:raw>dotnet restore</code> in the action, there\u2019s no need to\r\nrestore packages from Nuget during the build process. The <code is:raw>--no-restore</code>\r\nparameter tells the build process to skip this step to save time.</p>\n<h4 id="output">\u2014output</h4>\n<p>Once we build the SDK with the various targets, we want that clean output saved\r\nto a specific directory. In our case, the <code is:raw>./dist</code> directory.</p>\n<h4 id="-p">-p</h4>\n<p>The <code is:raw>-p</code> parameter is used to pass additional parameters to the build process.\r\nIn our case, we are sending a parameter called <code is:raw>Version</code> and set it to the value of\r\nthe <code is:raw>get_version</code> step, which returned our version number based on the GitHub\r\nrelease.</p>\n<h3 id="archiving-packing-artifacts">Archiving Packing Artifacts</h3>\n<p>The generated package should live in the ./dist directory when the build and\r\npacking process completes. We use the <code is:raw>actions/upload-artifact@v2</code> action to\r\nsave the contents of that directory as an artifact of the action with the name\r\n<code is:raw>dist</code>. We\u2019ll access this artifact in the next step of the process.</p>\n<h3 id="publishing-to-nuget">Publishing to NuGet</h3>\n<p>With the package archived as an artifact, the <code is:raw>publish</code> job will send it\r\nto NuGet.</p>\n<h4 id="downloading-artifacts">Downloading Artifacts</h4>\n<p>The publish job will first download the artifact named dist that was created in\r\nthe build job. These artifacts are downloaded to the <code is:raw>./dist</code> directory.</p>\n<h4 id="pushing-the-package">Pushing the Package</h4>\n<p>Next, the job calls <code is:raw>dotnet nuget push</code> to send any .nupkg file in the <code is:raw>./dist</code>\r\ndirectory to NuGet.org. This requires an access token that NuGet provides.\r\nFor securities sake, we store that token in the repositories secrets and access\r\nit via <code is:raw>${{secrets.NUGET_API_KEY}}</code>.</p>\n<p>With that step complete, the action is finished and stops. NuGet will review\r\nthe uploaded package and release it to the marketplace automatically.</p>\n<h2 id="announcing-the-deepgram-net-sdk">Announcing the Deepgram .NET SDK</h2>\n<p>Of course, with all this work completed, we can announce the new\r\n<a href="https://www.nuget.org/packages/Deepgram/">Deepgram .NET SDK</a>. Try it out, and\r\nlet us know if it helps you get up and running with Deepgram even faster.</p>\n<p>Also, the entire project has been\r\n<a href="https://github.com/deepgram-devs/deepgram-dotnet-sdk">built in the open on GitHub</a>,\r\nand we\u2019d love your input, feedback, and contributions to make it even better!\r\nHappy building!</p>' };
const frontmatter = { "title": "Building a Cross Platform NuGet Package", "description": "Learning to build a NuGet package by building a .NET SDK for the Deepgram API, while ensuring it's compatible with as many versions of the .NET Framework and as many platforms as possible.", "date": "2021-12-23T00:00:00.000Z", "cover": "https://res.cloudinary.com/deepgram/image/upload/v1639685643/blog/2021/12/cross-platform-nuget-dotnet/Building-Cross-Platform-NuGet-Package%402x.jpg", "authors": ["michael-jolley"], "category": "tutorial", "tags": ["dotnet", "sdk"], "seo": { "title": "Building a Cross Platform NuGet Package", "description": "Learning to build a NuGet package by building a .NET SDK for the Deepgram API, while ensuring it's compatible with as many versions of the .NET Framework and as many platforms as possible." }, "shorturls": { "share": "https://dpgr.am/80c1eaf", "twitter": "https://dpgr.am/63333a7", "linkedin": "https://dpgr.am/22512d8", "reddit": "https://dpgr.am/0688948", "facebook": "https://dpgr.am/7764cea" }, "og": { "image": "https://res.cloudinary.com/deepgram/image/upload/v1661453827/blog/cross-platform-nuget-dotnet/ograph.png" }, "astro": { "headings": [{ "depth": 2, "slug": "use-case", "text": "Use Case" }, { "depth": 2, "slug": "calling-the-api", "text": "Calling the API" }, { "depth": 2, "slug": "bring-your-own-logging", "text": "Bring Your Own Logging" }, { "depth": 2, "slug": "microsofts-cross-platform-recommendations", "text": "Microsoft\u2019s Cross-Platform Recommendations" }, { "depth": 2, "slug": "publishing-to-nuget-with-github-actions", "text": "Publishing to Nuget with GitHub Actions" }, { "depth": 3, "slug": "triggering-a-new-release", "text": "Triggering a New Release" }, { "depth": 3, "slug": "restoring-dependencies", "text": "Restoring Dependencies" }, { "depth": 3, "slug": "identifying-version-number", "text": "Identifying Version Number" }, { "depth": 3, "slug": "building--packaging-the-sdk", "text": "Building & Packaging the SDK" }, { "depth": 4, "slug": "configuration", "text": "\u2014configuration" }, { "depth": 4, "slug": "no-restore", "text": "\u2014no-restore" }, { "depth": 4, "slug": "output", "text": "\u2014output" }, { "depth": 4, "slug": "-p", "text": "-p" }, { "depth": 3, "slug": "archiving-packing-artifacts", "text": "Archiving Packing Artifacts" }, { "depth": 3, "slug": "publishing-to-nuget", "text": "Publishing to NuGet" }, { "depth": 4, "slug": "downloading-artifacts", "text": "Downloading Artifacts" }, { "depth": 4, "slug": "pushing-the-package", "text": "Pushing the Package" }, { "depth": 2, "slug": "announcing-the-deepgram-net-sdk", "text": "Announcing the Deepgram .NET SDK" }], "source": "\r\nI love the .NET ecosystem. My career started writing classic ASP applications in\r\nVisual Basic and transitioned to C# with .NET 2.0. I remember building my first\r\nASP.NET MVC application and feeling like I had just performed some kind of magic.\r\n\r\nOnce I joined Deepgram, I was very excited about the prospect of building a\r\n.NET SDK from scratch. During the process, I realized that there are certain\r\nthings to consider when building a .NET library to make it as accessible as\r\npossible to developers building with different versions of the .NET Framework\r\nand various platforms.\r\n\r\n> Happy holidays! This post is a contribution to [C# Advent 2021](https://www.csadvent.christmas/). Be\r\n> sure to visit and read all the excellent content focused on C# and the .NET community.\r\n\r\n## Use Case\r\n\r\nBefore we get too deep in the how-to, let's talk about the need I was trying to\r\naddress. Today, Deepgram has two fully supported SDKs; Node.js & Python.\r\nLike .NET, both are great languages with solid ecosystems, but I wanted to\r\nprovide that first-class citizen experience to my beloved .NET developers. \u{1F601}\r\n\r\nAfter a bit of planning, I landed on the following requirements for the SDK:\r\n\r\n*   Enable access to all the publicly available endpoints of the [Deepgram API](https://developers.deepgram.com/api-reference/)\r\n*   Allow users to provide their own logging by using the [LoggerFactory](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerfactory) provided in the `Microsoft.Extensions.Logging` library\r\n*   Ensure the library was accessible to as many frameworks & platforms as reasonably practical\r\n\r\n## Calling the API\r\n\r\nMost of the Deepgram API is accessible via HTTP requests, so the library handles\r\nthose as you'd expect with an HTTPClient. Requests to transcribe audio in\r\nreal-time are handled via WebSockets. Creating a reusable and well-managed\r\nWebSocket client was more challenging because I couldn't find any real-world\r\nexamples in the documentation. In most cases, the documentation would show\r\nconnecting to a socket, sending a message, receiving a message, and then\r\ndisconnecting. In the real world, I needed a client that would connect, then\r\nsend & receive messages on-demand, and disconnect at a later time that I\r\ndecide.\r\n\r\n## Bring Your Own Logging\r\n\r\nLogging, like tests, are one of those features that developers like to bypass.\r\nFor years, my projects were scarce on logging and, when included, it was\r\noften added as an afterthought. That said, I was very impressed by one of my\r\ncolleagues, [Steve Lorello](https://twitter.com/slorello), at Vonage, who worked\r\non their .NET SDK. Not only did he do a great job with logging throughout the\r\nSDK, he utilized the `LoggerFactory` to provide the ability for developers to\r\nchoose their own logging solution. I contacted him as I was getting started to\r\nwarn him that I was blatantly plagiarizing his work. \u{1F602}\r\n\r\nLuckily, Steve was super gracious and offered to help with any questions.\r\nSeriously, if you aren't following Steve on [Twitter](https://twitter.com/slorello),\r\nyou should. He's doing outstanding work at Redis now.\r\n\r\n## Microsoft's Cross-Platform Recommendations\r\n\r\nMicrosoft recommends starting with a `netstandard2.0` target. Since we only plan\r\non supporting platforms & frameworks that can use .NET Standard 2.0 or later,\r\nI started reviewing any dependencies I had added intending to strip it down\r\nto only those compliant with the .NET Standard 2.0.\r\n\r\nI did notice in [Microsoft's recommendations](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting)\r\nthat in some cases, you may have to shield your users depending on their platform\r\nand framework, as in the example below:\r\n\r\n```csharp\r\npublic static class GpsLocation\r\n{\r\n    // This project uses multi-targeting to expose device-specific APIs to .NET Standard.\r\n    public static async Task<(double latitude, double longitude)> GetCoordinatesAsync()\r\n    {\r\n#if NET461\r\n        return CallDotNetFramworkApi();\r\n#elif WINDOWS_UWP\r\n        return CallUwpApi();\r\n#else\r\n        throw new PlatformNotSupportedException();\r\n#endif\r\n    }\r\n\r\n    // Allows callers to check without having to catch PlatformNotSupportedException\r\n    // or replicating the OS check.\r\n    public static bool IsSupported\r\n    {\r\n        get\r\n        {\r\n#if NET461 || WINDOWS_UWP\r\n            return true;\r\n#else\r\n            return false;\r\n#endif\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFortunately, our SDK didn't require these types of workarounds.\r\n\r\n## Publishing to Nuget with GitHub Actions\r\n\r\nBecause I created the library in Visual Studio 2022 using the new class library\r\ntemplates, the configuration for building a NuGet package was as painless as\r\nproviding details like the name, description, etc. of the package. I had already\r\ncreated a [GitHub Action](https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CI.yml)\r\nto perform CI tasks, so I decided to add another GitHub Action to deploy the\r\npackage to NuGet.org when a new version was released.\r\n\r\nThe Continuous Deployment (CD) action contains two jobs: `build` and `publish`.\r\nThe `build` job creates the NuGet package, while the `publish` job\r\nhandles uploading the generated package to NuGet.org. The `publish` job will\r\nonly run if the `build` job completes successfully. You can review the entire\r\nCD workflow file [here](https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CD.yml).\r\n\r\n### Triggering a New Release\r\n\r\nOnce we're ready to release a new version of the SDK, we create a new GitHub\r\nrelease. The CD action is triggered when that new release is published. Once\r\nit begins, we use the `actions/checkout@v2` to check out the code based on the\r\nsha associated with the release.\r\n\r\n### Restoring Dependencies\r\n\r\nOnce the repository is retrieved, we install .NET 6 and install any\r\nrequired dependencies from NuGet.\r\n\r\n### Identifying Version Number\r\n\r\nOnce the dependencies are installed, the next step pulls the version number from\r\nthe GitHub release and outputs that value so that subsequent steps can access\r\nit.\r\n\r\n### Building & Packaging the SDK\r\n\r\nNext, the action calls `dotnet pack` and passes various parameters to configure\r\nthe build and packing process to ensure we've got the cleanest output\r\npossible.\r\n\r\n#### --configuration\r\n\r\nThe `--configuration` parameter tells the build process to run in `Release`\r\nmode rather than `Debug` mode.\r\n\r\n#### --no-restore\r\n\r\nBecause we previously ran `dotnet restore` in the action, there's no need to\r\nrestore packages from Nuget during the build process. The `--no-restore`\r\nparameter tells the build process to skip this step to save time.\r\n\r\n#### --output\r\n\r\nOnce we build the SDK with the various targets, we want that clean output saved\r\nto a specific directory. In our case, the `./dist` directory.\r\n\r\n#### -p\r\n\r\nThe `-p` parameter is used to pass additional parameters to the build process.\r\nIn our case, we are sending a parameter called `Version` and set it to the value of\r\nthe `get_version` step, which returned our version number based on the GitHub\r\nrelease.\r\n\r\n### Archiving Packing Artifacts\r\n\r\nThe generated package should live in the ./dist directory when the build and\r\npacking process completes. We use the `actions/upload-artifact@v2` action to\r\nsave the contents of that directory as an artifact of the action with the name\r\n`dist`. We'll access this artifact in the next step of the process.\r\n\r\n### Publishing to NuGet\r\n\r\nWith the package archived as an artifact, the `publish` job will send it\r\nto NuGet.\r\n\r\n#### Downloading Artifacts\r\n\r\nThe publish job will first download the artifact named dist that was created in\r\nthe build job. These artifacts are downloaded to the `./dist` directory.\r\n\r\n#### Pushing the Package\r\n\r\nNext, the job calls `dotnet nuget push` to send any .nupkg file in the `./dist`\r\ndirectory to NuGet.org. This requires an access token that NuGet provides.\r\nFor securities sake, we store that token in the repositories secrets and access\r\nit via `${{secrets.NUGET_API_KEY}}`.\r\n\r\nWith that step complete, the action is finished and stops. NuGet will review\r\nthe uploaded package and release it to the marketplace automatically.\r\n\r\n## Announcing the Deepgram .NET SDK\r\n\r\nOf course, with all this work completed, we can announce the new\r\n[Deepgram .NET SDK](https://www.nuget.org/packages/Deepgram/). Try it out, and\r\nlet us know if it helps you get up and running with Deepgram even faster.\r\n\r\nAlso, the entire project has been\r\n[built in the open on GitHub](https://github.com/deepgram-devs/deepgram-dotnet-sdk),\r\nand we'd love your input, feedback, and contributions to make it even better!\r\nHappy building!\r\n\r\n        ", "html": '<p>I love the .NET ecosystem. My career started writing classic ASP applications in\r\nVisual Basic and transitioned to C# with .NET 2.0. I remember building my first\r\nASP.NET MVC application and feeling like I had just performed some kind of magic.</p>\n<p>Once I joined Deepgram, I was very excited about the prospect of building a\r\n.NET SDK from scratch. During the process, I realized that there are certain\r\nthings to consider when building a .NET library to make it as accessible as\r\npossible to developers building with different versions of the .NET Framework\r\nand various platforms.</p>\n<blockquote>\n<p>Happy holidays! This post is a contribution to <a href="https://www.csadvent.christmas/">C# Advent 2021</a>. Be\r\nsure to visit and read all the excellent content focused on C# and the .NET community.</p>\n</blockquote>\n<h2 id="use-case">Use Case</h2>\n<p>Before we get too deep in the how-to, let\u2019s talk about the need I was trying to\r\naddress. Today, Deepgram has two fully supported SDKs; Node.js & Python.\r\nLike .NET, both are great languages with solid ecosystems, but I wanted to\r\nprovide that first-class citizen experience to my beloved .NET developers. \u{1F601}</p>\n<p>After a bit of planning, I landed on the following requirements for the SDK:</p>\n<ul>\n<li>Enable access to all the publicly available endpoints of the <a href="https://developers.deepgram.com/api-reference/">Deepgram API</a></li>\n<li>Allow users to provide their own logging by using the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerfactory">LoggerFactory</a> provided in the <code is:raw>Microsoft.Extensions.Logging</code> library</li>\n<li>Ensure the library was accessible to as many frameworks & platforms as reasonably practical</li>\n</ul>\n<h2 id="calling-the-api">Calling the API</h2>\n<p>Most of the Deepgram API is accessible via HTTP requests, so the library handles\r\nthose as you\u2019d expect with an HTTPClient. Requests to transcribe audio in\r\nreal-time are handled via WebSockets. Creating a reusable and well-managed\r\nWebSocket client was more challenging because I couldn\u2019t find any real-world\r\nexamples in the documentation. In most cases, the documentation would show\r\nconnecting to a socket, sending a message, receiving a message, and then\r\ndisconnecting. In the real world, I needed a client that would connect, then\r\nsend & receive messages on-demand, and disconnect at a later time that I\r\ndecide.</p>\n<h2 id="bring-your-own-logging">Bring Your Own Logging</h2>\n<p>Logging, like tests, are one of those features that developers like to bypass.\r\nFor years, my projects were scarce on logging and, when included, it was\r\noften added as an afterthought. That said, I was very impressed by one of my\r\ncolleagues, <a href="https://twitter.com/slorello">Steve Lorello</a>, at Vonage, who worked\r\non their .NET SDK. Not only did he do a great job with logging throughout the\r\nSDK, he utilized the <code is:raw>LoggerFactory</code> to provide the ability for developers to\r\nchoose their own logging solution. I contacted him as I was getting started to\r\nwarn him that I was blatantly plagiarizing his work. \u{1F602}</p>\n<p>Luckily, Steve was super gracious and offered to help with any questions.\r\nSeriously, if you aren\u2019t following Steve on <a href="https://twitter.com/slorello">Twitter</a>,\r\nyou should. He\u2019s doing outstanding work at Redis now.</p>\n<h2 id="microsofts-cross-platform-recommendations">Microsoft\u2019s Cross-Platform Recommendations</h2>\n<p>Microsoft recommends starting with a <code is:raw>netstandard2.0</code> target. Since we only plan\r\non supporting platforms & frameworks that can use .NET Standard 2.0 or later,\r\nI started reviewing any dependencies I had added intending to strip it down\r\nto only those compliant with the .NET Standard 2.0.</p>\n<p>I did notice in <a href="https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting">Microsoft\u2019s recommendations</a>\r\nthat in some cases, you may have to shield your users depending on their platform\r\nand framework, as in the example below:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">static</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">class</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">GpsLocation</span></span>\n<span class="line"><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// This project uses multi-targeting to expose device-specific APIs to .NET Standard.</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">static</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">Task</span><span style="color: #C9D1D9">&lt;(</span><span style="color: #FF7B72">double</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">latitude</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">double</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">longitude</span><span style="color: #C9D1D9">)&gt; </span><span style="color: #D2A8FF">GetCoordinatesAsync</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">    {</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">NET461</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">CallDotNetFramworkApi</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">elif</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">WINDOWS_UWP</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">CallUwpApi</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">else</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">throw</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">PlatformNotSupportedException</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">endif</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// Allows callers to check without having to catch PlatformNotSupportedException</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// or replicating the OS check.</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">static</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">bool</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">IsSupported</span></span>\n<span class="line"><span style="color: #C9D1D9">    {</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">get</span></span>\n<span class="line"><span style="color: #C9D1D9">        {</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">NET461</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">WINDOWS_UWP</span></span>\n<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">else</span></span>\n<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">endif</span></span>\n<span class="line"><span style="color: #C9D1D9">        }</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Fortunately, our SDK didn\u2019t require these types of workarounds.</p>\n<h2 id="publishing-to-nuget-with-github-actions">Publishing to Nuget with GitHub Actions</h2>\n<p>Because I created the library in Visual Studio 2022 using the new class library\r\ntemplates, the configuration for building a NuGet package was as painless as\r\nproviding details like the name, description, etc. of the package. I had already\r\ncreated a <a href="https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CI.yml">GitHub Action</a>\r\nto perform CI tasks, so I decided to add another GitHub Action to deploy the\r\npackage to NuGet.org when a new version was released.</p>\n<p>The Continuous Deployment (CD) action contains two jobs: <code is:raw>build</code> and <code is:raw>publish</code>.\r\nThe <code is:raw>build</code> job creates the NuGet package, while the <code is:raw>publish</code> job\r\nhandles uploading the generated package to NuGet.org. The <code is:raw>publish</code> job will\r\nonly run if the <code is:raw>build</code> job completes successfully. You can review the entire\r\nCD workflow file <a href="https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CD.yml">here</a>.</p>\n<h3 id="triggering-a-new-release">Triggering a New Release</h3>\n<p>Once we\u2019re ready to release a new version of the SDK, we create a new GitHub\r\nrelease. The CD action is triggered when that new release is published. Once\r\nit begins, we use the <code is:raw>actions/checkout@v2</code> to check out the code based on the\r\nsha associated with the release.</p>\n<h3 id="restoring-dependencies">Restoring Dependencies</h3>\n<p>Once the repository is retrieved, we install .NET 6 and install any\r\nrequired dependencies from NuGet.</p>\n<h3 id="identifying-version-number">Identifying Version Number</h3>\n<p>Once the dependencies are installed, the next step pulls the version number from\r\nthe GitHub release and outputs that value so that subsequent steps can access\r\nit.</p>\n<h3 id="building--packaging-the-sdk">Building & Packaging the SDK</h3>\n<p>Next, the action calls <code is:raw>dotnet pack</code> and passes various parameters to configure\r\nthe build and packing process to ensure we\u2019ve got the cleanest output\r\npossible.</p>\n<h4 id="configuration">\u2014configuration</h4>\n<p>The <code is:raw>--configuration</code> parameter tells the build process to run in <code is:raw>Release</code>\r\nmode rather than <code is:raw>Debug</code> mode.</p>\n<h4 id="no-restore">\u2014no-restore</h4>\n<p>Because we previously ran <code is:raw>dotnet restore</code> in the action, there\u2019s no need to\r\nrestore packages from Nuget during the build process. The <code is:raw>--no-restore</code>\r\nparameter tells the build process to skip this step to save time.</p>\n<h4 id="output">\u2014output</h4>\n<p>Once we build the SDK with the various targets, we want that clean output saved\r\nto a specific directory. In our case, the <code is:raw>./dist</code> directory.</p>\n<h4 id="-p">-p</h4>\n<p>The <code is:raw>-p</code> parameter is used to pass additional parameters to the build process.\r\nIn our case, we are sending a parameter called <code is:raw>Version</code> and set it to the value of\r\nthe <code is:raw>get_version</code> step, which returned our version number based on the GitHub\r\nrelease.</p>\n<h3 id="archiving-packing-artifacts">Archiving Packing Artifacts</h3>\n<p>The generated package should live in the ./dist directory when the build and\r\npacking process completes. We use the <code is:raw>actions/upload-artifact@v2</code> action to\r\nsave the contents of that directory as an artifact of the action with the name\r\n<code is:raw>dist</code>. We\u2019ll access this artifact in the next step of the process.</p>\n<h3 id="publishing-to-nuget">Publishing to NuGet</h3>\n<p>With the package archived as an artifact, the <code is:raw>publish</code> job will send it\r\nto NuGet.</p>\n<h4 id="downloading-artifacts">Downloading Artifacts</h4>\n<p>The publish job will first download the artifact named dist that was created in\r\nthe build job. These artifacts are downloaded to the <code is:raw>./dist</code> directory.</p>\n<h4 id="pushing-the-package">Pushing the Package</h4>\n<p>Next, the job calls <code is:raw>dotnet nuget push</code> to send any .nupkg file in the <code is:raw>./dist</code>\r\ndirectory to NuGet.org. This requires an access token that NuGet provides.\r\nFor securities sake, we store that token in the repositories secrets and access\r\nit via <code is:raw>${{secrets.NUGET_API_KEY}}</code>.</p>\n<p>With that step complete, the action is finished and stops. NuGet will review\r\nthe uploaded package and release it to the marketplace automatically.</p>\n<h2 id="announcing-the-deepgram-net-sdk">Announcing the Deepgram .NET SDK</h2>\n<p>Of course, with all this work completed, we can announce the new\r\n<a href="https://www.nuget.org/packages/Deepgram/">Deepgram .NET SDK</a>. Try it out, and\r\nlet us know if it helps you get up and running with Deepgram even faster.</p>\n<p>Also, the entire project has been\r\n<a href="https://github.com/deepgram-devs/deepgram-dotnet-sdk">built in the open on GitHub</a>,\r\nand we\u2019d love your input, feedback, and contributions to make it even better!\r\nHappy building!</p>' }, "file": "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/cross-platform-nuget-dotnet/index.md" };
function rawContent() {
  return "\r\nI love the .NET ecosystem. My career started writing classic ASP applications in\r\nVisual Basic and transitioned to C# with .NET 2.0. I remember building my first\r\nASP.NET MVC application and feeling like I had just performed some kind of magic.\r\n\r\nOnce I joined Deepgram, I was very excited about the prospect of building a\r\n.NET SDK from scratch. During the process, I realized that there are certain\r\nthings to consider when building a .NET library to make it as accessible as\r\npossible to developers building with different versions of the .NET Framework\r\nand various platforms.\r\n\r\n> Happy holidays! This post is a contribution to [C# Advent 2021](https://www.csadvent.christmas/). Be\r\n> sure to visit and read all the excellent content focused on C# and the .NET community.\r\n\r\n## Use Case\r\n\r\nBefore we get too deep in the how-to, let's talk about the need I was trying to\r\naddress. Today, Deepgram has two fully supported SDKs; Node.js & Python.\r\nLike .NET, both are great languages with solid ecosystems, but I wanted to\r\nprovide that first-class citizen experience to my beloved .NET developers. \u{1F601}\r\n\r\nAfter a bit of planning, I landed on the following requirements for the SDK:\r\n\r\n*   Enable access to all the publicly available endpoints of the [Deepgram API](https://developers.deepgram.com/api-reference/)\r\n*   Allow users to provide their own logging by using the [LoggerFactory](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerfactory) provided in the `Microsoft.Extensions.Logging` library\r\n*   Ensure the library was accessible to as many frameworks & platforms as reasonably practical\r\n\r\n## Calling the API\r\n\r\nMost of the Deepgram API is accessible via HTTP requests, so the library handles\r\nthose as you'd expect with an HTTPClient. Requests to transcribe audio in\r\nreal-time are handled via WebSockets. Creating a reusable and well-managed\r\nWebSocket client was more challenging because I couldn't find any real-world\r\nexamples in the documentation. In most cases, the documentation would show\r\nconnecting to a socket, sending a message, receiving a message, and then\r\ndisconnecting. In the real world, I needed a client that would connect, then\r\nsend & receive messages on-demand, and disconnect at a later time that I\r\ndecide.\r\n\r\n## Bring Your Own Logging\r\n\r\nLogging, like tests, are one of those features that developers like to bypass.\r\nFor years, my projects were scarce on logging and, when included, it was\r\noften added as an afterthought. That said, I was very impressed by one of my\r\ncolleagues, [Steve Lorello](https://twitter.com/slorello), at Vonage, who worked\r\non their .NET SDK. Not only did he do a great job with logging throughout the\r\nSDK, he utilized the `LoggerFactory` to provide the ability for developers to\r\nchoose their own logging solution. I contacted him as I was getting started to\r\nwarn him that I was blatantly plagiarizing his work. \u{1F602}\r\n\r\nLuckily, Steve was super gracious and offered to help with any questions.\r\nSeriously, if you aren't following Steve on [Twitter](https://twitter.com/slorello),\r\nyou should. He's doing outstanding work at Redis now.\r\n\r\n## Microsoft's Cross-Platform Recommendations\r\n\r\nMicrosoft recommends starting with a `netstandard2.0` target. Since we only plan\r\non supporting platforms & frameworks that can use .NET Standard 2.0 or later,\r\nI started reviewing any dependencies I had added intending to strip it down\r\nto only those compliant with the .NET Standard 2.0.\r\n\r\nI did notice in [Microsoft's recommendations](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting)\r\nthat in some cases, you may have to shield your users depending on their platform\r\nand framework, as in the example below:\r\n\r\n```csharp\r\npublic static class GpsLocation\r\n{\r\n    // This project uses multi-targeting to expose device-specific APIs to .NET Standard.\r\n    public static async Task<(double latitude, double longitude)> GetCoordinatesAsync()\r\n    {\r\n#if NET461\r\n        return CallDotNetFramworkApi();\r\n#elif WINDOWS_UWP\r\n        return CallUwpApi();\r\n#else\r\n        throw new PlatformNotSupportedException();\r\n#endif\r\n    }\r\n\r\n    // Allows callers to check without having to catch PlatformNotSupportedException\r\n    // or replicating the OS check.\r\n    public static bool IsSupported\r\n    {\r\n        get\r\n        {\r\n#if NET461 || WINDOWS_UWP\r\n            return true;\r\n#else\r\n            return false;\r\n#endif\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFortunately, our SDK didn't require these types of workarounds.\r\n\r\n## Publishing to Nuget with GitHub Actions\r\n\r\nBecause I created the library in Visual Studio 2022 using the new class library\r\ntemplates, the configuration for building a NuGet package was as painless as\r\nproviding details like the name, description, etc. of the package. I had already\r\ncreated a [GitHub Action](https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CI.yml)\r\nto perform CI tasks, so I decided to add another GitHub Action to deploy the\r\npackage to NuGet.org when a new version was released.\r\n\r\nThe Continuous Deployment (CD) action contains two jobs: `build` and `publish`.\r\nThe `build` job creates the NuGet package, while the `publish` job\r\nhandles uploading the generated package to NuGet.org. The `publish` job will\r\nonly run if the `build` job completes successfully. You can review the entire\r\nCD workflow file [here](https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CD.yml).\r\n\r\n### Triggering a New Release\r\n\r\nOnce we're ready to release a new version of the SDK, we create a new GitHub\r\nrelease. The CD action is triggered when that new release is published. Once\r\nit begins, we use the `actions/checkout@v2` to check out the code based on the\r\nsha associated with the release.\r\n\r\n### Restoring Dependencies\r\n\r\nOnce the repository is retrieved, we install .NET 6 and install any\r\nrequired dependencies from NuGet.\r\n\r\n### Identifying Version Number\r\n\r\nOnce the dependencies are installed, the next step pulls the version number from\r\nthe GitHub release and outputs that value so that subsequent steps can access\r\nit.\r\n\r\n### Building & Packaging the SDK\r\n\r\nNext, the action calls `dotnet pack` and passes various parameters to configure\r\nthe build and packing process to ensure we've got the cleanest output\r\npossible.\r\n\r\n#### --configuration\r\n\r\nThe `--configuration` parameter tells the build process to run in `Release`\r\nmode rather than `Debug` mode.\r\n\r\n#### --no-restore\r\n\r\nBecause we previously ran `dotnet restore` in the action, there's no need to\r\nrestore packages from Nuget during the build process. The `--no-restore`\r\nparameter tells the build process to skip this step to save time.\r\n\r\n#### --output\r\n\r\nOnce we build the SDK with the various targets, we want that clean output saved\r\nto a specific directory. In our case, the `./dist` directory.\r\n\r\n#### -p\r\n\r\nThe `-p` parameter is used to pass additional parameters to the build process.\r\nIn our case, we are sending a parameter called `Version` and set it to the value of\r\nthe `get_version` step, which returned our version number based on the GitHub\r\nrelease.\r\n\r\n### Archiving Packing Artifacts\r\n\r\nThe generated package should live in the ./dist directory when the build and\r\npacking process completes. We use the `actions/upload-artifact@v2` action to\r\nsave the contents of that directory as an artifact of the action with the name\r\n`dist`. We'll access this artifact in the next step of the process.\r\n\r\n### Publishing to NuGet\r\n\r\nWith the package archived as an artifact, the `publish` job will send it\r\nto NuGet.\r\n\r\n#### Downloading Artifacts\r\n\r\nThe publish job will first download the artifact named dist that was created in\r\nthe build job. These artifacts are downloaded to the `./dist` directory.\r\n\r\n#### Pushing the Package\r\n\r\nNext, the job calls `dotnet nuget push` to send any .nupkg file in the `./dist`\r\ndirectory to NuGet.org. This requires an access token that NuGet provides.\r\nFor securities sake, we store that token in the repositories secrets and access\r\nit via `${{secrets.NUGET_API_KEY}}`.\r\n\r\nWith that step complete, the action is finished and stops. NuGet will review\r\nthe uploaded package and release it to the marketplace automatically.\r\n\r\n## Announcing the Deepgram .NET SDK\r\n\r\nOf course, with all this work completed, we can announce the new\r\n[Deepgram .NET SDK](https://www.nuget.org/packages/Deepgram/). Try it out, and\r\nlet us know if it helps you get up and running with Deepgram even faster.\r\n\r\nAlso, the entire project has been\r\n[built in the open on GitHub](https://github.com/deepgram-devs/deepgram-dotnet-sdk),\r\nand we'd love your input, feedback, and contributions to make it even better!\r\nHappy building!\r\n\r\n        ";
}
function compiledContent() {
  return '<p>I love the .NET ecosystem. My career started writing classic ASP applications in\r\nVisual Basic and transitioned to C# with .NET 2.0. I remember building my first\r\nASP.NET MVC application and feeling like I had just performed some kind of magic.</p>\n<p>Once I joined Deepgram, I was very excited about the prospect of building a\r\n.NET SDK from scratch. During the process, I realized that there are certain\r\nthings to consider when building a .NET library to make it as accessible as\r\npossible to developers building with different versions of the .NET Framework\r\nand various platforms.</p>\n<blockquote>\n<p>Happy holidays! This post is a contribution to <a href="https://www.csadvent.christmas/">C# Advent 2021</a>. Be\r\nsure to visit and read all the excellent content focused on C# and the .NET community.</p>\n</blockquote>\n<h2 id="use-case">Use Case</h2>\n<p>Before we get too deep in the how-to, let\u2019s talk about the need I was trying to\r\naddress. Today, Deepgram has two fully supported SDKs; Node.js & Python.\r\nLike .NET, both are great languages with solid ecosystems, but I wanted to\r\nprovide that first-class citizen experience to my beloved .NET developers. \u{1F601}</p>\n<p>After a bit of planning, I landed on the following requirements for the SDK:</p>\n<ul>\n<li>Enable access to all the publicly available endpoints of the <a href="https://developers.deepgram.com/api-reference/">Deepgram API</a></li>\n<li>Allow users to provide their own logging by using the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerfactory">LoggerFactory</a> provided in the <code is:raw>Microsoft.Extensions.Logging</code> library</li>\n<li>Ensure the library was accessible to as many frameworks & platforms as reasonably practical</li>\n</ul>\n<h2 id="calling-the-api">Calling the API</h2>\n<p>Most of the Deepgram API is accessible via HTTP requests, so the library handles\r\nthose as you\u2019d expect with an HTTPClient. Requests to transcribe audio in\r\nreal-time are handled via WebSockets. Creating a reusable and well-managed\r\nWebSocket client was more challenging because I couldn\u2019t find any real-world\r\nexamples in the documentation. In most cases, the documentation would show\r\nconnecting to a socket, sending a message, receiving a message, and then\r\ndisconnecting. In the real world, I needed a client that would connect, then\r\nsend & receive messages on-demand, and disconnect at a later time that I\r\ndecide.</p>\n<h2 id="bring-your-own-logging">Bring Your Own Logging</h2>\n<p>Logging, like tests, are one of those features that developers like to bypass.\r\nFor years, my projects were scarce on logging and, when included, it was\r\noften added as an afterthought. That said, I was very impressed by one of my\r\ncolleagues, <a href="https://twitter.com/slorello">Steve Lorello</a>, at Vonage, who worked\r\non their .NET SDK. Not only did he do a great job with logging throughout the\r\nSDK, he utilized the <code is:raw>LoggerFactory</code> to provide the ability for developers to\r\nchoose their own logging solution. I contacted him as I was getting started to\r\nwarn him that I was blatantly plagiarizing his work. \u{1F602}</p>\n<p>Luckily, Steve was super gracious and offered to help with any questions.\r\nSeriously, if you aren\u2019t following Steve on <a href="https://twitter.com/slorello">Twitter</a>,\r\nyou should. He\u2019s doing outstanding work at Redis now.</p>\n<h2 id="microsofts-cross-platform-recommendations">Microsoft\u2019s Cross-Platform Recommendations</h2>\n<p>Microsoft recommends starting with a <code is:raw>netstandard2.0</code> target. Since we only plan\r\non supporting platforms & frameworks that can use .NET Standard 2.0 or later,\r\nI started reviewing any dependencies I had added intending to strip it down\r\nto only those compliant with the .NET Standard 2.0.</p>\n<p>I did notice in <a href="https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting">Microsoft\u2019s recommendations</a>\r\nthat in some cases, you may have to shield your users depending on their platform\r\nand framework, as in the example below:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">static</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">class</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">GpsLocation</span></span>\n<span class="line"><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// This project uses multi-targeting to expose device-specific APIs to .NET Standard.</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">static</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">Task</span><span style="color: #C9D1D9">&lt;(</span><span style="color: #FF7B72">double</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">latitude</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">double</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">longitude</span><span style="color: #C9D1D9">)&gt; </span><span style="color: #D2A8FF">GetCoordinatesAsync</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">    {</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">NET461</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">CallDotNetFramworkApi</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">elif</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">WINDOWS_UWP</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">CallUwpApi</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">else</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">throw</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">PlatformNotSupportedException</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">endif</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// Allows callers to check without having to catch PlatformNotSupportedException</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// or replicating the OS check.</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">static</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">bool</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">IsSupported</span></span>\n<span class="line"><span style="color: #C9D1D9">    {</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">get</span></span>\n<span class="line"><span style="color: #C9D1D9">        {</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">NET461</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">WINDOWS_UWP</span></span>\n<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">else</span></span>\n<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">endif</span></span>\n<span class="line"><span style="color: #C9D1D9">        }</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Fortunately, our SDK didn\u2019t require these types of workarounds.</p>\n<h2 id="publishing-to-nuget-with-github-actions">Publishing to Nuget with GitHub Actions</h2>\n<p>Because I created the library in Visual Studio 2022 using the new class library\r\ntemplates, the configuration for building a NuGet package was as painless as\r\nproviding details like the name, description, etc. of the package. I had already\r\ncreated a <a href="https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CI.yml">GitHub Action</a>\r\nto perform CI tasks, so I decided to add another GitHub Action to deploy the\r\npackage to NuGet.org when a new version was released.</p>\n<p>The Continuous Deployment (CD) action contains two jobs: <code is:raw>build</code> and <code is:raw>publish</code>.\r\nThe <code is:raw>build</code> job creates the NuGet package, while the <code is:raw>publish</code> job\r\nhandles uploading the generated package to NuGet.org. The <code is:raw>publish</code> job will\r\nonly run if the <code is:raw>build</code> job completes successfully. You can review the entire\r\nCD workflow file <a href="https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CD.yml">here</a>.</p>\n<h3 id="triggering-a-new-release">Triggering a New Release</h3>\n<p>Once we\u2019re ready to release a new version of the SDK, we create a new GitHub\r\nrelease. The CD action is triggered when that new release is published. Once\r\nit begins, we use the <code is:raw>actions/checkout@v2</code> to check out the code based on the\r\nsha associated with the release.</p>\n<h3 id="restoring-dependencies">Restoring Dependencies</h3>\n<p>Once the repository is retrieved, we install .NET 6 and install any\r\nrequired dependencies from NuGet.</p>\n<h3 id="identifying-version-number">Identifying Version Number</h3>\n<p>Once the dependencies are installed, the next step pulls the version number from\r\nthe GitHub release and outputs that value so that subsequent steps can access\r\nit.</p>\n<h3 id="building--packaging-the-sdk">Building & Packaging the SDK</h3>\n<p>Next, the action calls <code is:raw>dotnet pack</code> and passes various parameters to configure\r\nthe build and packing process to ensure we\u2019ve got the cleanest output\r\npossible.</p>\n<h4 id="configuration">\u2014configuration</h4>\n<p>The <code is:raw>--configuration</code> parameter tells the build process to run in <code is:raw>Release</code>\r\nmode rather than <code is:raw>Debug</code> mode.</p>\n<h4 id="no-restore">\u2014no-restore</h4>\n<p>Because we previously ran <code is:raw>dotnet restore</code> in the action, there\u2019s no need to\r\nrestore packages from Nuget during the build process. The <code is:raw>--no-restore</code>\r\nparameter tells the build process to skip this step to save time.</p>\n<h4 id="output">\u2014output</h4>\n<p>Once we build the SDK with the various targets, we want that clean output saved\r\nto a specific directory. In our case, the <code is:raw>./dist</code> directory.</p>\n<h4 id="-p">-p</h4>\n<p>The <code is:raw>-p</code> parameter is used to pass additional parameters to the build process.\r\nIn our case, we are sending a parameter called <code is:raw>Version</code> and set it to the value of\r\nthe <code is:raw>get_version</code> step, which returned our version number based on the GitHub\r\nrelease.</p>\n<h3 id="archiving-packing-artifacts">Archiving Packing Artifacts</h3>\n<p>The generated package should live in the ./dist directory when the build and\r\npacking process completes. We use the <code is:raw>actions/upload-artifact@v2</code> action to\r\nsave the contents of that directory as an artifact of the action with the name\r\n<code is:raw>dist</code>. We\u2019ll access this artifact in the next step of the process.</p>\n<h3 id="publishing-to-nuget">Publishing to NuGet</h3>\n<p>With the package archived as an artifact, the <code is:raw>publish</code> job will send it\r\nto NuGet.</p>\n<h4 id="downloading-artifacts">Downloading Artifacts</h4>\n<p>The publish job will first download the artifact named dist that was created in\r\nthe build job. These artifacts are downloaded to the <code is:raw>./dist</code> directory.</p>\n<h4 id="pushing-the-package">Pushing the Package</h4>\n<p>Next, the job calls <code is:raw>dotnet nuget push</code> to send any .nupkg file in the <code is:raw>./dist</code>\r\ndirectory to NuGet.org. This requires an access token that NuGet provides.\r\nFor securities sake, we store that token in the repositories secrets and access\r\nit via <code is:raw>${{secrets.NUGET_API_KEY}}</code>.</p>\n<p>With that step complete, the action is finished and stops. NuGet will review\r\nthe uploaded package and release it to the marketplace automatically.</p>\n<h2 id="announcing-the-deepgram-net-sdk">Announcing the Deepgram .NET SDK</h2>\n<p>Of course, with all this work completed, we can announce the new\r\n<a href="https://www.nuget.org/packages/Deepgram/">Deepgram .NET SDK</a>. Try it out, and\r\nlet us know if it helps you get up and running with Deepgram even faster.</p>\n<p>Also, the entire project has been\r\n<a href="https://github.com/deepgram-devs/deepgram-dotnet-sdk">built in the open on GitHub</a>,\r\nand we\u2019d love your input, feedback, and contributions to make it even better!\r\nHappy building!</p>';
}
const $$Astro = createAstro("/Users/sandrarodgers/web-next/blog/src/content/blog/posts/cross-platform-nuget-dotnet/index.md", "https://blog.deepgram.com/", "file:///Users/sandrarodgers/web-next/blog/");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  new Slugger();
  return renderTemplate`<head>${renderHead($$result)}</head><p>I love the .NET ecosystem. My career started writing classic ASP applications in
Visual Basic and transitioned to C# with .NET 2.0. I remember building my first
ASP.NET MVC application and feeling like I had just performed some kind of magic.</p>
<p>Once I joined Deepgram, I was very excited about the prospect of building a
.NET SDK from scratch. During the process, I realized that there are certain
things to consider when building a .NET library to make it as accessible as
possible to developers building with different versions of the .NET Framework
and various platforms.</p>
<blockquote>
<p>Happy holidays! This post is a contribution to <a href="https://www.csadvent.christmas/">C# Advent 2021</a>. Be
sure to visit and read all the excellent content focused on C# and the .NET community.</p>
</blockquote>
<h2 id="use-case">Use Case</h2>
<p>Before we get too deep in the how-to, let’s talk about the need I was trying to
address. Today, Deepgram has two fully supported SDKs; Node.js & Python.
Like .NET, both are great languages with solid ecosystems, but I wanted to
provide that first-class citizen experience to my beloved .NET developers. 😁</p>
<p>After a bit of planning, I landed on the following requirements for the SDK:</p>
<ul>
<li>Enable access to all the publicly available endpoints of the <a href="https://developers.deepgram.com/api-reference/">Deepgram API</a></li>
<li>Allow users to provide their own logging by using the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerfactory">LoggerFactory</a> provided in the <code>Microsoft.Extensions.Logging</code> library</li>
<li>Ensure the library was accessible to as many frameworks & platforms as reasonably practical</li>
</ul>
<h2 id="calling-the-api">Calling the API</h2>
<p>Most of the Deepgram API is accessible via HTTP requests, so the library handles
those as you’d expect with an HTTPClient. Requests to transcribe audio in
real-time are handled via WebSockets. Creating a reusable and well-managed
WebSocket client was more challenging because I couldn’t find any real-world
examples in the documentation. In most cases, the documentation would show
connecting to a socket, sending a message, receiving a message, and then
disconnecting. In the real world, I needed a client that would connect, then
send & receive messages on-demand, and disconnect at a later time that I
decide.</p>
<h2 id="bring-your-own-logging">Bring Your Own Logging</h2>
<p>Logging, like tests, are one of those features that developers like to bypass.
For years, my projects were scarce on logging and, when included, it was
often added as an afterthought. That said, I was very impressed by one of my
colleagues, <a href="https://twitter.com/slorello">Steve Lorello</a>, at Vonage, who worked
on their .NET SDK. Not only did he do a great job with logging throughout the
SDK, he utilized the <code>LoggerFactory</code> to provide the ability for developers to
choose their own logging solution. I contacted him as I was getting started to
warn him that I was blatantly plagiarizing his work. 😂</p>
<p>Luckily, Steve was super gracious and offered to help with any questions.
Seriously, if you aren’t following Steve on <a href="https://twitter.com/slorello">Twitter</a>,
you should. He’s doing outstanding work at Redis now.</p>
<h2 id="microsofts-cross-platform-recommendations">Microsoft’s Cross-Platform Recommendations</h2>
<p>Microsoft recommends starting with a <code>netstandard2.0</code> target. Since we only plan
on supporting platforms & frameworks that can use .NET Standard 2.0 or later,
I started reviewing any dependencies I had added intending to strip it down
to only those compliant with the .NET Standard 2.0.</p>
<p>I did notice in <a href="https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting">Microsoft’s recommendations</a>
that in some cases, you may have to shield your users depending on their platform
and framework, as in the example below:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">static</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">class</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">GpsLocation</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// This project uses multi-targeting to expose device-specific APIs to .NET Standard.</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">static</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">Task</span><span style="color: #C9D1D9">&lt;(</span><span style="color: #FF7B72">double</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">latitude</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">double</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">longitude</span><span style="color: #C9D1D9">)&gt; </span><span style="color: #D2A8FF">GetCoordinatesAsync</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #C9D1D9">    {</span></span>
<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">NET461</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">CallDotNetFramworkApi</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">elif</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">WINDOWS_UWP</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">CallUwpApi</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">else</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">throw</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">PlatformNotSupportedException</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">endif</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// Allows callers to check without having to catch PlatformNotSupportedException</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// or replicating the OS check.</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">static</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">bool</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">IsSupported</span></span>
<span class="line"><span style="color: #C9D1D9">    {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">get</span></span>
<span class="line"><span style="color: #C9D1D9">        {</span></span>
<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">NET461</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">WINDOWS_UWP</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">else</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">#</span><span style="color: #FF7B72">endif</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>Fortunately, our SDK didn’t require these types of workarounds.</p>
<h2 id="publishing-to-nuget-with-github-actions">Publishing to Nuget with GitHub Actions</h2>
<p>Because I created the library in Visual Studio 2022 using the new class library
templates, the configuration for building a NuGet package was as painless as
providing details like the name, description, etc. of the package. I had already
created a <a href="https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CI.yml">GitHub Action</a>
to perform CI tasks, so I decided to add another GitHub Action to deploy the
package to NuGet.org when a new version was released.</p>
<p>The Continuous Deployment (CD) action contains two jobs: <code>build</code> and <code>publish</code>.
The <code>build</code> job creates the NuGet package, while the <code>publish</code> job
handles uploading the generated package to NuGet.org. The <code>publish</code> job will
only run if the <code>build</code> job completes successfully. You can review the entire
CD workflow file <a href="https://github.com/deepgram-devs/deepgram-dotnet-sdk/blob/main/.github/workflows/CD.yml">here</a>.</p>
<h3 id="triggering-a-new-release">Triggering a New Release</h3>
<p>Once we’re ready to release a new version of the SDK, we create a new GitHub
release. The CD action is triggered when that new release is published. Once
it begins, we use the <code>actions/checkout@v2</code> to check out the code based on the
sha associated with the release.</p>
<h3 id="restoring-dependencies">Restoring Dependencies</h3>
<p>Once the repository is retrieved, we install .NET 6 and install any
required dependencies from NuGet.</p>
<h3 id="identifying-version-number">Identifying Version Number</h3>
<p>Once the dependencies are installed, the next step pulls the version number from
the GitHub release and outputs that value so that subsequent steps can access
it.</p>
<h3 id="building--packaging-the-sdk">Building & Packaging the SDK</h3>
<p>Next, the action calls <code>dotnet pack</code> and passes various parameters to configure
the build and packing process to ensure we’ve got the cleanest output
possible.</p>
<h4 id="configuration">—configuration</h4>
<p>The <code>--configuration</code> parameter tells the build process to run in <code>Release</code>
mode rather than <code>Debug</code> mode.</p>
<h4 id="no-restore">—no-restore</h4>
<p>Because we previously ran <code>dotnet restore</code> in the action, there’s no need to
restore packages from Nuget during the build process. The <code>--no-restore</code>
parameter tells the build process to skip this step to save time.</p>
<h4 id="output">—output</h4>
<p>Once we build the SDK with the various targets, we want that clean output saved
to a specific directory. In our case, the <code>./dist</code> directory.</p>
<h4 id="-p">-p</h4>
<p>The <code>-p</code> parameter is used to pass additional parameters to the build process.
In our case, we are sending a parameter called <code>Version</code> and set it to the value of
the <code>get_version</code> step, which returned our version number based on the GitHub
release.</p>
<h3 id="archiving-packing-artifacts">Archiving Packing Artifacts</h3>
<p>The generated package should live in the ./dist directory when the build and
packing process completes. We use the <code>actions/upload-artifact@v2</code> action to
save the contents of that directory as an artifact of the action with the name
<code>dist</code>. We’ll access this artifact in the next step of the process.</p>
<h3 id="publishing-to-nuget">Publishing to NuGet</h3>
<p>With the package archived as an artifact, the <code>publish</code> job will send it
to NuGet.</p>
<h4 id="downloading-artifacts">Downloading Artifacts</h4>
<p>The publish job will first download the artifact named dist that was created in
the build job. These artifacts are downloaded to the <code>./dist</code> directory.</p>
<h4 id="pushing-the-package">Pushing the Package</h4>
<p>Next, the job calls <code>dotnet nuget push</code> to send any .nupkg file in the <code>./dist</code>
directory to NuGet.org. This requires an access token that NuGet provides.
For securities sake, we store that token in the repositories secrets and access
it via <code>\${{secrets.NUGET_API_KEY}}</code>.</p>
<p>With that step complete, the action is finished and stops. NuGet will review
the uploaded package and release it to the marketplace automatically.</p>
<h2 id="announcing-the-deepgram-net-sdk">Announcing the Deepgram .NET SDK</h2>
<p>Of course, with all this work completed, we can announce the new
<a href="https://www.nuget.org/packages/Deepgram/">Deepgram .NET SDK</a>. Try it out, and
let us know if it helps you get up and running with Deepgram even faster.</p>
<p>Also, the entire project has been
<a href="https://github.com/deepgram-devs/deepgram-dotnet-sdk">built in the open on GitHub</a>,
and we’d love your input, feedback, and contributions to make it even better!
Happy building!</p>`;
}, "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/cross-platform-nuget-dotnet/index.md");

export { compiledContent, $$Index as default, frontmatter, metadata, rawContent };
