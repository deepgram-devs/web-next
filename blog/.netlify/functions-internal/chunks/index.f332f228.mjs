import { c as createAstro, a as createComponent, r as renderTemplate, b as renderHead, d as renderComponent } from '../entry.mjs';
import Slugger from 'github-slugger';
import '@astrojs/netlify/netlify-functions.js';
import 'preact';
import 'preact-render-to-string';
import 'vue';
import 'vue/server-renderer';
import 'html-escaper';
import 'node-html-parser';
import 'axios';
/* empty css                           *//* empty css                           *//* empty css                           *//* empty css                           *//* empty css                          */import 'clone-deep';
import 'slugify';
import 'shiki';
/* empty css                           */import '@astrojs/rss';
/* empty css                           */import 'mime';
import 'cookie';
import 'kleur/colors';
import 'string-width';
import 'path-browserify';
import 'path-to-regexp';

const metadata = { "headings": [{ "depth": 2, "slug": "introduction---async-and-the-composition-api", "text": "Introduction - Async and the Composition API" }, { "depth": 2, "slug": "composables-and-asynchronous-logic", "text": "Composables and Asynchronous Logic" }, { "depth": 2, "slug": "composable-using-async-and-await", "text": "Composable Using Async and Await" }, { "depth": 3, "slug": "usedeepgramkey-composable", "text": "useDeepgramKey Composable" }, { "depth": 3, "slug": "tip-1---use-async-and-await-to-write-a-composable-that-returns-a-promise", "text": "Tip #1 - Use async and await to write a composable that returns a promise." }, { "depth": 2, "slug": "composable-that-relies-on-asynchronous-events-in-other-composables", "text": "Composable That Relies on Asynchronous Events in Other Composables" }, { "depth": 3, "slug": "usemicrophone-composable", "text": "useMicrophone Composable" }, { "depth": 3, "slug": "usedeepgramsocket-composable", "text": "useDeepgramSocket Composable" }, { "depth": 3, "slug": "tip-2---use-then-to-chain-each-composable-that-returns-a-promise-to-run-asynchronously-if-returned-values-need-to-be-in-the-same-scope", "text": "Tip #2 - Use .then() to chain each composable that returns a promise to run asynchronously if returned values need to be in the same scope" }, { "depth": 3, "slug": "opendeepgramsocket-function", "text": "openDeepgramSocket Function" }, { "depth": 3, "slug": "vue-watch-to-update-transcript-status", "text": "Vue watch to Update Transcript Status" }, { "depth": 3, "slug": "tip-3-use-watch-to-update-a-value-in-the-component-and-trigger-a-side-effect-in-sync-with-that-change", "text": "Tip #3: Use watch to update a value in the component and trigger a side effect in-sync with that change" }, { "depth": 2, "slug": "conclusion", "text": "Conclusion" }], "source": "\nThis is the final post of my series, \"How to Build a Live Streaming Web Application with Amazon IVS and Deepgram.\"\n\n<Panel type=\"info\" title=\"Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)\">\n<ol> \n<li><a href=\"https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/\">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>\n<li><a href=\"https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/\"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>\n<li><a href=\"https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/\"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li>\n\n<li><a href=\"https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/\"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li>\n</ol>\n</Panel>\n\nFor today's post, I recommend getting a Deepgram API key to use in this project, which anyone can get by heading to the [Deepgram console](https://console.deepgram.com/signup?jump=keys).\n\n## Introduction - Async and the Composition API\n\nToday's post will cover how to use Vue 3 composables to power a text-captions component that integrates with Deepgram's speech-to-text API. Some of the things I'll cover today are:\n\n*   Using `async` and `await` to write a composable that fetches a temporary API key from Deepgram.\n*   Using Vue 3's `watch` method to react to data that is updating in real-time as Deepgram sends a text transcription back through a browser WebSocket.\n*   Writing logic that is sensitive to the order things occur - i.e., asynchronous logic that flows between the component and the composable.\n\nThis post assumes some knowledge of Vue 3, in particular Vue composables. For a refresher on Vue 3, check out my series [Diving Into Vue 3](https://blog.deepgram.com/diving-into-vue-3-getting-started/).\n\nToday I will build the `AudioCaptions.vue` component. (For the `VideoPlayer` component, see my [previous post](https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/#composable-to-bring-in-an-external-script) in the series.) Here is the page with minimal styling. I've put a red box around the `AudioCaptions.vue` component:\n\n![StreamChannel page emphasizing AudioCaptions.vue component](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/StreamChannel_captions.png)\n\nWhere it says \"Deepgram Not Connected,\" there will be text captions that display in real-time along with the video stream.\n\nHere is a diagram of what I will build today:\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/AudioTranscription_Final.png\" alt=\"Audio Transcription Feature Diagram\" style=\"width: 75%; margin:auto;\">\n\nThis feature will rely on Vue 3's Composition API, especially Vue Composables, to put Deepgram captions on the screen.\n\n## Composables and Asynchronous Logic\n\nComposables are a feature of the Vue 3 Composition API; **custom composables** are the ones I build myself with the intention of encapsulating reusable, stateful logic.\n\nI feel like it is somewhat of an art learning how to write composables. The key to writing them well is making them as generic as possible so that they can be reused in many contexts.\n\nFor example, I could write a function that does everything I need it to do to create text captions on the screen using the Deepgram API - the function would include logic to get an API key, turn on the browser microphone, get the audio stream from the microphone, and then send the stream through a WebSocket. I could call the composable `useDeepgram`.\n\nHowever, there are several logical concerns in that one large `useDeepgram` function that could be broken out into other composable functions. While it's easier just to write it all in one file, it means I could only use it in situations that are exactly like this project.\n\nThe challenge of breaking it apart is that the logic to get the transcription from Deepgram depends on certain things happening first, such as the API key arriving and the microphone being turned on. When I break that logic apart into separate functions, I have to be conscious of the order that those functions run, the state that gets updated in multiple functions (and making sure the functions stay in sync), and the conventions for writing asynchronous logic. Not to mention the challenge of updating the component in real-time with the data that comes through the WebSocket.\n\nThe point is that writing composables in the real world can be challenging, so learning some strategies for dealing with more complicated situations, particularly asynchronous logic, is worth it. Because the beauty of composables is that if you write them well, you have a clean, reusable function that you'll return to again and again.\n\n## Composable Using Async and Await\n\nHere is the `AudioCaptions.vue` component right now, before I add the feature logic:\n\n```js\n<template>\n  <div>\n    <p>Status Will Go Here</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  setup() {\n    return {};\n  },\n};\n<\/script>\n```\n\nIn the template where it says \"Status Will Go Here,\" I plan to add a reactive variable. That value will update to show the audio captions after everything is working. For now, I've just hard-coded that text.\n\n### useDeepgramKey Composable\n\nThe first composable I'm going to write will be called `useDeepgramKey.js`, and its purpose will be to fetch a temporary API key. If I fetch a temporary API key from Deepgram, I can use the key in the browser and not worry about exposing the key since the key will expire almost immediately. Read more about this feature in a blog post that Kevin wrote about [protecting your Deepgram API key](https://blog.deepgram.com/protecting-api-key/).\n\nOn the backend, I have set up an endpoint to receive the fetch request from the composable. That endpoint can be seen in the `server.js` file in my repo [here](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/deepgram-composables/server.js).\n\nNow I'll create the `useDeepgramKey.js` composable.\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/useDeepgramKey.png\" alt=\"Create useDeepgramKey.js file in Composables folder\" style=\"width: 50%; margin:auto;\">\n\n### Tip #1 - Use async and await to write a composable that returns a promise.\n\nI will do three things to make this composable run asynchronously:\n\n1.  Write the composable as an async function using `export default async` to make the composable itself know to wait for the fetch request to finish.\n\n2.  Encapsulate the fetch request in its own async function called `async function getKey()`, which is called inside the composable using the `await` keyword.\n\n3.  In the component `AudioCaptions`, use a `.then()` when I call the composable so that I get access to the returned state after the Promise completes.\n\nHere is the composable to start. The `key` will update to be the API key when that arrives from the backend, and `DGStatus` will update with a message if there is an error.\n\n```js\nimport { ref } from 'vue'\nlet key = ref('')\nlet DGStatus = ref('Deepgram Not Connected')\n\nexport default async function useDeepgramKey() {\n  return { key, DGStatus }\n}\n```\n\nNow I'll write an async function that will perform all the logic of getting the temporary key. I'll name it `getKey()` and I will use a try-catch block to make the fetch request and handle any errors:\n\n```js\nasync function getKey() {\n  try {\n    const res = await fetch('http://localhost:8080/deepgram-token', {\n      headers: { 'Content-type': 'application/json' },\n    })\n    if (res) {\n      const response = await res.json()\n      // update with temporary api key:\n      key.value = response.key\n      return key\n    }\n  } catch (error) {\n    if (error) {\n      // update to show error message on screen:\n      DGStatus.value = 'Error. Please try again.'\n    }\n  }\n}\n```\n\nTo make sure this runs, I need to call the function in the composable. I will add `await getKey()` to the async function that will be exported. Using `await` is to go along with `async` that I used on the composable function itself. These two keywords together tell the composable that it must wait until the `getKey` function resolves.\n\nHere is the composable in its entirety:\n\n```js\nimport { ref } from 'vue'\nlet key = ref('')\nlet DGStatus = ref('Deepgram Not Connected')\n\nasync function getKey() {\n  try {\n    const res = await fetch('http://localhost:8080/deepgram-token', {\n      headers: { 'Content-type': 'application/json' },\n    })\n    if (res) {\n      const response = await res.json()\n      // update with temporary api key:\n      key.value = response.key\n      return key\n    }\n  } catch (error) {\n    if (error) {\n      // update to show error message on screen:\n      DGStatus.value = 'Error. Please try again.'\n    }\n  }\n}\n\nexport default async function useDeepgramKey() {\n  // call function:\n  await getKey()\n  return { key, DGStatus }\n}\n```\n\nI can `console.log(key.value)` to make sure the key is arriving successfully.\n\nThen I'll go back to `AudioCaptions.vue` to wire up a reactive reference that will update to show the error status message if the key does not arrive. I'll create a `ref` called `deepgramStatus` and replace the hardcoded \"Status Will Go Here\" with that variable.\n\n```js\n<template>\n  <div>\n    <p>{{ deepgramStatus }}</p>\n  </div>\n</template>\n\n<script>\nimport { ref } from \"vue\";\nexport default {\n  setup() {\n    let deepgramStatus = ref(\"Deepgram Not Connected\");\n    return { deepgramStatus };\n  },\n};\n<\/script>\n```\n\n**I also need to call the composable function in the component.** If I don't call it, the logic won't run. Since it is a promise, I will use a `.then()` method on it to get the result, which will be the `key` and `DGStatus` values. I only need the `DGStatus`, so I'll set that to the `deepgramStatus` ref.\n\nHere's the `AudioCaptions.vue` script now:\n\n```js\n<script>\nimport { ref } from \"vue\";\nimport useDeepgramKey from \"@/composables/useDeepgramKey\";\nexport default {\n  setup() {\n    let deepgramStatus = ref(\"Deepgram Not Connected\");\n\n    // use .then() to wait for promise resolution\n    useDeepgramKey().then((res) => {\n      deepgramStatus.value = res.DGStatus.value;\n    });\n\n    return { deepgramStatus };\n  },\n};\n<\/script>\n```\n\nIf I want to see the error message, I can delete a character in the fetch request URL, making it `http://localhost:8080/deepgram-toke`, which is incorrect. That will cause the fetch request to fail, and I'll see the error message.\n\n![Error. Please Try Again.](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/error-message.png)\n\n## Composable That Relies on Asynchronous Events in Other Composables\n\nNow I will begin to tackle the `useDeepgramSocket` composable. This composable will take an audio stream from the browser microphone and send it to Deepgram by way of a browser WebSocket. It relies on two other composables to do this:\n\n1.  `useDeepgramKey` - I need to get the temporary API key from the composable I just made, `useDeepgramKey`, to send it in the request to Deepgram; otherwise, Deepgram won't be able to fulfill the request.\n\n2.  `useMicrophone` - I need to get an audio stream from the browser microphone. That audio data will be sent to Deepgram to be transcribed into text that will be put onto the screen as captions.\n\nI haven't created the `useMicrophone` composable yet, so I'll make a quick detour right now to write that composable.\n\n### useMicrophone Composable\n\nThe `useMicrophone` composable will rely on the browser Media Stream API and the `getUserMedia` method to request permission to use the browser microphone of the user and pull the audio from it. Since there are several other blog posts in [Deepgram Docs](https://developers.deepgram.com/) about this nifty API, I won't go into detail about how it works. Check out [Brian's post](https://blog.deepgram.com/getting-started-with-mediastream-api/) for a general introduction to it.\n\nThis composable is also going to use an `async` function since the `getUserMedia` method requires waiting for the user to give permission to use the microphone. The time involved means that this method returns a promise. I already know how to write this type of composable since I just did it in the last section.\n\nI'll make the composable an `async` function and I'll also write the logic to get the audio stream as an `async` function. Here is the composable in its entirety:\n\n```js\nasync function getAudio() {\n  try {\n    const mediaStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n    })\n    const mediaRecorder = new MediaRecorder(mediaStream, {\n      audio: true,\n    })\n    return mediaRecorder\n  } catch (e) {\n    console.error(e)\n  }\n}\n\nexport default async function useMicrophone() {\n  const microphone = await getAudio()\n  return { microphone }\n}\n```\n\nNow it's ready for me to use in the next composable I will write.\n\n### useDeepgramSocket Composable\n\nFirst, I'll import this composable into `AudioCaptions.vue` and call it. That way, everything I write in `useDeepgramSocket` will run and I can check my progress as I build this composable.\n\n```js\n<script>\nimport { ref } from \"vue\";\nimport useDeepgramKey from \"@/composables/useDeepgramKey\";\nimport useDeepgramSocket from \"@/composables/useDeepgramSocket\";\nexport default {\n  setup() {\n    let deepgramStatus = ref(\"Deepgram Not Connected\");\n\n    useDeepgramKey().then((res) => {\n      deepgramStatus.value = res.DGStatus.value;\n    });\n\n    // call this so the composable runs as I work on it\n    useDeepgramSocket();\n\n    return { deepgramStatus };\n  },\n};\n<\/script>\n```\n\nI know I need to have access to the temporary API key from `useDeepgramToken` and to the microphone from `useMicrophone`. **I will start by setting up my composable to show that I have access to them within the same scope.**\n\nBoth composables return a promise. That means I will need to use syntax that will make the functions run but wait for the promise to resolve before moving on to the next thing.\n\n### Tip #2 - Use `.then()` to chain each composable that returns a promise to run asynchronously if returned values need to be in the same scope\n\nHere's what I mean:\n\n```js\nimport useDeepgramKey from './useDeepgramKey'\nimport useMicrophone from './useMicrophone'\n\nexport default function useDeepgramSocket() {\n  // chain .then() methods for each composable:\n  useDeepgramKey().then((keyRes) => {\n    useMicrophone().then((microphoneRes) => {\n      let apiKey = keyRes.key.value\n      let microphone = microphoneRes.microphone\n\n      console.log(apiKey)\n      console.log(microphone)\n\n      // WEBSOCKET FUNCTION WILL GO HERE\n    })\n  })\n  return {}\n}\n```\n\nI have named the result argument in each `.then()` a name that shows which composable they came from - `keyRes` and `microphoneRes`, which makes it easy for me to see what each of them represents. The `keyRes` is a `ref`, so I must drill all the way down to the `.value` property. The `microphoneRes` is a Vue 3 `readonly` property, which is why I don't have to drill down as far.\n\nNow that I have the values, I can write a function that encapsulates the logic to open the WebSocket.\n\n### openDeepgramSocket Function\n\nI will write a function called `openDeepgramSocket` that will do the following:\n\n*   Create the socket with `new WebSocket(URL, deepgram protocols)`.\n*   Open the socket with `socket.onopen`. When it opens, I'll add an event listener to the microphone to take in the audio stream and send it through the socket.\n*   Have `socket.onclose` listen for when the channel closes.\n\nI will also create a reactive reference called `DGStatus_socket` to update the status of the transcription along the way. That value will be returned to the `AudioCaptions.vue` component as the text captions.\n\nHere is the function:\n\n```js\nfunction openDeepgramSocket(apiKey, microphone) {\n  const socket = new WebSocket(\n    'wss://api.deepgram.com/v1/listen?punctuate=true',\n    ['token', apiKey]\n  )\n\n  socket.onopen = () => {\n    if (microphone.state != 'recording') {\n      DGStatus_socket.value = 'Connected to Deepgram'\n      console.log('Connection opened.')\n\n      microphone.addEventListener('dataavailable', async (event) => {\n        if (event.data.size > 0 && socket.readyState == 1) {\n          socket.send(event.data)\n        }\n      })\n\n      microphone.start(200)\n    }\n  }\n\n  socket.onmessage = (message) => {\n    const received = JSON.parse(message.data)\n    const transcript = received.channel.alternatives[0].transcript\n    if (transcript && received.is_final) {\n      DGStatus_socket.value = transcript + ''\n      // shows the transcript in the console:\n      console.log(DGStatus_socket.value)\n    }\n  }\n\n  socket.onclose = () => {\n    console.log('Connection closed.')\n  }\n}\n```\n\nI have to make sure to call the function in the composable:\n\n```js\nexport default function useDeepgramSocket() {\n  useDeepgramKey().then((keyRes) => {\n    useMicrophone().then((microphoneRes) => {\n      let apiKey = keyRes.key.value\n      let microphone = microphoneRes.microphone\n\n      // Call function:\n      openDeepgramSocket(apiKey, microphone)\n    })\n  })\n  return {}\n}\n```\n\nNow I see the transcript coming back to me because I have added a console.log to show it:\n\n![transcript returned in console with messages](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/transcript_console.png)\n\nI'm ready to put that transcript onto the screen as the captions!\n\n### Vue watch to Update Transcript Status\n\nI will use the reactive reference `DGStatus_socket` in the composable `useDeepgramSocket` to update the captions in `AudioCaptions.vue`. To do that, I need to return it from the composable and then destructure it in the component `AudioCaptions.vue`.\n\nHere is the `useDeepgramSocket` composable where I return the `DGStatus_socket` value (excluding the large `openDeepgramSocket` function):\n\n```js\nimport { ref } from \"vue\";\nimport useDeepgramKey from \"./useDeepgramKey\";\nimport useMicrophone from \"./useMicrophone\";\n\n// create status ref\nlet DGStatus_socket = ref(\"\");\n\nfunction openDeepgramSocket(apiKey, microphone) {\n...\n}\n\nexport default function useDeepgramSocket() {\n  useDeepgramKey().then((keyRes) => {\n    useMicrophone().then((microphoneRes) => {\n      let apiKey = keyRes.key.value;\n      let microphone = microphoneRes.microphone;\n\n      openDeepgramSocket(apiKey, microphone);\n    });\n  });\n\n  // return status ref to component\n  return { DGStatus_socket };\n}\n```\n\nIn `AudioCaptions.vue`, I destructure the `DGStatus_socket` so I have access to it:\n\n```js\nconst { DGStatus_socket } = useDeepgramSocket()\n```\n\nIs it working? Not yet. I have to update the `deepgramStatus` ref that is connected to the template if I want to see those captions on the screen.\n\n### Tip #3: Use watch to update a value in the component and trigger a side effect in-sync with that change\n\nAccording to the Vue documentation, `watch` is used in \"cases where we need to perform 'side effects' in reaction to state changes - for example, mutating the DOM or changing another piece of state based on the result of an async operation.\"\n\nThis example of putting the captions on the screen fits that description exactly. I want the `deepgramStatus` value to update if `DGStatus_socket` from the composable `useDeepgramSocket` changes, and I want that state change to trigger the effect of the text updating in the DOM.\n\nI will add a watcher to the `AudioCaptions` component:\n\n```js\nwatch(DGStatus_socket, () => {\n  deepgramStatus.value = DGStatus_socket.value\n})\n```\n\nAnd this is what the component in its entirety looks like now:\n\n```js\n<template>\n  <div>\n    <p>{{ deepgramStatus }}</p>\n  </div>\n</template>\n\n<script>\nimport { ref, watch } from \"vue\";\nimport useDeepgramKey from \"@/composables/useDeepgramKey\";\nimport useDeepgramSocket from \"@/composables/useDeepgramSocket\";\nexport default {\n  setup() {\n    let deepgramStatus = ref(\"Deepgram Not Connected\");\n\n    useDeepgramKey().then((res) => {\n      deepgramStatus.value = res.DGStatus.value;\n    });\n\n    const { DGStatus_socket } = useDeepgramSocket();\n\n    watch(DGStatus_socket, () => {\n      deepgramStatus.value = DGStatus_socket.value;\n    });\n\n    return { deepgramStatus };\n  },\n};\n<\/script>\n\n```\n\nAnd with that, I have my captions powered by Deepgram! Check out the code for this post on my repo branch [deepgram-composables](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/deepgram-composables).\n\n![Captions working](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/captions.gif)\n\n## Conclusion\n\nToday I built the final component of my project, a full-stack video streaming application with text captions.\n\nThis post contained the barebones logic for the captions feature, but in my actual project, I have added styling to improve the user experience, and I've added buttons to turn the captions on or off. Check out the repo [here](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram).\n\nHere is the final project:\n\n![Final project demo](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/VideoExample.gif)\n\nIt's been a great experience learning about Amazon IVS and Deepgram, and I've gotten the chance to get a better taste of how to take advantage Vue 3's composition API.\n\nIf you enjoyed this series, please follow me on [Twitter](https://twitter.com/sandra_rodgers_) to receive updates on future series I have in the works!\n\n        ", "html": '<p>This is the final post of my series, \u201CHow to Build a Live Streaming Web Application with Amazon IVS and Deepgram.\u201D</p>\n<Panel type="info" title="Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)"><ol><li><a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>\n<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>\n<li><a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li><li><a href="https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li></ol></Panel>\n<p>For today\u2019s post, I recommend getting a Deepgram API key to use in this project, which anyone can get by heading to the <a href="https://console.deepgram.com/signup?jump=keys">Deepgram console</a>.</p>\n<h2 id="introduction---async-and-the-composition-api">Introduction - Async and the Composition API</h2>\n<p>Today\u2019s post will cover how to use Vue 3 composables to power a text-captions component that integrates with Deepgram\u2019s speech-to-text API. Some of the things I\u2019ll cover today are:</p>\n<ul>\n<li>Using <code is:raw>async</code> and <code is:raw>await</code> to write a composable that fetches a temporary API key from Deepgram.</li>\n<li>Using Vue 3\u2019s <code is:raw>watch</code> method to react to data that is updating in real-time as Deepgram sends a text transcription back through a browser WebSocket.</li>\n<li>Writing logic that is sensitive to the order things occur - i.e., asynchronous logic that flows between the component and the composable.</li>\n</ul>\n<p>This post assumes some knowledge of Vue 3, in particular Vue composables. For a refresher on Vue 3, check out my series <a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3</a>.</p>\n<p>Today I will build the <code is:raw>AudioCaptions.vue</code> component. (For the <code is:raw>VideoPlayer</code> component, see my <a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/#composable-to-bring-in-an-external-script">previous post</a> in the series.) Here is the page with minimal styling. I\u2019ve put a red box around the <code is:raw>AudioCaptions.vue</code> component:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/StreamChannel_captions.png" alt="StreamChannel page emphasizing AudioCaptions.vue component"></p>\n<p>Where it says \u201CDeepgram Not Connected,\u201D there will be text captions that display in real-time along with the video stream.</p>\n<p>Here is a diagram of what I will build today:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/AudioTranscription_Final.png" alt="Audio Transcription Feature Diagram" style="width: 75%; margin:auto;" />\n<p>This feature will rely on Vue 3\u2019s Composition API, especially Vue Composables, to put Deepgram captions on the screen.</p>\n<h2 id="composables-and-asynchronous-logic">Composables and Asynchronous Logic</h2>\n<p>Composables are a feature of the Vue 3 Composition API; <strong>custom composables</strong> are the ones I build myself with the intention of encapsulating reusable, stateful logic.</p>\n<p>I feel like it is somewhat of an art learning how to write composables. The key to writing them well is making them as generic as possible so that they can be reused in many contexts.</p>\n<p>For example, I could write a function that does everything I need it to do to create text captions on the screen using the Deepgram API - the function would include logic to get an API key, turn on the browser microphone, get the audio stream from the microphone, and then send the stream through a WebSocket. I could call the composable <code is:raw>useDeepgram</code>.</p>\n<p>However, there are several logical concerns in that one large <code is:raw>useDeepgram</code> function that could be broken out into other composable functions. While it\u2019s easier just to write it all in one file, it means I could only use it in situations that are exactly like this project.</p>\n<p>The challenge of breaking it apart is that the logic to get the transcription from Deepgram depends on certain things happening first, such as the API key arriving and the microphone being turned on. When I break that logic apart into separate functions, I have to be conscious of the order that those functions run, the state that gets updated in multiple functions (and making sure the functions stay in sync), and the conventions for writing asynchronous logic. Not to mention the challenge of updating the component in real-time with the data that comes through the WebSocket.</p>\n<p>The point is that writing composables in the real world can be challenging, so learning some strategies for dealing with more complicated situations, particularly asynchronous logic, is worth it. Because the beauty of composables is that if you write them well, you have a clean, reusable function that you\u2019ll return to again and again.</p>\n<h2 id="composable-using-async-and-await">Composable Using Async and Await</h2>\n<p>Here is the <code is:raw>AudioCaptions.vue</code> component right now, before I add the feature logic:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;Status Will Go Here&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    return {};</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>In the template where it says \u201CStatus Will Go Here,\u201D I plan to add a reactive variable. That value will update to show the audio captions after everything is working. For now, I\u2019ve just hard-coded that text.</p>\n<h3 id="usedeepgramkey-composable">useDeepgramKey Composable</h3>\n<p>The first composable I\u2019m going to write will be called <code is:raw>useDeepgramKey.js</code>, and its purpose will be to fetch a temporary API key. If I fetch a temporary API key from Deepgram, I can use the key in the browser and not worry about exposing the key since the key will expire almost immediately. Read more about this feature in a blog post that Kevin wrote about <a href="https://blog.deepgram.com/protecting-api-key/">protecting your Deepgram API key</a>.</p>\n<p>On the backend, I have set up an endpoint to receive the fetch request from the composable. That endpoint can be seen in the <code is:raw>server.js</code> file in my repo <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/deepgram-composables/server.js">here</a>.</p>\n<p>Now I\u2019ll create the <code is:raw>useDeepgramKey.js</code> composable.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/useDeepgramKey.png" alt="Create useDeepgramKey.js file in Composables folder" style="width: 50%; margin:auto;" />\n<h3 id="tip-1---use-async-and-await-to-write-a-composable-that-returns-a-promise">Tip #1 - Use async and await to write a composable that returns a promise.</h3>\n<p>I will do three things to make this composable run asynchronously:</p>\n<ol>\n<li>\n<p>Write the composable as an async function using <code is:raw>export default async</code> to make the composable itself know to wait for the fetch request to finish.</p>\n</li>\n<li>\n<p>Encapsulate the fetch request in its own async function called <code is:raw>async function getKey()</code>, which is called inside the composable using the <code is:raw>await</code> keyword.</p>\n</li>\n<li>\n<p>In the component <code is:raw>AudioCaptions</code>, use a <code is:raw>.then()</code> when I call the composable so that I get access to the returned state after the Promise completes.</p>\n</li>\n</ol>\n<p>Here is the composable to start. The <code is:raw>key</code> will update to be the API key when that arrives from the backend, and <code is:raw>DGStatus</code> will update with a message if there is an error.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> key </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> DGStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Deepgram Not Connected&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">async</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { key, DGStatus }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now I\u2019ll write an async function that will perform all the logic of getting the temporary key. I\u2019ll name it <code is:raw>getKey()</code> and I will use a try-catch block to make the fetch request and handle any errors:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getKey</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">res</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/deepgram-token&#39;</span><span style="color: #C9D1D9">, {</span></span>\n<span class="line"><span style="color: #C9D1D9">      headers: { </span><span style="color: #A5D6FF">&#39;Content-type&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;application/json&#39;</span><span style="color: #C9D1D9"> },</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (res) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">response</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> res.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update with temporary api key:</span></span>\n<span class="line"><span style="color: #C9D1D9">      key.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response.key</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> key</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">catch</span><span style="color: #C9D1D9"> (error) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (error) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update to show error message on screen:</span></span>\n<span class="line"><span style="color: #C9D1D9">      DGStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Error. Please try again.&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>To make sure this runs, I need to call the function in the composable. I will add <code is:raw>await getKey()</code> to the async function that will be exported. Using <code is:raw>await</code> is to go along with <code is:raw>async</code> that I used on the composable function itself. These two keywords together tell the composable that it must wait until the <code is:raw>getKey</code> function resolves.</p>\n<p>Here is the composable in its entirety:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> key </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> DGStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Deepgram Not Connected&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getKey</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">res</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/deepgram-token&#39;</span><span style="color: #C9D1D9">, {</span></span>\n<span class="line"><span style="color: #C9D1D9">      headers: { </span><span style="color: #A5D6FF">&#39;Content-type&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;application/json&#39;</span><span style="color: #C9D1D9"> },</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (res) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">response</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> res.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update with temporary api key:</span></span>\n<span class="line"><span style="color: #C9D1D9">      key.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response.key</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> key</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">catch</span><span style="color: #C9D1D9"> (error) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (error) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update to show error message on screen:</span></span>\n<span class="line"><span style="color: #C9D1D9">      DGStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Error. Please try again.&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">async</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// call function:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getKey</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { key, DGStatus }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I can <code is:raw>console.log(key.value)</code> to make sure the key is arriving successfully.</p>\n<p>Then I\u2019ll go back to <code is:raw>AudioCaptions.vue</code> to wire up a reactive reference that will update to show the error status message if the key does not arrive. I\u2019ll create a <code is:raw>ref</code> called <code is:raw>deepgramStatus</code> and replace the hardcoded \u201CStatus Will Go Here\u201D with that variable.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9">{ deepgramStatus }</span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p><strong>I also need to call the composable function in the component.</strong> If I don\u2019t call it, the logic won\u2019t run. Since it is a promise, I will use a <code is:raw>.then()</code> method on it to get the result, which will be the <code is:raw>key</code> and <code is:raw>DGStatus</code> values. I only need the <code is:raw>DGStatus</code>, so I\u2019ll set that to the <code is:raw>deepgramStatus</code> ref.</p>\n<p>Here\u2019s the <code is:raw>AudioCaptions.vue</code> script now:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramKey from &quot;@/composables/useDeepgramKey&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// use .then() to wait for promise resolution</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FFA657">deepgramStatus</span><span style="color: #C9D1D9">.</span><span style="color: #FFA657">value</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> res.DGStatus.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>If I want to see the error message, I can delete a character in the fetch request URL, making it <code is:raw>http://localhost:8080/deepgram-toke</code>, which is incorrect. That will cause the fetch request to fail, and I\u2019ll see the error message.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/error-message.png" alt="Error. Please Try Again."></p>\n<h2 id="composable-that-relies-on-asynchronous-events-in-other-composables">Composable That Relies on Asynchronous Events in Other Composables</h2>\n<p>Now I will begin to tackle the <code is:raw>useDeepgramSocket</code> composable. This composable will take an audio stream from the browser microphone and send it to Deepgram by way of a browser WebSocket. It relies on two other composables to do this:</p>\n<ol>\n<li>\n<p><code is:raw>useDeepgramKey</code> - I need to get the temporary API key from the composable I just made, <code is:raw>useDeepgramKey</code>, to send it in the request to Deepgram; otherwise, Deepgram won\u2019t be able to fulfill the request.</p>\n</li>\n<li>\n<p><code is:raw>useMicrophone</code> - I need to get an audio stream from the browser microphone. That audio data will be sent to Deepgram to be transcribed into text that will be put onto the screen as captions.</p>\n</li>\n</ol>\n<p>I haven\u2019t created the <code is:raw>useMicrophone</code> composable yet, so I\u2019ll make a quick detour right now to write that composable.</p>\n<h3 id="usemicrophone-composable">useMicrophone Composable</h3>\n<p>The <code is:raw>useMicrophone</code> composable will rely on the browser Media Stream API and the <code is:raw>getUserMedia</code> method to request permission to use the browser microphone of the user and pull the audio from it. Since there are several other blog posts in <a href="https://developers.deepgram.com/">Deepgram Docs</a> about this nifty API, I won\u2019t go into detail about how it works. Check out <a href="https://blog.deepgram.com/getting-started-with-mediastream-api/">Brian\u2019s post</a> for a general introduction to it.</p>\n<p>This composable is also going to use an <code is:raw>async</code> function since the <code is:raw>getUserMedia</code> method requires waiting for the user to give permission to use the microphone. The time involved means that this method returns a promise. I already know how to write this type of composable since I just did it in the last section.</p>\n<p>I\u2019ll make the composable an <code is:raw>async</code> function and I\u2019ll also write the logic to get the audio stream as an <code is:raw>async</code> function. Here is the composable in its entirety:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getAudio</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">mediaStream</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> navigator.mediaDevices.</span><span style="color: #D2A8FF">getUserMedia</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">      audio: </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">mediaRecorder</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">MediaRecorder</span><span style="color: #C9D1D9">(mediaStream, {</span></span>\n<span class="line"><span style="color: #C9D1D9">      audio: </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> mediaRecorder</span></span>\n<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">catch</span><span style="color: #C9D1D9"> (e) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    console.</span><span style="color: #D2A8FF">error</span><span style="color: #C9D1D9">(e)</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">async</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">microphone</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getAudio</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { microphone }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now it\u2019s ready for me to use in the next composable I will write.</p>\n<h3 id="usedeepgramsocket-composable">useDeepgramSocket Composable</h3>\n<p>First, I\u2019ll import this composable into <code is:raw>AudioCaptions.vue</code> and call it. That way, everything I write in <code is:raw>useDeepgramSocket</code> will run and I can check my progress as I build this composable.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramKey from &quot;@/composables/useDeepgramKey&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramSocket from &quot;@/composables/useDeepgramSocket&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FFA657">deepgramStatus</span><span style="color: #C9D1D9">.</span><span style="color: #FFA657">value</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> res.DGStatus.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// call this so the composable runs as I work on it</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>I know I need to have access to the temporary API key from <code is:raw>useDeepgramToken</code> and to the microphone from <code is:raw>useMicrophone</code>. <strong>I will start by setting up my composable to show that I have access to them within the same scope.</strong></p>\n<p>Both composables return a promise. That means I will need to use syntax that will make the functions run but wait for the promise to resolve before moving on to the next thing.</p>\n<h3 id="tip-2---use-then-to-chain-each-composable-that-returns-a-promise-to-run-asynchronously-if-returned-values-need-to-be-in-the-same-scope">Tip #2 - Use <code is:raw>.then()</code> to chain each composable that returns a promise to run asynchronously if returned values need to be in the same scope</h3>\n<p>Here\u2019s what I mean:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useDeepgramKey </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;./useDeepgramKey&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useMicrophone </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;./useMicrophone&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// chain .then() methods for each composable:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">keyRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">microphoneRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> apiKey </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> keyRes.key.value</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> microphone </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> microphoneRes.microphone</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(apiKey)</span></span>\n<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(microphone)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// WEBSOCKET FUNCTION WILL GO HERE</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {}</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I have named the result argument in each <code is:raw>.then()</code> a name that shows which composable they came from - <code is:raw>keyRes</code> and <code is:raw>microphoneRes</code>, which makes it easy for me to see what each of them represents. The <code is:raw>keyRes</code> is a <code is:raw>ref</code>, so I must drill all the way down to the <code is:raw>.value</code> property. The <code is:raw>microphoneRes</code> is a Vue 3 <code is:raw>readonly</code> property, which is why I don\u2019t have to drill down as far.</p>\n<p>Now that I have the values, I can write a function that encapsulates the logic to open the WebSocket.</p>\n<h3 id="opendeepgramsocket-function">openDeepgramSocket Function</h3>\n<p>I will write a function called <code is:raw>openDeepgramSocket</code> that will do the following:</p>\n<ul>\n<li>Create the socket with <code is:raw>new WebSocket(URL, deepgram protocols)</code>.</li>\n<li>Open the socket with <code is:raw>socket.onopen</code>. When it opens, I\u2019ll add an event listener to the microphone to take in the audio stream and send it through the socket.</li>\n<li>Have <code is:raw>socket.onclose</code> listen for when the channel closes.</li>\n</ul>\n<p>I will also create a reactive reference called <code is:raw>DGStatus_socket</code> to update the status of the transcription along the way. That value will be returned to the <code is:raw>AudioCaptions.vue</code> component as the text captions.</p>\n<p>Here is the function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">apiKey</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">microphone</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">socket</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">WebSocket</span><span style="color: #C9D1D9">(</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?punctuate=true&#39;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    [</span><span style="color: #A5D6FF">&#39;token&#39;</span><span style="color: #C9D1D9">, apiKey]</span></span>\n<span class="line"><span style="color: #C9D1D9">  )</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  socket.</span><span style="color: #D2A8FF">onopen</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (microphone.state </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;recording&#39;</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      DGStatus_socket.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Connected to Deepgram&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Connection opened.&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      microphone.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;dataavailable&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">event</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (event.data.size </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> socket.readyState </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">          socket.</span><span style="color: #D2A8FF">send</span><span style="color: #C9D1D9">(event.data)</span></span>\n<span class="line"><span style="color: #C9D1D9">        }</span></span>\n<span class="line"><span style="color: #C9D1D9">      })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      microphone.</span><span style="color: #D2A8FF">start</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  socket.</span><span style="color: #D2A8FF">onmessage</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">message</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">received</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">JSON</span><span style="color: #C9D1D9">.</span><span style="color: #D2A8FF">parse</span><span style="color: #C9D1D9">(message.data)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">transcript</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> received.channel.alternatives[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">].transcript</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (transcript </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> received.is_final) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      DGStatus_socket.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// shows the transcript in the console:</span></span>\n<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(DGStatus_socket.value)</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  socket.</span><span style="color: #D2A8FF">onclose</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Connection closed.&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I have to make sure to call the function in the composable:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">keyRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">microphoneRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> apiKey </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> keyRes.key.value</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> microphone </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> microphoneRes.microphone</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// Call function:</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(apiKey, microphone)</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {}</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now I see the transcript coming back to me because I have added a console.log to show it:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/transcript_console.png" alt="transcript returned in console with messages"></p>\n<p>I\u2019m ready to put that transcript onto the screen as the captions!</p>\n<h3 id="vue-watch-to-update-transcript-status">Vue watch to Update Transcript Status</h3>\n<p>I will use the reactive reference <code is:raw>DGStatus_socket</code> in the composable <code is:raw>useDeepgramSocket</code> to update the captions in <code is:raw>AudioCaptions.vue</code>. To do that, I need to return it from the composable and then destructure it in the component <code is:raw>AudioCaptions.vue</code>.</p>\n<p>Here is the <code is:raw>useDeepgramSocket</code> composable where I return the <code is:raw>DGStatus_socket</code> value (excluding the large <code is:raw>openDeepgramSocket</code> function):</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;vue&quot;</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useDeepgramKey </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;./useDeepgramKey&quot;</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useMicrophone </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;./useMicrophone&quot;</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #8B949E">// create status ref</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> DGStatus_socket </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">apiKey</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">microphone</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #FF7B72">...</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">keyRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">microphoneRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> apiKey </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> keyRes.key.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> microphone </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> microphoneRes.microphone;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(apiKey, microphone);</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"><span style="color: #C9D1D9">  });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// return status ref to component</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { DGStatus_socket };</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>In <code is:raw>AudioCaptions.vue</code>, I destructure the <code is:raw>DGStatus_socket</code> so I have access to it:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">DGStatus_socket</span><span style="color: #C9D1D9"> } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #C9D1D9">()</span></span></code></pre>\n<p>Is it working? Not yet. I have to update the <code is:raw>deepgramStatus</code> ref that is connected to the template if I want to see those captions on the screen.</p>\n<h3 id="tip-3-use-watch-to-update-a-value-in-the-component-and-trigger-a-side-effect-in-sync-with-that-change">Tip #3: Use watch to update a value in the component and trigger a side effect in-sync with that change</h3>\n<p>According to the Vue documentation, <code is:raw>watch</code> is used in \u201Ccases where we need to perform \u2018side effects\u2019 in reaction to state changes - for example, mutating the DOM or changing another piece of state based on the result of an async operation.\u201D</p>\n<p>This example of putting the captions on the screen fits that description exactly. I want the <code is:raw>deepgramStatus</code> value to update if <code is:raw>DGStatus_socket</code> from the composable <code is:raw>useDeepgramSocket</code> changes, and I want that state change to trigger the effect of the text updating in the DOM.</p>\n<p>I will add a watcher to the <code is:raw>AudioCaptions</code> component:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(DGStatus_socket, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  deepgramStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> DGStatus_socket.value</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>And this is what the component in its entirety looks like now:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9">{ deepgramStatus }</span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref, watch </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramKey from &quot;@/composables/useDeepgramKey&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramSocket from &quot;@/composables/useDeepgramSocket&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FFA657">deepgramStatus</span><span style="color: #C9D1D9">.</span><span style="color: #FFA657">value</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> res.DGStatus.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    const { DGStatus_socket } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(DGStatus_socket, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      deepgramStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> DGStatus_socket.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span></code></pre>\n<p>And with that, I have my captions powered by Deepgram! Check out the code for this post on my repo branch <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/deepgram-composables">deepgram-composables</a>.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/captions.gif" alt="Captions working"></p>\n<h2 id="conclusion">Conclusion</h2>\n<p>Today I built the final component of my project, a full-stack video streaming application with text captions.</p>\n<p>This post contained the barebones logic for the captions feature, but in my actual project, I have added styling to improve the user experience, and I\u2019ve added buttons to turn the captions on or off. Check out the repo <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram">here</a>.</p>\n<p>Here is the final project:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/VideoExample.gif" alt="Final project demo"></p>\n<p>It\u2019s been a great experience learning about Amazon IVS and Deepgram, and I\u2019ve gotten the chance to get a better taste of how to take advantage Vue 3\u2019s composition API.</p>\n<p>If you enjoyed this series, please follow me on <a href="https://twitter.com/sandra_rodgers_">Twitter</a> to receive updates on future series I have in the works!</p>' };
const frontmatter = { "title": "Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component", "description": "In this segment, learn how to use Vue 3 composables to power a text-captions component that integrates with Deepgram's speech-to-text API. Read more here!", "date": "2022-04-01T00:00:00.000Z", "cover": "https://res.cloudinary.com/deepgram/image/upload/v1648829347/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/Building-Livestreaming-w-AmazonIVS.jpg", "authors": ["sandra-rodgers"], "category": "tutorial", "tags": ["aws", "javascript", "serverless"], "seo": { "title": "Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component", "description": "In this segment, learn how to use Vue 3 composables to power a text-captions component that integrates with Deepgram's speech-to-text API. Read more here!" }, "shorturls": { "share": "https://dpgr.am/5f3d18c", "twitter": "https://dpgr.am/6dfa73e", "linkedin": "https://dpgr.am/27c8482", "reddit": "https://dpgr.am/ec771f4", "facebook": "https://dpgr.am/cb3aca0" }, "og": { "image": "https://res.cloudinary.com/deepgram/image/upload/v1661454007/blog/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/ograph.png" }, "astro": { "headings": [{ "depth": 2, "slug": "introduction---async-and-the-composition-api", "text": "Introduction - Async and the Composition API" }, { "depth": 2, "slug": "composables-and-asynchronous-logic", "text": "Composables and Asynchronous Logic" }, { "depth": 2, "slug": "composable-using-async-and-await", "text": "Composable Using Async and Await" }, { "depth": 3, "slug": "usedeepgramkey-composable", "text": "useDeepgramKey Composable" }, { "depth": 3, "slug": "tip-1---use-async-and-await-to-write-a-composable-that-returns-a-promise", "text": "Tip #1 - Use async and await to write a composable that returns a promise." }, { "depth": 2, "slug": "composable-that-relies-on-asynchronous-events-in-other-composables", "text": "Composable That Relies on Asynchronous Events in Other Composables" }, { "depth": 3, "slug": "usemicrophone-composable", "text": "useMicrophone Composable" }, { "depth": 3, "slug": "usedeepgramsocket-composable", "text": "useDeepgramSocket Composable" }, { "depth": 3, "slug": "tip-2---use-then-to-chain-each-composable-that-returns-a-promise-to-run-asynchronously-if-returned-values-need-to-be-in-the-same-scope", "text": "Tip #2 - Use .then() to chain each composable that returns a promise to run asynchronously if returned values need to be in the same scope" }, { "depth": 3, "slug": "opendeepgramsocket-function", "text": "openDeepgramSocket Function" }, { "depth": 3, "slug": "vue-watch-to-update-transcript-status", "text": "Vue watch to Update Transcript Status" }, { "depth": 3, "slug": "tip-3-use-watch-to-update-a-value-in-the-component-and-trigger-a-side-effect-in-sync-with-that-change", "text": "Tip #3: Use watch to update a value in the component and trigger a side effect in-sync with that change" }, { "depth": 2, "slug": "conclusion", "text": "Conclusion" }], "source": "\nThis is the final post of my series, \"How to Build a Live Streaming Web Application with Amazon IVS and Deepgram.\"\n\n<Panel type=\"info\" title=\"Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)\">\n<ol> \n<li><a href=\"https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/\">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>\n<li><a href=\"https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/\"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>\n<li><a href=\"https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/\"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li>\n\n<li><a href=\"https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/\"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li>\n</ol>\n</Panel>\n\nFor today's post, I recommend getting a Deepgram API key to use in this project, which anyone can get by heading to the [Deepgram console](https://console.deepgram.com/signup?jump=keys).\n\n## Introduction - Async and the Composition API\n\nToday's post will cover how to use Vue 3 composables to power a text-captions component that integrates with Deepgram's speech-to-text API. Some of the things I'll cover today are:\n\n*   Using `async` and `await` to write a composable that fetches a temporary API key from Deepgram.\n*   Using Vue 3's `watch` method to react to data that is updating in real-time as Deepgram sends a text transcription back through a browser WebSocket.\n*   Writing logic that is sensitive to the order things occur - i.e., asynchronous logic that flows between the component and the composable.\n\nThis post assumes some knowledge of Vue 3, in particular Vue composables. For a refresher on Vue 3, check out my series [Diving Into Vue 3](https://blog.deepgram.com/diving-into-vue-3-getting-started/).\n\nToday I will build the `AudioCaptions.vue` component. (For the `VideoPlayer` component, see my [previous post](https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/#composable-to-bring-in-an-external-script) in the series.) Here is the page with minimal styling. I've put a red box around the `AudioCaptions.vue` component:\n\n![StreamChannel page emphasizing AudioCaptions.vue component](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/StreamChannel_captions.png)\n\nWhere it says \"Deepgram Not Connected,\" there will be text captions that display in real-time along with the video stream.\n\nHere is a diagram of what I will build today:\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/AudioTranscription_Final.png\" alt=\"Audio Transcription Feature Diagram\" style=\"width: 75%; margin:auto;\">\n\nThis feature will rely on Vue 3's Composition API, especially Vue Composables, to put Deepgram captions on the screen.\n\n## Composables and Asynchronous Logic\n\nComposables are a feature of the Vue 3 Composition API; **custom composables** are the ones I build myself with the intention of encapsulating reusable, stateful logic.\n\nI feel like it is somewhat of an art learning how to write composables. The key to writing them well is making them as generic as possible so that they can be reused in many contexts.\n\nFor example, I could write a function that does everything I need it to do to create text captions on the screen using the Deepgram API - the function would include logic to get an API key, turn on the browser microphone, get the audio stream from the microphone, and then send the stream through a WebSocket. I could call the composable `useDeepgram`.\n\nHowever, there are several logical concerns in that one large `useDeepgram` function that could be broken out into other composable functions. While it's easier just to write it all in one file, it means I could only use it in situations that are exactly like this project.\n\nThe challenge of breaking it apart is that the logic to get the transcription from Deepgram depends on certain things happening first, such as the API key arriving and the microphone being turned on. When I break that logic apart into separate functions, I have to be conscious of the order that those functions run, the state that gets updated in multiple functions (and making sure the functions stay in sync), and the conventions for writing asynchronous logic. Not to mention the challenge of updating the component in real-time with the data that comes through the WebSocket.\n\nThe point is that writing composables in the real world can be challenging, so learning some strategies for dealing with more complicated situations, particularly asynchronous logic, is worth it. Because the beauty of composables is that if you write them well, you have a clean, reusable function that you'll return to again and again.\n\n## Composable Using Async and Await\n\nHere is the `AudioCaptions.vue` component right now, before I add the feature logic:\n\n```js\n<template>\n  <div>\n    <p>Status Will Go Here</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  setup() {\n    return {};\n  },\n};\n<\/script>\n```\n\nIn the template where it says \"Status Will Go Here,\" I plan to add a reactive variable. That value will update to show the audio captions after everything is working. For now, I've just hard-coded that text.\n\n### useDeepgramKey Composable\n\nThe first composable I'm going to write will be called `useDeepgramKey.js`, and its purpose will be to fetch a temporary API key. If I fetch a temporary API key from Deepgram, I can use the key in the browser and not worry about exposing the key since the key will expire almost immediately. Read more about this feature in a blog post that Kevin wrote about [protecting your Deepgram API key](https://blog.deepgram.com/protecting-api-key/).\n\nOn the backend, I have set up an endpoint to receive the fetch request from the composable. That endpoint can be seen in the `server.js` file in my repo [here](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/deepgram-composables/server.js).\n\nNow I'll create the `useDeepgramKey.js` composable.\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/useDeepgramKey.png\" alt=\"Create useDeepgramKey.js file in Composables folder\" style=\"width: 50%; margin:auto;\">\n\n### Tip #1 - Use async and await to write a composable that returns a promise.\n\nI will do three things to make this composable run asynchronously:\n\n1.  Write the composable as an async function using `export default async` to make the composable itself know to wait for the fetch request to finish.\n\n2.  Encapsulate the fetch request in its own async function called `async function getKey()`, which is called inside the composable using the `await` keyword.\n\n3.  In the component `AudioCaptions`, use a `.then()` when I call the composable so that I get access to the returned state after the Promise completes.\n\nHere is the composable to start. The `key` will update to be the API key when that arrives from the backend, and `DGStatus` will update with a message if there is an error.\n\n```js\nimport { ref } from 'vue'\nlet key = ref('')\nlet DGStatus = ref('Deepgram Not Connected')\n\nexport default async function useDeepgramKey() {\n  return { key, DGStatus }\n}\n```\n\nNow I'll write an async function that will perform all the logic of getting the temporary key. I'll name it `getKey()` and I will use a try-catch block to make the fetch request and handle any errors:\n\n```js\nasync function getKey() {\n  try {\n    const res = await fetch('http://localhost:8080/deepgram-token', {\n      headers: { 'Content-type': 'application/json' },\n    })\n    if (res) {\n      const response = await res.json()\n      // update with temporary api key:\n      key.value = response.key\n      return key\n    }\n  } catch (error) {\n    if (error) {\n      // update to show error message on screen:\n      DGStatus.value = 'Error. Please try again.'\n    }\n  }\n}\n```\n\nTo make sure this runs, I need to call the function in the composable. I will add `await getKey()` to the async function that will be exported. Using `await` is to go along with `async` that I used on the composable function itself. These two keywords together tell the composable that it must wait until the `getKey` function resolves.\n\nHere is the composable in its entirety:\n\n```js\nimport { ref } from 'vue'\nlet key = ref('')\nlet DGStatus = ref('Deepgram Not Connected')\n\nasync function getKey() {\n  try {\n    const res = await fetch('http://localhost:8080/deepgram-token', {\n      headers: { 'Content-type': 'application/json' },\n    })\n    if (res) {\n      const response = await res.json()\n      // update with temporary api key:\n      key.value = response.key\n      return key\n    }\n  } catch (error) {\n    if (error) {\n      // update to show error message on screen:\n      DGStatus.value = 'Error. Please try again.'\n    }\n  }\n}\n\nexport default async function useDeepgramKey() {\n  // call function:\n  await getKey()\n  return { key, DGStatus }\n}\n```\n\nI can `console.log(key.value)` to make sure the key is arriving successfully.\n\nThen I'll go back to `AudioCaptions.vue` to wire up a reactive reference that will update to show the error status message if the key does not arrive. I'll create a `ref` called `deepgramStatus` and replace the hardcoded \"Status Will Go Here\" with that variable.\n\n```js\n<template>\n  <div>\n    <p>{{ deepgramStatus }}</p>\n  </div>\n</template>\n\n<script>\nimport { ref } from \"vue\";\nexport default {\n  setup() {\n    let deepgramStatus = ref(\"Deepgram Not Connected\");\n    return { deepgramStatus };\n  },\n};\n<\/script>\n```\n\n**I also need to call the composable function in the component.** If I don't call it, the logic won't run. Since it is a promise, I will use a `.then()` method on it to get the result, which will be the `key` and `DGStatus` values. I only need the `DGStatus`, so I'll set that to the `deepgramStatus` ref.\n\nHere's the `AudioCaptions.vue` script now:\n\n```js\n<script>\nimport { ref } from \"vue\";\nimport useDeepgramKey from \"@/composables/useDeepgramKey\";\nexport default {\n  setup() {\n    let deepgramStatus = ref(\"Deepgram Not Connected\");\n\n    // use .then() to wait for promise resolution\n    useDeepgramKey().then((res) => {\n      deepgramStatus.value = res.DGStatus.value;\n    });\n\n    return { deepgramStatus };\n  },\n};\n<\/script>\n```\n\nIf I want to see the error message, I can delete a character in the fetch request URL, making it `http://localhost:8080/deepgram-toke`, which is incorrect. That will cause the fetch request to fail, and I'll see the error message.\n\n![Error. Please Try Again.](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/error-message.png)\n\n## Composable That Relies on Asynchronous Events in Other Composables\n\nNow I will begin to tackle the `useDeepgramSocket` composable. This composable will take an audio stream from the browser microphone and send it to Deepgram by way of a browser WebSocket. It relies on two other composables to do this:\n\n1.  `useDeepgramKey` - I need to get the temporary API key from the composable I just made, `useDeepgramKey`, to send it in the request to Deepgram; otherwise, Deepgram won't be able to fulfill the request.\n\n2.  `useMicrophone` - I need to get an audio stream from the browser microphone. That audio data will be sent to Deepgram to be transcribed into text that will be put onto the screen as captions.\n\nI haven't created the `useMicrophone` composable yet, so I'll make a quick detour right now to write that composable.\n\n### useMicrophone Composable\n\nThe `useMicrophone` composable will rely on the browser Media Stream API and the `getUserMedia` method to request permission to use the browser microphone of the user and pull the audio from it. Since there are several other blog posts in [Deepgram Docs](https://developers.deepgram.com/) about this nifty API, I won't go into detail about how it works. Check out [Brian's post](https://blog.deepgram.com/getting-started-with-mediastream-api/) for a general introduction to it.\n\nThis composable is also going to use an `async` function since the `getUserMedia` method requires waiting for the user to give permission to use the microphone. The time involved means that this method returns a promise. I already know how to write this type of composable since I just did it in the last section.\n\nI'll make the composable an `async` function and I'll also write the logic to get the audio stream as an `async` function. Here is the composable in its entirety:\n\n```js\nasync function getAudio() {\n  try {\n    const mediaStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n    })\n    const mediaRecorder = new MediaRecorder(mediaStream, {\n      audio: true,\n    })\n    return mediaRecorder\n  } catch (e) {\n    console.error(e)\n  }\n}\n\nexport default async function useMicrophone() {\n  const microphone = await getAudio()\n  return { microphone }\n}\n```\n\nNow it's ready for me to use in the next composable I will write.\n\n### useDeepgramSocket Composable\n\nFirst, I'll import this composable into `AudioCaptions.vue` and call it. That way, everything I write in `useDeepgramSocket` will run and I can check my progress as I build this composable.\n\n```js\n<script>\nimport { ref } from \"vue\";\nimport useDeepgramKey from \"@/composables/useDeepgramKey\";\nimport useDeepgramSocket from \"@/composables/useDeepgramSocket\";\nexport default {\n  setup() {\n    let deepgramStatus = ref(\"Deepgram Not Connected\");\n\n    useDeepgramKey().then((res) => {\n      deepgramStatus.value = res.DGStatus.value;\n    });\n\n    // call this so the composable runs as I work on it\n    useDeepgramSocket();\n\n    return { deepgramStatus };\n  },\n};\n<\/script>\n```\n\nI know I need to have access to the temporary API key from `useDeepgramToken` and to the microphone from `useMicrophone`. **I will start by setting up my composable to show that I have access to them within the same scope.**\n\nBoth composables return a promise. That means I will need to use syntax that will make the functions run but wait for the promise to resolve before moving on to the next thing.\n\n### Tip #2 - Use `.then()` to chain each composable that returns a promise to run asynchronously if returned values need to be in the same scope\n\nHere's what I mean:\n\n```js\nimport useDeepgramKey from './useDeepgramKey'\nimport useMicrophone from './useMicrophone'\n\nexport default function useDeepgramSocket() {\n  // chain .then() methods for each composable:\n  useDeepgramKey().then((keyRes) => {\n    useMicrophone().then((microphoneRes) => {\n      let apiKey = keyRes.key.value\n      let microphone = microphoneRes.microphone\n\n      console.log(apiKey)\n      console.log(microphone)\n\n      // WEBSOCKET FUNCTION WILL GO HERE\n    })\n  })\n  return {}\n}\n```\n\nI have named the result argument in each `.then()` a name that shows which composable they came from - `keyRes` and `microphoneRes`, which makes it easy for me to see what each of them represents. The `keyRes` is a `ref`, so I must drill all the way down to the `.value` property. The `microphoneRes` is a Vue 3 `readonly` property, which is why I don't have to drill down as far.\n\nNow that I have the values, I can write a function that encapsulates the logic to open the WebSocket.\n\n### openDeepgramSocket Function\n\nI will write a function called `openDeepgramSocket` that will do the following:\n\n*   Create the socket with `new WebSocket(URL, deepgram protocols)`.\n*   Open the socket with `socket.onopen`. When it opens, I'll add an event listener to the microphone to take in the audio stream and send it through the socket.\n*   Have `socket.onclose` listen for when the channel closes.\n\nI will also create a reactive reference called `DGStatus_socket` to update the status of the transcription along the way. That value will be returned to the `AudioCaptions.vue` component as the text captions.\n\nHere is the function:\n\n```js\nfunction openDeepgramSocket(apiKey, microphone) {\n  const socket = new WebSocket(\n    'wss://api.deepgram.com/v1/listen?punctuate=true',\n    ['token', apiKey]\n  )\n\n  socket.onopen = () => {\n    if (microphone.state != 'recording') {\n      DGStatus_socket.value = 'Connected to Deepgram'\n      console.log('Connection opened.')\n\n      microphone.addEventListener('dataavailable', async (event) => {\n        if (event.data.size > 0 && socket.readyState == 1) {\n          socket.send(event.data)\n        }\n      })\n\n      microphone.start(200)\n    }\n  }\n\n  socket.onmessage = (message) => {\n    const received = JSON.parse(message.data)\n    const transcript = received.channel.alternatives[0].transcript\n    if (transcript && received.is_final) {\n      DGStatus_socket.value = transcript + ''\n      // shows the transcript in the console:\n      console.log(DGStatus_socket.value)\n    }\n  }\n\n  socket.onclose = () => {\n    console.log('Connection closed.')\n  }\n}\n```\n\nI have to make sure to call the function in the composable:\n\n```js\nexport default function useDeepgramSocket() {\n  useDeepgramKey().then((keyRes) => {\n    useMicrophone().then((microphoneRes) => {\n      let apiKey = keyRes.key.value\n      let microphone = microphoneRes.microphone\n\n      // Call function:\n      openDeepgramSocket(apiKey, microphone)\n    })\n  })\n  return {}\n}\n```\n\nNow I see the transcript coming back to me because I have added a console.log to show it:\n\n![transcript returned in console with messages](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/transcript_console.png)\n\nI'm ready to put that transcript onto the screen as the captions!\n\n### Vue watch to Update Transcript Status\n\nI will use the reactive reference `DGStatus_socket` in the composable `useDeepgramSocket` to update the captions in `AudioCaptions.vue`. To do that, I need to return it from the composable and then destructure it in the component `AudioCaptions.vue`.\n\nHere is the `useDeepgramSocket` composable where I return the `DGStatus_socket` value (excluding the large `openDeepgramSocket` function):\n\n```js\nimport { ref } from \"vue\";\nimport useDeepgramKey from \"./useDeepgramKey\";\nimport useMicrophone from \"./useMicrophone\";\n\n// create status ref\nlet DGStatus_socket = ref(\"\");\n\nfunction openDeepgramSocket(apiKey, microphone) {\n...\n}\n\nexport default function useDeepgramSocket() {\n  useDeepgramKey().then((keyRes) => {\n    useMicrophone().then((microphoneRes) => {\n      let apiKey = keyRes.key.value;\n      let microphone = microphoneRes.microphone;\n\n      openDeepgramSocket(apiKey, microphone);\n    });\n  });\n\n  // return status ref to component\n  return { DGStatus_socket };\n}\n```\n\nIn `AudioCaptions.vue`, I destructure the `DGStatus_socket` so I have access to it:\n\n```js\nconst { DGStatus_socket } = useDeepgramSocket()\n```\n\nIs it working? Not yet. I have to update the `deepgramStatus` ref that is connected to the template if I want to see those captions on the screen.\n\n### Tip #3: Use watch to update a value in the component and trigger a side effect in-sync with that change\n\nAccording to the Vue documentation, `watch` is used in \"cases where we need to perform 'side effects' in reaction to state changes - for example, mutating the DOM or changing another piece of state based on the result of an async operation.\"\n\nThis example of putting the captions on the screen fits that description exactly. I want the `deepgramStatus` value to update if `DGStatus_socket` from the composable `useDeepgramSocket` changes, and I want that state change to trigger the effect of the text updating in the DOM.\n\nI will add a watcher to the `AudioCaptions` component:\n\n```js\nwatch(DGStatus_socket, () => {\n  deepgramStatus.value = DGStatus_socket.value\n})\n```\n\nAnd this is what the component in its entirety looks like now:\n\n```js\n<template>\n  <div>\n    <p>{{ deepgramStatus }}</p>\n  </div>\n</template>\n\n<script>\nimport { ref, watch } from \"vue\";\nimport useDeepgramKey from \"@/composables/useDeepgramKey\";\nimport useDeepgramSocket from \"@/composables/useDeepgramSocket\";\nexport default {\n  setup() {\n    let deepgramStatus = ref(\"Deepgram Not Connected\");\n\n    useDeepgramKey().then((res) => {\n      deepgramStatus.value = res.DGStatus.value;\n    });\n\n    const { DGStatus_socket } = useDeepgramSocket();\n\n    watch(DGStatus_socket, () => {\n      deepgramStatus.value = DGStatus_socket.value;\n    });\n\n    return { deepgramStatus };\n  },\n};\n<\/script>\n\n```\n\nAnd with that, I have my captions powered by Deepgram! Check out the code for this post on my repo branch [deepgram-composables](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/deepgram-composables).\n\n![Captions working](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/captions.gif)\n\n## Conclusion\n\nToday I built the final component of my project, a full-stack video streaming application with text captions.\n\nThis post contained the barebones logic for the captions feature, but in my actual project, I have added styling to improve the user experience, and I've added buttons to turn the captions on or off. Check out the repo [here](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram).\n\nHere is the final project:\n\n![Final project demo](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/VideoExample.gif)\n\nIt's been a great experience learning about Amazon IVS and Deepgram, and I've gotten the chance to get a better taste of how to take advantage Vue 3's composition API.\n\nIf you enjoyed this series, please follow me on [Twitter](https://twitter.com/sandra_rodgers_) to receive updates on future series I have in the works!\n\n        ", "html": '<p>This is the final post of my series, \u201CHow to Build a Live Streaming Web Application with Amazon IVS and Deepgram.\u201D</p>\n<Panel type="info" title="Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)"><ol><li><a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>\n<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>\n<li><a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li><li><a href="https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li></ol></Panel>\n<p>For today\u2019s post, I recommend getting a Deepgram API key to use in this project, which anyone can get by heading to the <a href="https://console.deepgram.com/signup?jump=keys">Deepgram console</a>.</p>\n<h2 id="introduction---async-and-the-composition-api">Introduction - Async and the Composition API</h2>\n<p>Today\u2019s post will cover how to use Vue 3 composables to power a text-captions component that integrates with Deepgram\u2019s speech-to-text API. Some of the things I\u2019ll cover today are:</p>\n<ul>\n<li>Using <code is:raw>async</code> and <code is:raw>await</code> to write a composable that fetches a temporary API key from Deepgram.</li>\n<li>Using Vue 3\u2019s <code is:raw>watch</code> method to react to data that is updating in real-time as Deepgram sends a text transcription back through a browser WebSocket.</li>\n<li>Writing logic that is sensitive to the order things occur - i.e., asynchronous logic that flows between the component and the composable.</li>\n</ul>\n<p>This post assumes some knowledge of Vue 3, in particular Vue composables. For a refresher on Vue 3, check out my series <a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3</a>.</p>\n<p>Today I will build the <code is:raw>AudioCaptions.vue</code> component. (For the <code is:raw>VideoPlayer</code> component, see my <a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/#composable-to-bring-in-an-external-script">previous post</a> in the series.) Here is the page with minimal styling. I\u2019ve put a red box around the <code is:raw>AudioCaptions.vue</code> component:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/StreamChannel_captions.png" alt="StreamChannel page emphasizing AudioCaptions.vue component"></p>\n<p>Where it says \u201CDeepgram Not Connected,\u201D there will be text captions that display in real-time along with the video stream.</p>\n<p>Here is a diagram of what I will build today:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/AudioTranscription_Final.png" alt="Audio Transcription Feature Diagram" style="width: 75%; margin:auto;" />\n<p>This feature will rely on Vue 3\u2019s Composition API, especially Vue Composables, to put Deepgram captions on the screen.</p>\n<h2 id="composables-and-asynchronous-logic">Composables and Asynchronous Logic</h2>\n<p>Composables are a feature of the Vue 3 Composition API; <strong>custom composables</strong> are the ones I build myself with the intention of encapsulating reusable, stateful logic.</p>\n<p>I feel like it is somewhat of an art learning how to write composables. The key to writing them well is making them as generic as possible so that they can be reused in many contexts.</p>\n<p>For example, I could write a function that does everything I need it to do to create text captions on the screen using the Deepgram API - the function would include logic to get an API key, turn on the browser microphone, get the audio stream from the microphone, and then send the stream through a WebSocket. I could call the composable <code is:raw>useDeepgram</code>.</p>\n<p>However, there are several logical concerns in that one large <code is:raw>useDeepgram</code> function that could be broken out into other composable functions. While it\u2019s easier just to write it all in one file, it means I could only use it in situations that are exactly like this project.</p>\n<p>The challenge of breaking it apart is that the logic to get the transcription from Deepgram depends on certain things happening first, such as the API key arriving and the microphone being turned on. When I break that logic apart into separate functions, I have to be conscious of the order that those functions run, the state that gets updated in multiple functions (and making sure the functions stay in sync), and the conventions for writing asynchronous logic. Not to mention the challenge of updating the component in real-time with the data that comes through the WebSocket.</p>\n<p>The point is that writing composables in the real world can be challenging, so learning some strategies for dealing with more complicated situations, particularly asynchronous logic, is worth it. Because the beauty of composables is that if you write them well, you have a clean, reusable function that you\u2019ll return to again and again.</p>\n<h2 id="composable-using-async-and-await">Composable Using Async and Await</h2>\n<p>Here is the <code is:raw>AudioCaptions.vue</code> component right now, before I add the feature logic:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;Status Will Go Here&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    return {};</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>In the template where it says \u201CStatus Will Go Here,\u201D I plan to add a reactive variable. That value will update to show the audio captions after everything is working. For now, I\u2019ve just hard-coded that text.</p>\n<h3 id="usedeepgramkey-composable">useDeepgramKey Composable</h3>\n<p>The first composable I\u2019m going to write will be called <code is:raw>useDeepgramKey.js</code>, and its purpose will be to fetch a temporary API key. If I fetch a temporary API key from Deepgram, I can use the key in the browser and not worry about exposing the key since the key will expire almost immediately. Read more about this feature in a blog post that Kevin wrote about <a href="https://blog.deepgram.com/protecting-api-key/">protecting your Deepgram API key</a>.</p>\n<p>On the backend, I have set up an endpoint to receive the fetch request from the composable. That endpoint can be seen in the <code is:raw>server.js</code> file in my repo <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/deepgram-composables/server.js">here</a>.</p>\n<p>Now I\u2019ll create the <code is:raw>useDeepgramKey.js</code> composable.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/useDeepgramKey.png" alt="Create useDeepgramKey.js file in Composables folder" style="width: 50%; margin:auto;" />\n<h3 id="tip-1---use-async-and-await-to-write-a-composable-that-returns-a-promise">Tip #1 - Use async and await to write a composable that returns a promise.</h3>\n<p>I will do three things to make this composable run asynchronously:</p>\n<ol>\n<li>\n<p>Write the composable as an async function using <code is:raw>export default async</code> to make the composable itself know to wait for the fetch request to finish.</p>\n</li>\n<li>\n<p>Encapsulate the fetch request in its own async function called <code is:raw>async function getKey()</code>, which is called inside the composable using the <code is:raw>await</code> keyword.</p>\n</li>\n<li>\n<p>In the component <code is:raw>AudioCaptions</code>, use a <code is:raw>.then()</code> when I call the composable so that I get access to the returned state after the Promise completes.</p>\n</li>\n</ol>\n<p>Here is the composable to start. The <code is:raw>key</code> will update to be the API key when that arrives from the backend, and <code is:raw>DGStatus</code> will update with a message if there is an error.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> key </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> DGStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Deepgram Not Connected&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">async</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { key, DGStatus }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now I\u2019ll write an async function that will perform all the logic of getting the temporary key. I\u2019ll name it <code is:raw>getKey()</code> and I will use a try-catch block to make the fetch request and handle any errors:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getKey</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">res</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/deepgram-token&#39;</span><span style="color: #C9D1D9">, {</span></span>\n<span class="line"><span style="color: #C9D1D9">      headers: { </span><span style="color: #A5D6FF">&#39;Content-type&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;application/json&#39;</span><span style="color: #C9D1D9"> },</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (res) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">response</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> res.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update with temporary api key:</span></span>\n<span class="line"><span style="color: #C9D1D9">      key.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response.key</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> key</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">catch</span><span style="color: #C9D1D9"> (error) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (error) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update to show error message on screen:</span></span>\n<span class="line"><span style="color: #C9D1D9">      DGStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Error. Please try again.&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>To make sure this runs, I need to call the function in the composable. I will add <code is:raw>await getKey()</code> to the async function that will be exported. Using <code is:raw>await</code> is to go along with <code is:raw>async</code> that I used on the composable function itself. These two keywords together tell the composable that it must wait until the <code is:raw>getKey</code> function resolves.</p>\n<p>Here is the composable in its entirety:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> key </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> DGStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Deepgram Not Connected&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getKey</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">res</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/deepgram-token&#39;</span><span style="color: #C9D1D9">, {</span></span>\n<span class="line"><span style="color: #C9D1D9">      headers: { </span><span style="color: #A5D6FF">&#39;Content-type&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;application/json&#39;</span><span style="color: #C9D1D9"> },</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (res) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">response</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> res.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update with temporary api key:</span></span>\n<span class="line"><span style="color: #C9D1D9">      key.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response.key</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> key</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">catch</span><span style="color: #C9D1D9"> (error) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (error) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update to show error message on screen:</span></span>\n<span class="line"><span style="color: #C9D1D9">      DGStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Error. Please try again.&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">async</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// call function:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getKey</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { key, DGStatus }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I can <code is:raw>console.log(key.value)</code> to make sure the key is arriving successfully.</p>\n<p>Then I\u2019ll go back to <code is:raw>AudioCaptions.vue</code> to wire up a reactive reference that will update to show the error status message if the key does not arrive. I\u2019ll create a <code is:raw>ref</code> called <code is:raw>deepgramStatus</code> and replace the hardcoded \u201CStatus Will Go Here\u201D with that variable.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9">{ deepgramStatus }</span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p><strong>I also need to call the composable function in the component.</strong> If I don\u2019t call it, the logic won\u2019t run. Since it is a promise, I will use a <code is:raw>.then()</code> method on it to get the result, which will be the <code is:raw>key</code> and <code is:raw>DGStatus</code> values. I only need the <code is:raw>DGStatus</code>, so I\u2019ll set that to the <code is:raw>deepgramStatus</code> ref.</p>\n<p>Here\u2019s the <code is:raw>AudioCaptions.vue</code> script now:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramKey from &quot;@/composables/useDeepgramKey&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// use .then() to wait for promise resolution</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FFA657">deepgramStatus</span><span style="color: #C9D1D9">.</span><span style="color: #FFA657">value</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> res.DGStatus.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>If I want to see the error message, I can delete a character in the fetch request URL, making it <code is:raw>http://localhost:8080/deepgram-toke</code>, which is incorrect. That will cause the fetch request to fail, and I\u2019ll see the error message.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/error-message.png" alt="Error. Please Try Again."></p>\n<h2 id="composable-that-relies-on-asynchronous-events-in-other-composables">Composable That Relies on Asynchronous Events in Other Composables</h2>\n<p>Now I will begin to tackle the <code is:raw>useDeepgramSocket</code> composable. This composable will take an audio stream from the browser microphone and send it to Deepgram by way of a browser WebSocket. It relies on two other composables to do this:</p>\n<ol>\n<li>\n<p><code is:raw>useDeepgramKey</code> - I need to get the temporary API key from the composable I just made, <code is:raw>useDeepgramKey</code>, to send it in the request to Deepgram; otherwise, Deepgram won\u2019t be able to fulfill the request.</p>\n</li>\n<li>\n<p><code is:raw>useMicrophone</code> - I need to get an audio stream from the browser microphone. That audio data will be sent to Deepgram to be transcribed into text that will be put onto the screen as captions.</p>\n</li>\n</ol>\n<p>I haven\u2019t created the <code is:raw>useMicrophone</code> composable yet, so I\u2019ll make a quick detour right now to write that composable.</p>\n<h3 id="usemicrophone-composable">useMicrophone Composable</h3>\n<p>The <code is:raw>useMicrophone</code> composable will rely on the browser Media Stream API and the <code is:raw>getUserMedia</code> method to request permission to use the browser microphone of the user and pull the audio from it. Since there are several other blog posts in <a href="https://developers.deepgram.com/">Deepgram Docs</a> about this nifty API, I won\u2019t go into detail about how it works. Check out <a href="https://blog.deepgram.com/getting-started-with-mediastream-api/">Brian\u2019s post</a> for a general introduction to it.</p>\n<p>This composable is also going to use an <code is:raw>async</code> function since the <code is:raw>getUserMedia</code> method requires waiting for the user to give permission to use the microphone. The time involved means that this method returns a promise. I already know how to write this type of composable since I just did it in the last section.</p>\n<p>I\u2019ll make the composable an <code is:raw>async</code> function and I\u2019ll also write the logic to get the audio stream as an <code is:raw>async</code> function. Here is the composable in its entirety:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getAudio</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">mediaStream</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> navigator.mediaDevices.</span><span style="color: #D2A8FF">getUserMedia</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">      audio: </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">mediaRecorder</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">MediaRecorder</span><span style="color: #C9D1D9">(mediaStream, {</span></span>\n<span class="line"><span style="color: #C9D1D9">      audio: </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> mediaRecorder</span></span>\n<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">catch</span><span style="color: #C9D1D9"> (e) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    console.</span><span style="color: #D2A8FF">error</span><span style="color: #C9D1D9">(e)</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">async</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">microphone</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getAudio</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { microphone }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now it\u2019s ready for me to use in the next composable I will write.</p>\n<h3 id="usedeepgramsocket-composable">useDeepgramSocket Composable</h3>\n<p>First, I\u2019ll import this composable into <code is:raw>AudioCaptions.vue</code> and call it. That way, everything I write in <code is:raw>useDeepgramSocket</code> will run and I can check my progress as I build this composable.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramKey from &quot;@/composables/useDeepgramKey&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramSocket from &quot;@/composables/useDeepgramSocket&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FFA657">deepgramStatus</span><span style="color: #C9D1D9">.</span><span style="color: #FFA657">value</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> res.DGStatus.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// call this so the composable runs as I work on it</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>I know I need to have access to the temporary API key from <code is:raw>useDeepgramToken</code> and to the microphone from <code is:raw>useMicrophone</code>. <strong>I will start by setting up my composable to show that I have access to them within the same scope.</strong></p>\n<p>Both composables return a promise. That means I will need to use syntax that will make the functions run but wait for the promise to resolve before moving on to the next thing.</p>\n<h3 id="tip-2---use-then-to-chain-each-composable-that-returns-a-promise-to-run-asynchronously-if-returned-values-need-to-be-in-the-same-scope">Tip #2 - Use <code is:raw>.then()</code> to chain each composable that returns a promise to run asynchronously if returned values need to be in the same scope</h3>\n<p>Here\u2019s what I mean:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useDeepgramKey </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;./useDeepgramKey&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useMicrophone </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;./useMicrophone&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// chain .then() methods for each composable:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">keyRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">microphoneRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> apiKey </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> keyRes.key.value</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> microphone </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> microphoneRes.microphone</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(apiKey)</span></span>\n<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(microphone)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// WEBSOCKET FUNCTION WILL GO HERE</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {}</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I have named the result argument in each <code is:raw>.then()</code> a name that shows which composable they came from - <code is:raw>keyRes</code> and <code is:raw>microphoneRes</code>, which makes it easy for me to see what each of them represents. The <code is:raw>keyRes</code> is a <code is:raw>ref</code>, so I must drill all the way down to the <code is:raw>.value</code> property. The <code is:raw>microphoneRes</code> is a Vue 3 <code is:raw>readonly</code> property, which is why I don\u2019t have to drill down as far.</p>\n<p>Now that I have the values, I can write a function that encapsulates the logic to open the WebSocket.</p>\n<h3 id="opendeepgramsocket-function">openDeepgramSocket Function</h3>\n<p>I will write a function called <code is:raw>openDeepgramSocket</code> that will do the following:</p>\n<ul>\n<li>Create the socket with <code is:raw>new WebSocket(URL, deepgram protocols)</code>.</li>\n<li>Open the socket with <code is:raw>socket.onopen</code>. When it opens, I\u2019ll add an event listener to the microphone to take in the audio stream and send it through the socket.</li>\n<li>Have <code is:raw>socket.onclose</code> listen for when the channel closes.</li>\n</ul>\n<p>I will also create a reactive reference called <code is:raw>DGStatus_socket</code> to update the status of the transcription along the way. That value will be returned to the <code is:raw>AudioCaptions.vue</code> component as the text captions.</p>\n<p>Here is the function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">apiKey</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">microphone</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">socket</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">WebSocket</span><span style="color: #C9D1D9">(</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?punctuate=true&#39;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    [</span><span style="color: #A5D6FF">&#39;token&#39;</span><span style="color: #C9D1D9">, apiKey]</span></span>\n<span class="line"><span style="color: #C9D1D9">  )</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  socket.</span><span style="color: #D2A8FF">onopen</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (microphone.state </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;recording&#39;</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      DGStatus_socket.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Connected to Deepgram&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Connection opened.&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      microphone.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;dataavailable&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">event</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (event.data.size </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> socket.readyState </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">          socket.</span><span style="color: #D2A8FF">send</span><span style="color: #C9D1D9">(event.data)</span></span>\n<span class="line"><span style="color: #C9D1D9">        }</span></span>\n<span class="line"><span style="color: #C9D1D9">      })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      microphone.</span><span style="color: #D2A8FF">start</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  socket.</span><span style="color: #D2A8FF">onmessage</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">message</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">received</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">JSON</span><span style="color: #C9D1D9">.</span><span style="color: #D2A8FF">parse</span><span style="color: #C9D1D9">(message.data)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">transcript</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> received.channel.alternatives[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">].transcript</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (transcript </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> received.is_final) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      DGStatus_socket.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// shows the transcript in the console:</span></span>\n<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(DGStatus_socket.value)</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  socket.</span><span style="color: #D2A8FF">onclose</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Connection closed.&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I have to make sure to call the function in the composable:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">keyRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">microphoneRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> apiKey </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> keyRes.key.value</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> microphone </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> microphoneRes.microphone</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// Call function:</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(apiKey, microphone)</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {}</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now I see the transcript coming back to me because I have added a console.log to show it:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/transcript_console.png" alt="transcript returned in console with messages"></p>\n<p>I\u2019m ready to put that transcript onto the screen as the captions!</p>\n<h3 id="vue-watch-to-update-transcript-status">Vue watch to Update Transcript Status</h3>\n<p>I will use the reactive reference <code is:raw>DGStatus_socket</code> in the composable <code is:raw>useDeepgramSocket</code> to update the captions in <code is:raw>AudioCaptions.vue</code>. To do that, I need to return it from the composable and then destructure it in the component <code is:raw>AudioCaptions.vue</code>.</p>\n<p>Here is the <code is:raw>useDeepgramSocket</code> composable where I return the <code is:raw>DGStatus_socket</code> value (excluding the large <code is:raw>openDeepgramSocket</code> function):</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;vue&quot;</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useDeepgramKey </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;./useDeepgramKey&quot;</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useMicrophone </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;./useMicrophone&quot;</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #8B949E">// create status ref</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> DGStatus_socket </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">apiKey</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">microphone</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #FF7B72">...</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">keyRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">microphoneRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> apiKey </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> keyRes.key.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> microphone </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> microphoneRes.microphone;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(apiKey, microphone);</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"><span style="color: #C9D1D9">  });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// return status ref to component</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { DGStatus_socket };</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>In <code is:raw>AudioCaptions.vue</code>, I destructure the <code is:raw>DGStatus_socket</code> so I have access to it:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">DGStatus_socket</span><span style="color: #C9D1D9"> } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #C9D1D9">()</span></span></code></pre>\n<p>Is it working? Not yet. I have to update the <code is:raw>deepgramStatus</code> ref that is connected to the template if I want to see those captions on the screen.</p>\n<h3 id="tip-3-use-watch-to-update-a-value-in-the-component-and-trigger-a-side-effect-in-sync-with-that-change">Tip #3: Use watch to update a value in the component and trigger a side effect in-sync with that change</h3>\n<p>According to the Vue documentation, <code is:raw>watch</code> is used in \u201Ccases where we need to perform \u2018side effects\u2019 in reaction to state changes - for example, mutating the DOM or changing another piece of state based on the result of an async operation.\u201D</p>\n<p>This example of putting the captions on the screen fits that description exactly. I want the <code is:raw>deepgramStatus</code> value to update if <code is:raw>DGStatus_socket</code> from the composable <code is:raw>useDeepgramSocket</code> changes, and I want that state change to trigger the effect of the text updating in the DOM.</p>\n<p>I will add a watcher to the <code is:raw>AudioCaptions</code> component:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(DGStatus_socket, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  deepgramStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> DGStatus_socket.value</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>And this is what the component in its entirety looks like now:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9">{ deepgramStatus }</span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref, watch </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramKey from &quot;@/composables/useDeepgramKey&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramSocket from &quot;@/composables/useDeepgramSocket&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FFA657">deepgramStatus</span><span style="color: #C9D1D9">.</span><span style="color: #FFA657">value</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> res.DGStatus.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    const { DGStatus_socket } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(DGStatus_socket, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      deepgramStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> DGStatus_socket.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span></code></pre>\n<p>And with that, I have my captions powered by Deepgram! Check out the code for this post on my repo branch <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/deepgram-composables">deepgram-composables</a>.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/captions.gif" alt="Captions working"></p>\n<h2 id="conclusion">Conclusion</h2>\n<p>Today I built the final component of my project, a full-stack video streaming application with text captions.</p>\n<p>This post contained the barebones logic for the captions feature, but in my actual project, I have added styling to improve the user experience, and I\u2019ve added buttons to turn the captions on or off. Check out the repo <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram">here</a>.</p>\n<p>Here is the final project:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/VideoExample.gif" alt="Final project demo"></p>\n<p>It\u2019s been a great experience learning about Amazon IVS and Deepgram, and I\u2019ve gotten the chance to get a better taste of how to take advantage Vue 3\u2019s composition API.</p>\n<p>If you enjoyed this series, please follow me on <a href="https://twitter.com/sandra_rodgers_">Twitter</a> to receive updates on future series I have in the works!</p>' }, "file": "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/index.md" };
function rawContent() {
  return "\nThis is the final post of my series, \"How to Build a Live Streaming Web Application with Amazon IVS and Deepgram.\"\n\n<Panel type=\"info\" title=\"Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)\">\n<ol> \n<li><a href=\"https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/\">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>\n<li><a href=\"https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/\"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>\n<li><a href=\"https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/\"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li>\n\n<li><a href=\"https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/\"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li>\n</ol>\n</Panel>\n\nFor today's post, I recommend getting a Deepgram API key to use in this project, which anyone can get by heading to the [Deepgram console](https://console.deepgram.com/signup?jump=keys).\n\n## Introduction - Async and the Composition API\n\nToday's post will cover how to use Vue 3 composables to power a text-captions component that integrates with Deepgram's speech-to-text API. Some of the things I'll cover today are:\n\n*   Using `async` and `await` to write a composable that fetches a temporary API key from Deepgram.\n*   Using Vue 3's `watch` method to react to data that is updating in real-time as Deepgram sends a text transcription back through a browser WebSocket.\n*   Writing logic that is sensitive to the order things occur - i.e., asynchronous logic that flows between the component and the composable.\n\nThis post assumes some knowledge of Vue 3, in particular Vue composables. For a refresher on Vue 3, check out my series [Diving Into Vue 3](https://blog.deepgram.com/diving-into-vue-3-getting-started/).\n\nToday I will build the `AudioCaptions.vue` component. (For the `VideoPlayer` component, see my [previous post](https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/#composable-to-bring-in-an-external-script) in the series.) Here is the page with minimal styling. I've put a red box around the `AudioCaptions.vue` component:\n\n![StreamChannel page emphasizing AudioCaptions.vue component](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/StreamChannel_captions.png)\n\nWhere it says \"Deepgram Not Connected,\" there will be text captions that display in real-time along with the video stream.\n\nHere is a diagram of what I will build today:\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/AudioTranscription_Final.png\" alt=\"Audio Transcription Feature Diagram\" style=\"width: 75%; margin:auto;\">\n\nThis feature will rely on Vue 3's Composition API, especially Vue Composables, to put Deepgram captions on the screen.\n\n## Composables and Asynchronous Logic\n\nComposables are a feature of the Vue 3 Composition API; **custom composables** are the ones I build myself with the intention of encapsulating reusable, stateful logic.\n\nI feel like it is somewhat of an art learning how to write composables. The key to writing them well is making them as generic as possible so that they can be reused in many contexts.\n\nFor example, I could write a function that does everything I need it to do to create text captions on the screen using the Deepgram API - the function would include logic to get an API key, turn on the browser microphone, get the audio stream from the microphone, and then send the stream through a WebSocket. I could call the composable `useDeepgram`.\n\nHowever, there are several logical concerns in that one large `useDeepgram` function that could be broken out into other composable functions. While it's easier just to write it all in one file, it means I could only use it in situations that are exactly like this project.\n\nThe challenge of breaking it apart is that the logic to get the transcription from Deepgram depends on certain things happening first, such as the API key arriving and the microphone being turned on. When I break that logic apart into separate functions, I have to be conscious of the order that those functions run, the state that gets updated in multiple functions (and making sure the functions stay in sync), and the conventions for writing asynchronous logic. Not to mention the challenge of updating the component in real-time with the data that comes through the WebSocket.\n\nThe point is that writing composables in the real world can be challenging, so learning some strategies for dealing with more complicated situations, particularly asynchronous logic, is worth it. Because the beauty of composables is that if you write them well, you have a clean, reusable function that you'll return to again and again.\n\n## Composable Using Async and Await\n\nHere is the `AudioCaptions.vue` component right now, before I add the feature logic:\n\n```js\n<template>\n  <div>\n    <p>Status Will Go Here</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  setup() {\n    return {};\n  },\n};\n<\/script>\n```\n\nIn the template where it says \"Status Will Go Here,\" I plan to add a reactive variable. That value will update to show the audio captions after everything is working. For now, I've just hard-coded that text.\n\n### useDeepgramKey Composable\n\nThe first composable I'm going to write will be called `useDeepgramKey.js`, and its purpose will be to fetch a temporary API key. If I fetch a temporary API key from Deepgram, I can use the key in the browser and not worry about exposing the key since the key will expire almost immediately. Read more about this feature in a blog post that Kevin wrote about [protecting your Deepgram API key](https://blog.deepgram.com/protecting-api-key/).\n\nOn the backend, I have set up an endpoint to receive the fetch request from the composable. That endpoint can be seen in the `server.js` file in my repo [here](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/deepgram-composables/server.js).\n\nNow I'll create the `useDeepgramKey.js` composable.\n\n<img src=\"https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/useDeepgramKey.png\" alt=\"Create useDeepgramKey.js file in Composables folder\" style=\"width: 50%; margin:auto;\">\n\n### Tip #1 - Use async and await to write a composable that returns a promise.\n\nI will do three things to make this composable run asynchronously:\n\n1.  Write the composable as an async function using `export default async` to make the composable itself know to wait for the fetch request to finish.\n\n2.  Encapsulate the fetch request in its own async function called `async function getKey()`, which is called inside the composable using the `await` keyword.\n\n3.  In the component `AudioCaptions`, use a `.then()` when I call the composable so that I get access to the returned state after the Promise completes.\n\nHere is the composable to start. The `key` will update to be the API key when that arrives from the backend, and `DGStatus` will update with a message if there is an error.\n\n```js\nimport { ref } from 'vue'\nlet key = ref('')\nlet DGStatus = ref('Deepgram Not Connected')\n\nexport default async function useDeepgramKey() {\n  return { key, DGStatus }\n}\n```\n\nNow I'll write an async function that will perform all the logic of getting the temporary key. I'll name it `getKey()` and I will use a try-catch block to make the fetch request and handle any errors:\n\n```js\nasync function getKey() {\n  try {\n    const res = await fetch('http://localhost:8080/deepgram-token', {\n      headers: { 'Content-type': 'application/json' },\n    })\n    if (res) {\n      const response = await res.json()\n      // update with temporary api key:\n      key.value = response.key\n      return key\n    }\n  } catch (error) {\n    if (error) {\n      // update to show error message on screen:\n      DGStatus.value = 'Error. Please try again.'\n    }\n  }\n}\n```\n\nTo make sure this runs, I need to call the function in the composable. I will add `await getKey()` to the async function that will be exported. Using `await` is to go along with `async` that I used on the composable function itself. These two keywords together tell the composable that it must wait until the `getKey` function resolves.\n\nHere is the composable in its entirety:\n\n```js\nimport { ref } from 'vue'\nlet key = ref('')\nlet DGStatus = ref('Deepgram Not Connected')\n\nasync function getKey() {\n  try {\n    const res = await fetch('http://localhost:8080/deepgram-token', {\n      headers: { 'Content-type': 'application/json' },\n    })\n    if (res) {\n      const response = await res.json()\n      // update with temporary api key:\n      key.value = response.key\n      return key\n    }\n  } catch (error) {\n    if (error) {\n      // update to show error message on screen:\n      DGStatus.value = 'Error. Please try again.'\n    }\n  }\n}\n\nexport default async function useDeepgramKey() {\n  // call function:\n  await getKey()\n  return { key, DGStatus }\n}\n```\n\nI can `console.log(key.value)` to make sure the key is arriving successfully.\n\nThen I'll go back to `AudioCaptions.vue` to wire up a reactive reference that will update to show the error status message if the key does not arrive. I'll create a `ref` called `deepgramStatus` and replace the hardcoded \"Status Will Go Here\" with that variable.\n\n```js\n<template>\n  <div>\n    <p>{{ deepgramStatus }}</p>\n  </div>\n</template>\n\n<script>\nimport { ref } from \"vue\";\nexport default {\n  setup() {\n    let deepgramStatus = ref(\"Deepgram Not Connected\");\n    return { deepgramStatus };\n  },\n};\n<\/script>\n```\n\n**I also need to call the composable function in the component.** If I don't call it, the logic won't run. Since it is a promise, I will use a `.then()` method on it to get the result, which will be the `key` and `DGStatus` values. I only need the `DGStatus`, so I'll set that to the `deepgramStatus` ref.\n\nHere's the `AudioCaptions.vue` script now:\n\n```js\n<script>\nimport { ref } from \"vue\";\nimport useDeepgramKey from \"@/composables/useDeepgramKey\";\nexport default {\n  setup() {\n    let deepgramStatus = ref(\"Deepgram Not Connected\");\n\n    // use .then() to wait for promise resolution\n    useDeepgramKey().then((res) => {\n      deepgramStatus.value = res.DGStatus.value;\n    });\n\n    return { deepgramStatus };\n  },\n};\n<\/script>\n```\n\nIf I want to see the error message, I can delete a character in the fetch request URL, making it `http://localhost:8080/deepgram-toke`, which is incorrect. That will cause the fetch request to fail, and I'll see the error message.\n\n![Error. Please Try Again.](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/error-message.png)\n\n## Composable That Relies on Asynchronous Events in Other Composables\n\nNow I will begin to tackle the `useDeepgramSocket` composable. This composable will take an audio stream from the browser microphone and send it to Deepgram by way of a browser WebSocket. It relies on two other composables to do this:\n\n1.  `useDeepgramKey` - I need to get the temporary API key from the composable I just made, `useDeepgramKey`, to send it in the request to Deepgram; otherwise, Deepgram won't be able to fulfill the request.\n\n2.  `useMicrophone` - I need to get an audio stream from the browser microphone. That audio data will be sent to Deepgram to be transcribed into text that will be put onto the screen as captions.\n\nI haven't created the `useMicrophone` composable yet, so I'll make a quick detour right now to write that composable.\n\n### useMicrophone Composable\n\nThe `useMicrophone` composable will rely on the browser Media Stream API and the `getUserMedia` method to request permission to use the browser microphone of the user and pull the audio from it. Since there are several other blog posts in [Deepgram Docs](https://developers.deepgram.com/) about this nifty API, I won't go into detail about how it works. Check out [Brian's post](https://blog.deepgram.com/getting-started-with-mediastream-api/) for a general introduction to it.\n\nThis composable is also going to use an `async` function since the `getUserMedia` method requires waiting for the user to give permission to use the microphone. The time involved means that this method returns a promise. I already know how to write this type of composable since I just did it in the last section.\n\nI'll make the composable an `async` function and I'll also write the logic to get the audio stream as an `async` function. Here is the composable in its entirety:\n\n```js\nasync function getAudio() {\n  try {\n    const mediaStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n    })\n    const mediaRecorder = new MediaRecorder(mediaStream, {\n      audio: true,\n    })\n    return mediaRecorder\n  } catch (e) {\n    console.error(e)\n  }\n}\n\nexport default async function useMicrophone() {\n  const microphone = await getAudio()\n  return { microphone }\n}\n```\n\nNow it's ready for me to use in the next composable I will write.\n\n### useDeepgramSocket Composable\n\nFirst, I'll import this composable into `AudioCaptions.vue` and call it. That way, everything I write in `useDeepgramSocket` will run and I can check my progress as I build this composable.\n\n```js\n<script>\nimport { ref } from \"vue\";\nimport useDeepgramKey from \"@/composables/useDeepgramKey\";\nimport useDeepgramSocket from \"@/composables/useDeepgramSocket\";\nexport default {\n  setup() {\n    let deepgramStatus = ref(\"Deepgram Not Connected\");\n\n    useDeepgramKey().then((res) => {\n      deepgramStatus.value = res.DGStatus.value;\n    });\n\n    // call this so the composable runs as I work on it\n    useDeepgramSocket();\n\n    return { deepgramStatus };\n  },\n};\n<\/script>\n```\n\nI know I need to have access to the temporary API key from `useDeepgramToken` and to the microphone from `useMicrophone`. **I will start by setting up my composable to show that I have access to them within the same scope.**\n\nBoth composables return a promise. That means I will need to use syntax that will make the functions run but wait for the promise to resolve before moving on to the next thing.\n\n### Tip #2 - Use `.then()` to chain each composable that returns a promise to run asynchronously if returned values need to be in the same scope\n\nHere's what I mean:\n\n```js\nimport useDeepgramKey from './useDeepgramKey'\nimport useMicrophone from './useMicrophone'\n\nexport default function useDeepgramSocket() {\n  // chain .then() methods for each composable:\n  useDeepgramKey().then((keyRes) => {\n    useMicrophone().then((microphoneRes) => {\n      let apiKey = keyRes.key.value\n      let microphone = microphoneRes.microphone\n\n      console.log(apiKey)\n      console.log(microphone)\n\n      // WEBSOCKET FUNCTION WILL GO HERE\n    })\n  })\n  return {}\n}\n```\n\nI have named the result argument in each `.then()` a name that shows which composable they came from - `keyRes` and `microphoneRes`, which makes it easy for me to see what each of them represents. The `keyRes` is a `ref`, so I must drill all the way down to the `.value` property. The `microphoneRes` is a Vue 3 `readonly` property, which is why I don't have to drill down as far.\n\nNow that I have the values, I can write a function that encapsulates the logic to open the WebSocket.\n\n### openDeepgramSocket Function\n\nI will write a function called `openDeepgramSocket` that will do the following:\n\n*   Create the socket with `new WebSocket(URL, deepgram protocols)`.\n*   Open the socket with `socket.onopen`. When it opens, I'll add an event listener to the microphone to take in the audio stream and send it through the socket.\n*   Have `socket.onclose` listen for when the channel closes.\n\nI will also create a reactive reference called `DGStatus_socket` to update the status of the transcription along the way. That value will be returned to the `AudioCaptions.vue` component as the text captions.\n\nHere is the function:\n\n```js\nfunction openDeepgramSocket(apiKey, microphone) {\n  const socket = new WebSocket(\n    'wss://api.deepgram.com/v1/listen?punctuate=true',\n    ['token', apiKey]\n  )\n\n  socket.onopen = () => {\n    if (microphone.state != 'recording') {\n      DGStatus_socket.value = 'Connected to Deepgram'\n      console.log('Connection opened.')\n\n      microphone.addEventListener('dataavailable', async (event) => {\n        if (event.data.size > 0 && socket.readyState == 1) {\n          socket.send(event.data)\n        }\n      })\n\n      microphone.start(200)\n    }\n  }\n\n  socket.onmessage = (message) => {\n    const received = JSON.parse(message.data)\n    const transcript = received.channel.alternatives[0].transcript\n    if (transcript && received.is_final) {\n      DGStatus_socket.value = transcript + ''\n      // shows the transcript in the console:\n      console.log(DGStatus_socket.value)\n    }\n  }\n\n  socket.onclose = () => {\n    console.log('Connection closed.')\n  }\n}\n```\n\nI have to make sure to call the function in the composable:\n\n```js\nexport default function useDeepgramSocket() {\n  useDeepgramKey().then((keyRes) => {\n    useMicrophone().then((microphoneRes) => {\n      let apiKey = keyRes.key.value\n      let microphone = microphoneRes.microphone\n\n      // Call function:\n      openDeepgramSocket(apiKey, microphone)\n    })\n  })\n  return {}\n}\n```\n\nNow I see the transcript coming back to me because I have added a console.log to show it:\n\n![transcript returned in console with messages](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/transcript_console.png)\n\nI'm ready to put that transcript onto the screen as the captions!\n\n### Vue watch to Update Transcript Status\n\nI will use the reactive reference `DGStatus_socket` in the composable `useDeepgramSocket` to update the captions in `AudioCaptions.vue`. To do that, I need to return it from the composable and then destructure it in the component `AudioCaptions.vue`.\n\nHere is the `useDeepgramSocket` composable where I return the `DGStatus_socket` value (excluding the large `openDeepgramSocket` function):\n\n```js\nimport { ref } from \"vue\";\nimport useDeepgramKey from \"./useDeepgramKey\";\nimport useMicrophone from \"./useMicrophone\";\n\n// create status ref\nlet DGStatus_socket = ref(\"\");\n\nfunction openDeepgramSocket(apiKey, microphone) {\n...\n}\n\nexport default function useDeepgramSocket() {\n  useDeepgramKey().then((keyRes) => {\n    useMicrophone().then((microphoneRes) => {\n      let apiKey = keyRes.key.value;\n      let microphone = microphoneRes.microphone;\n\n      openDeepgramSocket(apiKey, microphone);\n    });\n  });\n\n  // return status ref to component\n  return { DGStatus_socket };\n}\n```\n\nIn `AudioCaptions.vue`, I destructure the `DGStatus_socket` so I have access to it:\n\n```js\nconst { DGStatus_socket } = useDeepgramSocket()\n```\n\nIs it working? Not yet. I have to update the `deepgramStatus` ref that is connected to the template if I want to see those captions on the screen.\n\n### Tip #3: Use watch to update a value in the component and trigger a side effect in-sync with that change\n\nAccording to the Vue documentation, `watch` is used in \"cases where we need to perform 'side effects' in reaction to state changes - for example, mutating the DOM or changing another piece of state based on the result of an async operation.\"\n\nThis example of putting the captions on the screen fits that description exactly. I want the `deepgramStatus` value to update if `DGStatus_socket` from the composable `useDeepgramSocket` changes, and I want that state change to trigger the effect of the text updating in the DOM.\n\nI will add a watcher to the `AudioCaptions` component:\n\n```js\nwatch(DGStatus_socket, () => {\n  deepgramStatus.value = DGStatus_socket.value\n})\n```\n\nAnd this is what the component in its entirety looks like now:\n\n```js\n<template>\n  <div>\n    <p>{{ deepgramStatus }}</p>\n  </div>\n</template>\n\n<script>\nimport { ref, watch } from \"vue\";\nimport useDeepgramKey from \"@/composables/useDeepgramKey\";\nimport useDeepgramSocket from \"@/composables/useDeepgramSocket\";\nexport default {\n  setup() {\n    let deepgramStatus = ref(\"Deepgram Not Connected\");\n\n    useDeepgramKey().then((res) => {\n      deepgramStatus.value = res.DGStatus.value;\n    });\n\n    const { DGStatus_socket } = useDeepgramSocket();\n\n    watch(DGStatus_socket, () => {\n      deepgramStatus.value = DGStatus_socket.value;\n    });\n\n    return { deepgramStatus };\n  },\n};\n<\/script>\n\n```\n\nAnd with that, I have my captions powered by Deepgram! Check out the code for this post on my repo branch [deepgram-composables](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/deepgram-composables).\n\n![Captions working](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/captions.gif)\n\n## Conclusion\n\nToday I built the final component of my project, a full-stack video streaming application with text captions.\n\nThis post contained the barebones logic for the captions feature, but in my actual project, I have added styling to improve the user experience, and I've added buttons to turn the captions on or off. Check out the repo [here](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram).\n\nHere is the final project:\n\n![Final project demo](https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/VideoExample.gif)\n\nIt's been a great experience learning about Amazon IVS and Deepgram, and I've gotten the chance to get a better taste of how to take advantage Vue 3's composition API.\n\nIf you enjoyed this series, please follow me on [Twitter](https://twitter.com/sandra_rodgers_) to receive updates on future series I have in the works!\n\n        ";
}
function compiledContent() {
  return '<p>This is the final post of my series, \u201CHow to Build a Live Streaming Web Application with Amazon IVS and Deepgram.\u201D</p>\n<Panel type="info" title="Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)"><ol><li><a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>\n<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>\n<li><a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li><li><a href="https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li></ol></Panel>\n<p>For today\u2019s post, I recommend getting a Deepgram API key to use in this project, which anyone can get by heading to the <a href="https://console.deepgram.com/signup?jump=keys">Deepgram console</a>.</p>\n<h2 id="introduction---async-and-the-composition-api">Introduction - Async and the Composition API</h2>\n<p>Today\u2019s post will cover how to use Vue 3 composables to power a text-captions component that integrates with Deepgram\u2019s speech-to-text API. Some of the things I\u2019ll cover today are:</p>\n<ul>\n<li>Using <code is:raw>async</code> and <code is:raw>await</code> to write a composable that fetches a temporary API key from Deepgram.</li>\n<li>Using Vue 3\u2019s <code is:raw>watch</code> method to react to data that is updating in real-time as Deepgram sends a text transcription back through a browser WebSocket.</li>\n<li>Writing logic that is sensitive to the order things occur - i.e., asynchronous logic that flows between the component and the composable.</li>\n</ul>\n<p>This post assumes some knowledge of Vue 3, in particular Vue composables. For a refresher on Vue 3, check out my series <a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3</a>.</p>\n<p>Today I will build the <code is:raw>AudioCaptions.vue</code> component. (For the <code is:raw>VideoPlayer</code> component, see my <a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/#composable-to-bring-in-an-external-script">previous post</a> in the series.) Here is the page with minimal styling. I\u2019ve put a red box around the <code is:raw>AudioCaptions.vue</code> component:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/StreamChannel_captions.png" alt="StreamChannel page emphasizing AudioCaptions.vue component"></p>\n<p>Where it says \u201CDeepgram Not Connected,\u201D there will be text captions that display in real-time along with the video stream.</p>\n<p>Here is a diagram of what I will build today:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/AudioTranscription_Final.png" alt="Audio Transcription Feature Diagram" style="width: 75%; margin:auto;" />\n<p>This feature will rely on Vue 3\u2019s Composition API, especially Vue Composables, to put Deepgram captions on the screen.</p>\n<h2 id="composables-and-asynchronous-logic">Composables and Asynchronous Logic</h2>\n<p>Composables are a feature of the Vue 3 Composition API; <strong>custom composables</strong> are the ones I build myself with the intention of encapsulating reusable, stateful logic.</p>\n<p>I feel like it is somewhat of an art learning how to write composables. The key to writing them well is making them as generic as possible so that they can be reused in many contexts.</p>\n<p>For example, I could write a function that does everything I need it to do to create text captions on the screen using the Deepgram API - the function would include logic to get an API key, turn on the browser microphone, get the audio stream from the microphone, and then send the stream through a WebSocket. I could call the composable <code is:raw>useDeepgram</code>.</p>\n<p>However, there are several logical concerns in that one large <code is:raw>useDeepgram</code> function that could be broken out into other composable functions. While it\u2019s easier just to write it all in one file, it means I could only use it in situations that are exactly like this project.</p>\n<p>The challenge of breaking it apart is that the logic to get the transcription from Deepgram depends on certain things happening first, such as the API key arriving and the microphone being turned on. When I break that logic apart into separate functions, I have to be conscious of the order that those functions run, the state that gets updated in multiple functions (and making sure the functions stay in sync), and the conventions for writing asynchronous logic. Not to mention the challenge of updating the component in real-time with the data that comes through the WebSocket.</p>\n<p>The point is that writing composables in the real world can be challenging, so learning some strategies for dealing with more complicated situations, particularly asynchronous logic, is worth it. Because the beauty of composables is that if you write them well, you have a clean, reusable function that you\u2019ll return to again and again.</p>\n<h2 id="composable-using-async-and-await">Composable Using Async and Await</h2>\n<p>Here is the <code is:raw>AudioCaptions.vue</code> component right now, before I add the feature logic:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;Status Will Go Here&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    return {};</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>In the template where it says \u201CStatus Will Go Here,\u201D I plan to add a reactive variable. That value will update to show the audio captions after everything is working. For now, I\u2019ve just hard-coded that text.</p>\n<h3 id="usedeepgramkey-composable">useDeepgramKey Composable</h3>\n<p>The first composable I\u2019m going to write will be called <code is:raw>useDeepgramKey.js</code>, and its purpose will be to fetch a temporary API key. If I fetch a temporary API key from Deepgram, I can use the key in the browser and not worry about exposing the key since the key will expire almost immediately. Read more about this feature in a blog post that Kevin wrote about <a href="https://blog.deepgram.com/protecting-api-key/">protecting your Deepgram API key</a>.</p>\n<p>On the backend, I have set up an endpoint to receive the fetch request from the composable. That endpoint can be seen in the <code is:raw>server.js</code> file in my repo <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/deepgram-composables/server.js">here</a>.</p>\n<p>Now I\u2019ll create the <code is:raw>useDeepgramKey.js</code> composable.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/useDeepgramKey.png" alt="Create useDeepgramKey.js file in Composables folder" style="width: 50%; margin:auto;" />\n<h3 id="tip-1---use-async-and-await-to-write-a-composable-that-returns-a-promise">Tip #1 - Use async and await to write a composable that returns a promise.</h3>\n<p>I will do three things to make this composable run asynchronously:</p>\n<ol>\n<li>\n<p>Write the composable as an async function using <code is:raw>export default async</code> to make the composable itself know to wait for the fetch request to finish.</p>\n</li>\n<li>\n<p>Encapsulate the fetch request in its own async function called <code is:raw>async function getKey()</code>, which is called inside the composable using the <code is:raw>await</code> keyword.</p>\n</li>\n<li>\n<p>In the component <code is:raw>AudioCaptions</code>, use a <code is:raw>.then()</code> when I call the composable so that I get access to the returned state after the Promise completes.</p>\n</li>\n</ol>\n<p>Here is the composable to start. The <code is:raw>key</code> will update to be the API key when that arrives from the backend, and <code is:raw>DGStatus</code> will update with a message if there is an error.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> key </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> DGStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Deepgram Not Connected&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">async</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { key, DGStatus }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now I\u2019ll write an async function that will perform all the logic of getting the temporary key. I\u2019ll name it <code is:raw>getKey()</code> and I will use a try-catch block to make the fetch request and handle any errors:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getKey</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">res</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/deepgram-token&#39;</span><span style="color: #C9D1D9">, {</span></span>\n<span class="line"><span style="color: #C9D1D9">      headers: { </span><span style="color: #A5D6FF">&#39;Content-type&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;application/json&#39;</span><span style="color: #C9D1D9"> },</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (res) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">response</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> res.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update with temporary api key:</span></span>\n<span class="line"><span style="color: #C9D1D9">      key.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response.key</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> key</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">catch</span><span style="color: #C9D1D9"> (error) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (error) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update to show error message on screen:</span></span>\n<span class="line"><span style="color: #C9D1D9">      DGStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Error. Please try again.&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>To make sure this runs, I need to call the function in the composable. I will add <code is:raw>await getKey()</code> to the async function that will be exported. Using <code is:raw>await</code> is to go along with <code is:raw>async</code> that I used on the composable function itself. These two keywords together tell the composable that it must wait until the <code is:raw>getKey</code> function resolves.</p>\n<p>Here is the composable in its entirety:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> key </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> DGStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Deepgram Not Connected&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getKey</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">res</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/deepgram-token&#39;</span><span style="color: #C9D1D9">, {</span></span>\n<span class="line"><span style="color: #C9D1D9">      headers: { </span><span style="color: #A5D6FF">&#39;Content-type&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;application/json&#39;</span><span style="color: #C9D1D9"> },</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (res) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">response</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> res.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update with temporary api key:</span></span>\n<span class="line"><span style="color: #C9D1D9">      key.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response.key</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> key</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">catch</span><span style="color: #C9D1D9"> (error) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (error) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update to show error message on screen:</span></span>\n<span class="line"><span style="color: #C9D1D9">      DGStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Error. Please try again.&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">async</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// call function:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getKey</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { key, DGStatus }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I can <code is:raw>console.log(key.value)</code> to make sure the key is arriving successfully.</p>\n<p>Then I\u2019ll go back to <code is:raw>AudioCaptions.vue</code> to wire up a reactive reference that will update to show the error status message if the key does not arrive. I\u2019ll create a <code is:raw>ref</code> called <code is:raw>deepgramStatus</code> and replace the hardcoded \u201CStatus Will Go Here\u201D with that variable.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9">{ deepgramStatus }</span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p><strong>I also need to call the composable function in the component.</strong> If I don\u2019t call it, the logic won\u2019t run. Since it is a promise, I will use a <code is:raw>.then()</code> method on it to get the result, which will be the <code is:raw>key</code> and <code is:raw>DGStatus</code> values. I only need the <code is:raw>DGStatus</code>, so I\u2019ll set that to the <code is:raw>deepgramStatus</code> ref.</p>\n<p>Here\u2019s the <code is:raw>AudioCaptions.vue</code> script now:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramKey from &quot;@/composables/useDeepgramKey&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// use .then() to wait for promise resolution</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FFA657">deepgramStatus</span><span style="color: #C9D1D9">.</span><span style="color: #FFA657">value</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> res.DGStatus.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>If I want to see the error message, I can delete a character in the fetch request URL, making it <code is:raw>http://localhost:8080/deepgram-toke</code>, which is incorrect. That will cause the fetch request to fail, and I\u2019ll see the error message.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/error-message.png" alt="Error. Please Try Again."></p>\n<h2 id="composable-that-relies-on-asynchronous-events-in-other-composables">Composable That Relies on Asynchronous Events in Other Composables</h2>\n<p>Now I will begin to tackle the <code is:raw>useDeepgramSocket</code> composable. This composable will take an audio stream from the browser microphone and send it to Deepgram by way of a browser WebSocket. It relies on two other composables to do this:</p>\n<ol>\n<li>\n<p><code is:raw>useDeepgramKey</code> - I need to get the temporary API key from the composable I just made, <code is:raw>useDeepgramKey</code>, to send it in the request to Deepgram; otherwise, Deepgram won\u2019t be able to fulfill the request.</p>\n</li>\n<li>\n<p><code is:raw>useMicrophone</code> - I need to get an audio stream from the browser microphone. That audio data will be sent to Deepgram to be transcribed into text that will be put onto the screen as captions.</p>\n</li>\n</ol>\n<p>I haven\u2019t created the <code is:raw>useMicrophone</code> composable yet, so I\u2019ll make a quick detour right now to write that composable.</p>\n<h3 id="usemicrophone-composable">useMicrophone Composable</h3>\n<p>The <code is:raw>useMicrophone</code> composable will rely on the browser Media Stream API and the <code is:raw>getUserMedia</code> method to request permission to use the browser microphone of the user and pull the audio from it. Since there are several other blog posts in <a href="https://developers.deepgram.com/">Deepgram Docs</a> about this nifty API, I won\u2019t go into detail about how it works. Check out <a href="https://blog.deepgram.com/getting-started-with-mediastream-api/">Brian\u2019s post</a> for a general introduction to it.</p>\n<p>This composable is also going to use an <code is:raw>async</code> function since the <code is:raw>getUserMedia</code> method requires waiting for the user to give permission to use the microphone. The time involved means that this method returns a promise. I already know how to write this type of composable since I just did it in the last section.</p>\n<p>I\u2019ll make the composable an <code is:raw>async</code> function and I\u2019ll also write the logic to get the audio stream as an <code is:raw>async</code> function. Here is the composable in its entirety:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getAudio</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">mediaStream</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> navigator.mediaDevices.</span><span style="color: #D2A8FF">getUserMedia</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">      audio: </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">mediaRecorder</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">MediaRecorder</span><span style="color: #C9D1D9">(mediaStream, {</span></span>\n<span class="line"><span style="color: #C9D1D9">      audio: </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> mediaRecorder</span></span>\n<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">catch</span><span style="color: #C9D1D9"> (e) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    console.</span><span style="color: #D2A8FF">error</span><span style="color: #C9D1D9">(e)</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">async</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">microphone</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getAudio</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { microphone }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now it\u2019s ready for me to use in the next composable I will write.</p>\n<h3 id="usedeepgramsocket-composable">useDeepgramSocket Composable</h3>\n<p>First, I\u2019ll import this composable into <code is:raw>AudioCaptions.vue</code> and call it. That way, everything I write in <code is:raw>useDeepgramSocket</code> will run and I can check my progress as I build this composable.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramKey from &quot;@/composables/useDeepgramKey&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramSocket from &quot;@/composables/useDeepgramSocket&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FFA657">deepgramStatus</span><span style="color: #C9D1D9">.</span><span style="color: #FFA657">value</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> res.DGStatus.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// call this so the composable runs as I work on it</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>I know I need to have access to the temporary API key from <code is:raw>useDeepgramToken</code> and to the microphone from <code is:raw>useMicrophone</code>. <strong>I will start by setting up my composable to show that I have access to them within the same scope.</strong></p>\n<p>Both composables return a promise. That means I will need to use syntax that will make the functions run but wait for the promise to resolve before moving on to the next thing.</p>\n<h3 id="tip-2---use-then-to-chain-each-composable-that-returns-a-promise-to-run-asynchronously-if-returned-values-need-to-be-in-the-same-scope">Tip #2 - Use <code is:raw>.then()</code> to chain each composable that returns a promise to run asynchronously if returned values need to be in the same scope</h3>\n<p>Here\u2019s what I mean:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useDeepgramKey </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;./useDeepgramKey&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useMicrophone </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;./useMicrophone&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// chain .then() methods for each composable:</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">keyRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">microphoneRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> apiKey </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> keyRes.key.value</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> microphone </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> microphoneRes.microphone</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(apiKey)</span></span>\n<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(microphone)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// WEBSOCKET FUNCTION WILL GO HERE</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {}</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I have named the result argument in each <code is:raw>.then()</code> a name that shows which composable they came from - <code is:raw>keyRes</code> and <code is:raw>microphoneRes</code>, which makes it easy for me to see what each of them represents. The <code is:raw>keyRes</code> is a <code is:raw>ref</code>, so I must drill all the way down to the <code is:raw>.value</code> property. The <code is:raw>microphoneRes</code> is a Vue 3 <code is:raw>readonly</code> property, which is why I don\u2019t have to drill down as far.</p>\n<p>Now that I have the values, I can write a function that encapsulates the logic to open the WebSocket.</p>\n<h3 id="opendeepgramsocket-function">openDeepgramSocket Function</h3>\n<p>I will write a function called <code is:raw>openDeepgramSocket</code> that will do the following:</p>\n<ul>\n<li>Create the socket with <code is:raw>new WebSocket(URL, deepgram protocols)</code>.</li>\n<li>Open the socket with <code is:raw>socket.onopen</code>. When it opens, I\u2019ll add an event listener to the microphone to take in the audio stream and send it through the socket.</li>\n<li>Have <code is:raw>socket.onclose</code> listen for when the channel closes.</li>\n</ul>\n<p>I will also create a reactive reference called <code is:raw>DGStatus_socket</code> to update the status of the transcription along the way. That value will be returned to the <code is:raw>AudioCaptions.vue</code> component as the text captions.</p>\n<p>Here is the function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">apiKey</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">microphone</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">socket</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">WebSocket</span><span style="color: #C9D1D9">(</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?punctuate=true&#39;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    [</span><span style="color: #A5D6FF">&#39;token&#39;</span><span style="color: #C9D1D9">, apiKey]</span></span>\n<span class="line"><span style="color: #C9D1D9">  )</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  socket.</span><span style="color: #D2A8FF">onopen</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (microphone.state </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;recording&#39;</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      DGStatus_socket.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Connected to Deepgram&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Connection opened.&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      microphone.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;dataavailable&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">event</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (event.data.size </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> socket.readyState </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">          socket.</span><span style="color: #D2A8FF">send</span><span style="color: #C9D1D9">(event.data)</span></span>\n<span class="line"><span style="color: #C9D1D9">        }</span></span>\n<span class="line"><span style="color: #C9D1D9">      })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      microphone.</span><span style="color: #D2A8FF">start</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  socket.</span><span style="color: #D2A8FF">onmessage</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">message</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">received</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">JSON</span><span style="color: #C9D1D9">.</span><span style="color: #D2A8FF">parse</span><span style="color: #C9D1D9">(message.data)</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">transcript</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> received.channel.alternatives[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">].transcript</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (transcript </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> received.is_final) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      DGStatus_socket.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// shows the transcript in the console:</span></span>\n<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(DGStatus_socket.value)</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  socket.</span><span style="color: #D2A8FF">onclose</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Connection closed.&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I have to make sure to call the function in the composable:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">keyRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">microphoneRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> apiKey </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> keyRes.key.value</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> microphone </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> microphoneRes.microphone</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// Call function:</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(apiKey, microphone)</span></span>\n<span class="line"><span style="color: #C9D1D9">    })</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {}</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now I see the transcript coming back to me because I have added a console.log to show it:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/transcript_console.png" alt="transcript returned in console with messages"></p>\n<p>I\u2019m ready to put that transcript onto the screen as the captions!</p>\n<h3 id="vue-watch-to-update-transcript-status">Vue watch to Update Transcript Status</h3>\n<p>I will use the reactive reference <code is:raw>DGStatus_socket</code> in the composable <code is:raw>useDeepgramSocket</code> to update the captions in <code is:raw>AudioCaptions.vue</code>. To do that, I need to return it from the composable and then destructure it in the component <code is:raw>AudioCaptions.vue</code>.</p>\n<p>Here is the <code is:raw>useDeepgramSocket</code> composable where I return the <code is:raw>DGStatus_socket</code> value (excluding the large <code is:raw>openDeepgramSocket</code> function):</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;vue&quot;</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useDeepgramKey </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;./useDeepgramKey&quot;</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useMicrophone </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;./useMicrophone&quot;</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #8B949E">// create status ref</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> DGStatus_socket </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">apiKey</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">microphone</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #FF7B72">...</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">keyRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">microphoneRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> apiKey </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> keyRes.key.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> microphone </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> microphoneRes.microphone;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(apiKey, microphone);</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"><span style="color: #C9D1D9">  });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// return status ref to component</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { DGStatus_socket };</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>In <code is:raw>AudioCaptions.vue</code>, I destructure the <code is:raw>DGStatus_socket</code> so I have access to it:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">DGStatus_socket</span><span style="color: #C9D1D9"> } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #C9D1D9">()</span></span></code></pre>\n<p>Is it working? Not yet. I have to update the <code is:raw>deepgramStatus</code> ref that is connected to the template if I want to see those captions on the screen.</p>\n<h3 id="tip-3-use-watch-to-update-a-value-in-the-component-and-trigger-a-side-effect-in-sync-with-that-change">Tip #3: Use watch to update a value in the component and trigger a side effect in-sync with that change</h3>\n<p>According to the Vue documentation, <code is:raw>watch</code> is used in \u201Ccases where we need to perform \u2018side effects\u2019 in reaction to state changes - for example, mutating the DOM or changing another piece of state based on the result of an async operation.\u201D</p>\n<p>This example of putting the captions on the screen fits that description exactly. I want the <code is:raw>deepgramStatus</code> value to update if <code is:raw>DGStatus_socket</code> from the composable <code is:raw>useDeepgramSocket</code> changes, and I want that state change to trigger the effect of the text updating in the DOM.</p>\n<p>I will add a watcher to the <code is:raw>AudioCaptions</code> component:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(DGStatus_socket, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  deepgramStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> DGStatus_socket.value</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>And this is what the component in its entirety looks like now:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9">{ deepgramStatus }</span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref, watch </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramKey from &quot;@/composables/useDeepgramKey&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useDeepgramSocket from &quot;@/composables/useDeepgramSocket&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FFA657">deepgramStatus</span><span style="color: #C9D1D9">.</span><span style="color: #FFA657">value</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> res.DGStatus.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    const { DGStatus_socket } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(DGStatus_socket, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      deepgramStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> DGStatus_socket.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span></code></pre>\n<p>And with that, I have my captions powered by Deepgram! Check out the code for this post on my repo branch <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/deepgram-composables">deepgram-composables</a>.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/captions.gif" alt="Captions working"></p>\n<h2 id="conclusion">Conclusion</h2>\n<p>Today I built the final component of my project, a full-stack video streaming application with text captions.</p>\n<p>This post contained the barebones logic for the captions feature, but in my actual project, I have added styling to improve the user experience, and I\u2019ve added buttons to turn the captions on or off. Check out the repo <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram">here</a>.</p>\n<p>Here is the final project:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/VideoExample.gif" alt="Final project demo"></p>\n<p>It\u2019s been a great experience learning about Amazon IVS and Deepgram, and I\u2019ve gotten the chance to get a better taste of how to take advantage Vue 3\u2019s composition API.</p>\n<p>If you enjoyed this series, please follow me on <a href="https://twitter.com/sandra_rodgers_">Twitter</a> to receive updates on future series I have in the works!</p>';
}
const $$Astro = createAstro("/Users/sandrarodgers/web-next/blog/src/content/blog/posts/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/index.md", "https://blog.deepgram.com/", "file:///Users/sandrarodgers/web-next/blog/");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  new Slugger();
  return renderTemplate`<head>${renderHead($$result)}</head><p>This is the final post of my series, “How to Build a Live Streaming Web Application with Amazon IVS and Deepgram.”</p>
${renderComponent($$result, "Panel", Panel, { "type": "info", "title": "Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)" }, { "default": () => renderTemplate`<ol><li><a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>
<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>
<li><a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li><li><a href="https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li></ol>` })}
<p>For today’s post, I recommend getting a Deepgram API key to use in this project, which anyone can get by heading to the <a href="https://console.deepgram.com/signup?jump=keys">Deepgram console</a>.</p>
<h2 id="introduction---async-and-the-composition-api">Introduction - Async and the Composition API</h2>
<p>Today’s post will cover how to use Vue 3 composables to power a text-captions component that integrates with Deepgram’s speech-to-text API. Some of the things I’ll cover today are:</p>
<ul>
<li>Using <code>async</code> and <code>await</code> to write a composable that fetches a temporary API key from Deepgram.</li>
<li>Using Vue 3’s <code>watch</code> method to react to data that is updating in real-time as Deepgram sends a text transcription back through a browser WebSocket.</li>
<li>Writing logic that is sensitive to the order things occur - i.e., asynchronous logic that flows between the component and the composable.</li>
</ul>
<p>This post assumes some knowledge of Vue 3, in particular Vue composables. For a refresher on Vue 3, check out my series <a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3</a>.</p>
<p>Today I will build the <code>AudioCaptions.vue</code> component. (For the <code>VideoPlayer</code> component, see my <a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/#composable-to-bring-in-an-external-script">previous post</a> in the series.) Here is the page with minimal styling. I’ve put a red box around the <code>AudioCaptions.vue</code> component:</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/StreamChannel_captions.png" alt="StreamChannel page emphasizing AudioCaptions.vue component"></p>
<p>Where it says “Deepgram Not Connected,” there will be text captions that display in real-time along with the video stream.</p>
<p>Here is a diagram of what I will build today:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/AudioTranscription_Final.png" alt="Audio Transcription Feature Diagram" style="width: 75%; margin:auto;">
<p>This feature will rely on Vue 3’s Composition API, especially Vue Composables, to put Deepgram captions on the screen.</p>
<h2 id="composables-and-asynchronous-logic">Composables and Asynchronous Logic</h2>
<p>Composables are a feature of the Vue 3 Composition API; <strong>custom composables</strong> are the ones I build myself with the intention of encapsulating reusable, stateful logic.</p>
<p>I feel like it is somewhat of an art learning how to write composables. The key to writing them well is making them as generic as possible so that they can be reused in many contexts.</p>
<p>For example, I could write a function that does everything I need it to do to create text captions on the screen using the Deepgram API - the function would include logic to get an API key, turn on the browser microphone, get the audio stream from the microphone, and then send the stream through a WebSocket. I could call the composable <code>useDeepgram</code>.</p>
<p>However, there are several logical concerns in that one large <code>useDeepgram</code> function that could be broken out into other composable functions. While it’s easier just to write it all in one file, it means I could only use it in situations that are exactly like this project.</p>
<p>The challenge of breaking it apart is that the logic to get the transcription from Deepgram depends on certain things happening first, such as the API key arriving and the microphone being turned on. When I break that logic apart into separate functions, I have to be conscious of the order that those functions run, the state that gets updated in multiple functions (and making sure the functions stay in sync), and the conventions for writing asynchronous logic. Not to mention the challenge of updating the component in real-time with the data that comes through the WebSocket.</p>
<p>The point is that writing composables in the real world can be challenging, so learning some strategies for dealing with more complicated situations, particularly asynchronous logic, is worth it. Because the beauty of composables is that if you write them well, you have a clean, reusable function that you’ll return to again and again.</p>
<h2 id="composable-using-async-and-await">Composable Using Async and Await</h2>
<p>Here is the <code>AudioCaptions.vue</code> component right now, before I add the feature logic:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;Status Will Go Here&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    return {};</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>In the template where it says “Status Will Go Here,” I plan to add a reactive variable. That value will update to show the audio captions after everything is working. For now, I’ve just hard-coded that text.</p>
<h3 id="usedeepgramkey-composable">useDeepgramKey Composable</h3>
<p>The first composable I’m going to write will be called <code>useDeepgramKey.js</code>, and its purpose will be to fetch a temporary API key. If I fetch a temporary API key from Deepgram, I can use the key in the browser and not worry about exposing the key since the key will expire almost immediately. Read more about this feature in a blog post that Kevin wrote about <a href="https://blog.deepgram.com/protecting-api-key/">protecting your Deepgram API key</a>.</p>
<p>On the backend, I have set up an endpoint to receive the fetch request from the composable. That endpoint can be seen in the <code>server.js</code> file in my repo <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/deepgram-composables/server.js">here</a>.</p>
<p>Now I’ll create the <code>useDeepgramKey.js</code> composable.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/useDeepgramKey.png" alt="Create useDeepgramKey.js file in Composables folder" style="width: 50%; margin:auto;">
<h3 id="tip-1---use-async-and-await-to-write-a-composable-that-returns-a-promise">Tip #1 - Use async and await to write a composable that returns a promise.</h3>
<p>I will do three things to make this composable run asynchronously:</p>
<ol>
<li>
<p>Write the composable as an async function using <code>export default async</code> to make the composable itself know to wait for the fetch request to finish.</p>
</li>
<li>
<p>Encapsulate the fetch request in its own async function called <code>async function getKey()</code>, which is called inside the composable using the <code>await</code> keyword.</p>
</li>
<li>
<p>In the component <code>AudioCaptions</code>, use a <code>.then()</code> when I call the composable so that I get access to the returned state after the Promise completes.</p>
</li>
</ol>
<p>Here is the composable to start. The <code>key</code> will update to be the API key when that arrives from the backend, and <code>DGStatus</code> will update with a message if there is an error.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>
<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> key </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> DGStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Deepgram Not Connected&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">async</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { key, DGStatus }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>Now I’ll write an async function that will perform all the logic of getting the temporary key. I’ll name it <code>getKey()</code> and I will use a try-catch block to make the fetch request and handle any errors:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getKey</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">res</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/deepgram-token&#39;</span><span style="color: #C9D1D9">, {</span></span>
<span class="line"><span style="color: #C9D1D9">      headers: { </span><span style="color: #A5D6FF">&#39;Content-type&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;application/json&#39;</span><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">    })</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (res) {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">response</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> res.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update with temporary api key:</span></span>
<span class="line"><span style="color: #C9D1D9">      key.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response.key</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> key</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">catch</span><span style="color: #C9D1D9"> (error) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (error) {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update to show error message on screen:</span></span>
<span class="line"><span style="color: #C9D1D9">      DGStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Error. Please try again.&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>To make sure this runs, I need to call the function in the composable. I will add <code>await getKey()</code> to the async function that will be exported. Using <code>await</code> is to go along with <code>async</code> that I used on the composable function itself. These two keywords together tell the composable that it must wait until the <code>getKey</code> function resolves.</p>
<p>Here is the composable in its entirety:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>
<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> key </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> DGStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Deepgram Not Connected&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getKey</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">res</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/deepgram-token&#39;</span><span style="color: #C9D1D9">, {</span></span>
<span class="line"><span style="color: #C9D1D9">      headers: { </span><span style="color: #A5D6FF">&#39;Content-type&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;application/json&#39;</span><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">    })</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (res) {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">response</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> res.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update with temporary api key:</span></span>
<span class="line"><span style="color: #C9D1D9">      key.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> response.key</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> key</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">catch</span><span style="color: #C9D1D9"> (error) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (error) {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// update to show error message on screen:</span></span>
<span class="line"><span style="color: #C9D1D9">      DGStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Error. Please try again.&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">async</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// call function:</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getKey</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { key, DGStatus }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>I can <code>console.log(key.value)</code> to make sure the key is arriving successfully.</p>
<p>Then I’ll go back to <code>AudioCaptions.vue</code> to wire up a reactive reference that will update to show the error status message if the key does not arrive. I’ll create a <code>ref</code> called <code>deepgramStatus</code> and replace the hardcoded “Status Will Go Here” with that variable.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9">{ deepgramStatus }</span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p><strong>I also need to call the composable function in the component.</strong> If I don’t call it, the logic won’t run. Since it is a promise, I will use a <code>.then()</code> method on it to get the result, which will be the <code>key</code> and <code>DGStatus</code> values. I only need the <code>DGStatus</code>, so I’ll set that to the <code>deepgramStatus</code> ref.</p>
<p>Here’s the <code>AudioCaptions.vue</code> script now:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">import useDeepgramKey from &quot;@/composables/useDeepgramKey&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// use .then() to wait for promise resolution</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FFA657">deepgramStatus</span><span style="color: #C9D1D9">.</span><span style="color: #FFA657">value</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> res.DGStatus.value;</span></span>
<span class="line"><span style="color: #C9D1D9">    });</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>If I want to see the error message, I can delete a character in the fetch request URL, making it <code>http://localhost:8080/deepgram-toke</code>, which is incorrect. That will cause the fetch request to fail, and I’ll see the error message.</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/error-message.png" alt="Error. Please Try Again."></p>
<h2 id="composable-that-relies-on-asynchronous-events-in-other-composables">Composable That Relies on Asynchronous Events in Other Composables</h2>
<p>Now I will begin to tackle the <code>useDeepgramSocket</code> composable. This composable will take an audio stream from the browser microphone and send it to Deepgram by way of a browser WebSocket. It relies on two other composables to do this:</p>
<ol>
<li>
<p><code>useDeepgramKey</code> - I need to get the temporary API key from the composable I just made, <code>useDeepgramKey</code>, to send it in the request to Deepgram; otherwise, Deepgram won’t be able to fulfill the request.</p>
</li>
<li>
<p><code>useMicrophone</code> - I need to get an audio stream from the browser microphone. That audio data will be sent to Deepgram to be transcribed into text that will be put onto the screen as captions.</p>
</li>
</ol>
<p>I haven’t created the <code>useMicrophone</code> composable yet, so I’ll make a quick detour right now to write that composable.</p>
<h3 id="usemicrophone-composable">useMicrophone Composable</h3>
<p>The <code>useMicrophone</code> composable will rely on the browser Media Stream API and the <code>getUserMedia</code> method to request permission to use the browser microphone of the user and pull the audio from it. Since there are several other blog posts in <a href="https://developers.deepgram.com/">Deepgram Docs</a> about this nifty API, I won’t go into detail about how it works. Check out <a href="https://blog.deepgram.com/getting-started-with-mediastream-api/">Brian’s post</a> for a general introduction to it.</p>
<p>This composable is also going to use an <code>async</code> function since the <code>getUserMedia</code> method requires waiting for the user to give permission to use the microphone. The time involved means that this method returns a promise. I already know how to write this type of composable since I just did it in the last section.</p>
<p>I’ll make the composable an <code>async</code> function and I’ll also write the logic to get the audio stream as an <code>async</code> function. Here is the composable in its entirety:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getAudio</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">try</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">mediaStream</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> navigator.mediaDevices.</span><span style="color: #D2A8FF">getUserMedia</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">      audio: </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    })</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">mediaRecorder</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">MediaRecorder</span><span style="color: #C9D1D9">(mediaStream, {</span></span>
<span class="line"><span style="color: #C9D1D9">      audio: </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    })</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> mediaRecorder</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">catch</span><span style="color: #C9D1D9"> (e) {</span></span>
<span class="line"><span style="color: #C9D1D9">    console.</span><span style="color: #D2A8FF">error</span><span style="color: #C9D1D9">(e)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">async</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">microphone</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">getAudio</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { microphone }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>Now it’s ready for me to use in the next composable I will write.</p>
<h3 id="usedeepgramsocket-composable">useDeepgramSocket Composable</h3>
<p>First, I’ll import this composable into <code>AudioCaptions.vue</code> and call it. That way, everything I write in <code>useDeepgramSocket</code> will run and I can check my progress as I build this composable.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">import useDeepgramKey from &quot;@/composables/useDeepgramKey&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">import useDeepgramSocket from &quot;@/composables/useDeepgramSocket&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FFA657">deepgramStatus</span><span style="color: #C9D1D9">.</span><span style="color: #FFA657">value</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> res.DGStatus.value;</span></span>
<span class="line"><span style="color: #C9D1D9">    });</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// call this so the composable runs as I work on it</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #C9D1D9">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>I know I need to have access to the temporary API key from <code>useDeepgramToken</code> and to the microphone from <code>useMicrophone</code>. <strong>I will start by setting up my composable to show that I have access to them within the same scope.</strong></p>
<p>Both composables return a promise. That means I will need to use syntax that will make the functions run but wait for the promise to resolve before moving on to the next thing.</p>
<h3 id="tip-2---use-then-to-chain-each-composable-that-returns-a-promise-to-run-asynchronously-if-returned-values-need-to-be-in-the-same-scope">Tip #2 - Use <code>.then()</code> to chain each composable that returns a promise to run asynchronously if returned values need to be in the same scope</h3>
<p>Here’s what I mean:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useDeepgramKey </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;./useDeepgramKey&#39;</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useMicrophone </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;./useMicrophone&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// chain .then() methods for each composable:</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">keyRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">microphoneRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> apiKey </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> keyRes.key.value</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> microphone </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> microphoneRes.microphone</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(apiKey)</span></span>
<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(microphone)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// WEBSOCKET FUNCTION WILL GO HERE</span></span>
<span class="line"><span style="color: #C9D1D9">    })</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {}</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>I have named the result argument in each <code>.then()</code> a name that shows which composable they came from - <code>keyRes</code> and <code>microphoneRes</code>, which makes it easy for me to see what each of them represents. The <code>keyRes</code> is a <code>ref</code>, so I must drill all the way down to the <code>.value</code> property. The <code>microphoneRes</code> is a Vue 3 <code>readonly</code> property, which is why I don’t have to drill down as far.</p>
<p>Now that I have the values, I can write a function that encapsulates the logic to open the WebSocket.</p>
<h3 id="opendeepgramsocket-function">openDeepgramSocket Function</h3>
<p>I will write a function called <code>openDeepgramSocket</code> that will do the following:</p>
<ul>
<li>Create the socket with <code>new WebSocket(URL, deepgram protocols)</code>.</li>
<li>Open the socket with <code>socket.onopen</code>. When it opens, I’ll add an event listener to the microphone to take in the audio stream and send it through the socket.</li>
<li>Have <code>socket.onclose</code> listen for when the channel closes.</li>
</ul>
<p>I will also create a reactive reference called <code>DGStatus_socket</code> to update the status of the transcription along the way. That value will be returned to the <code>AudioCaptions.vue</code> component as the text captions.</p>
<p>Here is the function:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">apiKey</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">microphone</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">socket</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">WebSocket</span><span style="color: #C9D1D9">(</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #A5D6FF">&#39;wss://api.deepgram.com/v1/listen?punctuate=true&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    [</span><span style="color: #A5D6FF">&#39;token&#39;</span><span style="color: #C9D1D9">, apiKey]</span></span>
<span class="line"><span style="color: #C9D1D9">  )</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  socket.</span><span style="color: #D2A8FF">onopen</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (microphone.state </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;recording&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">      DGStatus_socket.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Connected to Deepgram&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Connection opened.&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">      microphone.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;dataavailable&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">event</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (event.data.size </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> socket.readyState </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">          socket.</span><span style="color: #D2A8FF">send</span><span style="color: #C9D1D9">(event.data)</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">      })</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">      microphone.</span><span style="color: #D2A8FF">start</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  socket.</span><span style="color: #D2A8FF">onmessage</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">message</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">received</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">JSON</span><span style="color: #C9D1D9">.</span><span style="color: #D2A8FF">parse</span><span style="color: #C9D1D9">(message.data)</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">transcript</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> received.channel.alternatives[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">].transcript</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (transcript </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> received.is_final) {</span></span>
<span class="line"><span style="color: #C9D1D9">      DGStatus_socket.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// shows the transcript in the console:</span></span>
<span class="line"><span style="color: #C9D1D9">      console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(DGStatus_socket.value)</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  socket.</span><span style="color: #D2A8FF">onclose</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Connection closed.&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>I have to make sure to call the function in the composable:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">keyRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">microphoneRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> apiKey </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> keyRes.key.value</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> microphone </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> microphoneRes.microphone</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// Call function:</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(apiKey, microphone)</span></span>
<span class="line"><span style="color: #C9D1D9">    })</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {}</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>Now I see the transcript coming back to me because I have added a console.log to show it:</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/transcript_console.png" alt="transcript returned in console with messages"></p>
<p>I’m ready to put that transcript onto the screen as the captions!</p>
<h3 id="vue-watch-to-update-transcript-status">Vue watch to Update Transcript Status</h3>
<p>I will use the reactive reference <code>DGStatus_socket</code> in the composable <code>useDeepgramSocket</code> to update the captions in <code>AudioCaptions.vue</code>. To do that, I need to return it from the composable and then destructure it in the component <code>AudioCaptions.vue</code>.</p>
<p>Here is the <code>useDeepgramSocket</code> composable where I return the <code>DGStatus_socket</code> value (excluding the large <code>openDeepgramSocket</code> function):</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;vue&quot;</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useDeepgramKey </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;./useDeepgramKey&quot;</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useMicrophone </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;./useMicrophone&quot;</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// create status ref</span></span>
<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> DGStatus_socket </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;&quot;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">apiKey</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">microphone</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #FF7B72">...</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">keyRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useMicrophone</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">microphoneRes</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> apiKey </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> keyRes.key.value;</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> microphone </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> microphoneRes.microphone;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">openDeepgramSocket</span><span style="color: #C9D1D9">(apiKey, microphone);</span></span>
<span class="line"><span style="color: #C9D1D9">    });</span></span>
<span class="line"><span style="color: #C9D1D9">  });</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// return status ref to component</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { DGStatus_socket };</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>In <code>AudioCaptions.vue</code>, I destructure the <code>DGStatus_socket</code> so I have access to it:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">DGStatus_socket</span><span style="color: #C9D1D9"> } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #C9D1D9">()</span></span></code></pre>
<p>Is it working? Not yet. I have to update the <code>deepgramStatus</code> ref that is connected to the template if I want to see those captions on the screen.</p>
<h3 id="tip-3-use-watch-to-update-a-value-in-the-component-and-trigger-a-side-effect-in-sync-with-that-change">Tip #3: Use watch to update a value in the component and trigger a side effect in-sync with that change</h3>
<p>According to the Vue documentation, <code>watch</code> is used in “cases where we need to perform ‘side effects’ in reaction to state changes - for example, mutating the DOM or changing another piece of state based on the result of an async operation.”</p>
<p>This example of putting the captions on the screen fits that description exactly. I want the <code>deepgramStatus</code> value to update if <code>DGStatus_socket</code> from the composable <code>useDeepgramSocket</code> changes, and I want that state change to trigger the effect of the text updating in the DOM.</p>
<p>I will add a watcher to the <code>AudioCaptions</code> component:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(DGStatus_socket, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  deepgramStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> DGStatus_socket.value</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>And this is what the component in its entirety looks like now:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9">{ deepgramStatus }</span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref, watch </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">import useDeepgramKey from &quot;@/composables/useDeepgramKey&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">import useDeepgramSocket from &quot;@/composables/useDeepgramSocket&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    let deepgramStatus </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Deepgram Not Connected&quot;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useDeepgramKey</span><span style="color: #C9D1D9">().</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FFA657">deepgramStatus</span><span style="color: #C9D1D9">.</span><span style="color: #FFA657">value</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> res.DGStatus.value;</span></span>
<span class="line"><span style="color: #C9D1D9">    });</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    const { DGStatus_socket } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useDeepgramSocket</span><span style="color: #C9D1D9">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(DGStatus_socket, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      deepgramStatus.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> DGStatus_socket.value;</span></span>
<span class="line"><span style="color: #C9D1D9">    });</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    return { deepgramStatus };</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"></span></code></pre>
<p>And with that, I have my captions powered by Deepgram! Check out the code for this post on my repo branch <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/deepgram-composables">deepgram-composables</a>.</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/captions.gif" alt="Captions working"></p>
<h2 id="conclusion">Conclusion</h2>
<p>Today I built the final component of my project, a full-stack video streaming application with text captions.</p>
<p>This post contained the barebones logic for the captions feature, but in my actual project, I have added styling to improve the user experience, and I’ve added buttons to turn the captions on or off. Check out the repo <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram">here</a>.</p>
<p>Here is the final project:</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1648829348/blog/2022/03/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/VideoExample.gif" alt="Final project demo"></p>
<p>It’s been a great experience learning about Amazon IVS and Deepgram, and I’ve gotten the chance to get a better taste of how to take advantage Vue 3’s composition API.</p>
<p>If you enjoyed this series, please follow me on <a href="https://twitter.com/sandra_rodgers_">Twitter</a> to receive updates on future series I have in the works!</p>`;
}, "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/index.md");

export { compiledContent, $$Index as default, frontmatter, metadata, rawContent };
