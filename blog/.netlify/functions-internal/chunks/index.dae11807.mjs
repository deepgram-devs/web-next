import { c as createAstro, a as createComponent, r as renderTemplate, b as renderHead } from '../entry.mjs';
import Slugger from 'github-slugger';
import '@astrojs/netlify/netlify-functions.js';
import 'preact';
import 'preact-render-to-string';
import 'vue';
import 'vue/server-renderer';
import 'html-escaper';
import 'node-html-parser';
/* empty css                           */import 'axios';
/* empty css                          *//* empty css                           *//* empty css                          *//* empty css                              *//* empty css                              */import 'clone-deep';
import 'slugify';
import 'shiki';
/* empty css                           *//* empty css                              */import '@astrojs/rss';
/* empty css                           */import 'mime';
import 'cookie';
import 'kleur/colors';
import 'string-width';
import 'path-browserify';
import 'path-to-regexp';

const metadata = { "headings": [{ "depth": 2, "slug": "what-is-reactivity", "text": "What is reactivity?" }, { "depth": 3, "slug": "reactivity-in-vue-2", "text": "Reactivity in Vue 2" }, { "depth": 3, "slug": "reactivity-in-vue-3", "text": "Reactivity in Vue 3" }, { "depth": 2, "slug": "how-to-make-data-properties-reactive", "text": "How to make data properties reactive" }, { "depth": 3, "slug": "ref", "text": "ref" }, { "depth": 3, "slug": "reactive", "text": "reactive" }, { "depth": 3, "slug": "torefs", "text": "toRefs" }, { "depth": 3, "slug": "toref", "text": "toRef" }, { "depth": 3, "slug": "isref", "text": "isRef" }, { "depth": 2, "slug": "my-thoughts-on-the-vue-3-reactivity-api", "text": "My Thoughts on the Vue 3 Reactivity API" }, { "depth": 2, "slug": "conclusion", "text": "Conclusion" }], "source": "\nThis is the fourth post in my 'Diving Into Vue 3' series. Today I hope to give a clear and practical description of how to use the new Reactivity APIs, focusing on `ref` and `reactive`. I'll also introduce how to use related helpers such as `toRef`, `toRefs`, and `isRef`.\n\nThe other posts in this series that have already come out are:\n\n*   [Diving Into Vue 3 - Getting Started](https://blog.deepgram.com/diving-into-vue-3-getting-started/)\n*   [Diving Into Vue 3 - The Setup Function](https://blog.deepgram.com/diving-into-vue-3-setup-function/)\n*   [Diving Into Vue 3: Methods, Watch, and Computed](https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/)\n\nBut first, a little background on **reactivity**. Feel free to skip ahead to the section on [how to make data properties reactive](#how-to-make-data-properties-reactive) if you just want to learn about `ref` and `reactive`.\n\n## What is reactivity?\n\nThe term **reactivity** in relation to Vue generally refers to a feature where what you see on the screen automatically updates in-sync with any changes to the state. It's the Vue 'magic' that makes the template re-render instantly if a data property changes.\n\nWhen talking about **reactivity** in JavaScript or in programming in general, the term means programming something to work the way Vue does by implementing a design pattern called the **Observer Pattern**, which is explained in [Design Patterns for Humans](https://github.com/sohamkamani/javascript-design-patterns-for-humans#-observer) as :\n\n> whenever an object changes its state, all its dependents are notified.\n\nVue automatically updating the DOM when a data property changes is a result of Vue being built using the **Observer Pattern** - Vue state is an object with properties that have dependencies, so if one of those properties changes, its dependents react to the change by updating if they need to, and that triggers the re-render in the browser.\n\nJavaScript on its own is not reactive, as shown in this example:\n\n```js\nlet numWorkers = 50\nlet numManagers = 4\nlet totalEmployees = numWorkers + numManagers\n\nconsole.log(totalEmployees) // 54\n\nnumWorkers = 48\n\nconsole.log(totalEmployees) // Still 54\n```\n\nVue is reactive because the core Vue.js team built it to be. So in the following example, `totalEmployees` will automatically update anytime `numWorkers` or `numManagers` (two properties in the state object) changes:\n\n```js\n  data() {\n    //returns the state object\n    return { numWorkers: 4, numManagers: 6 }\n  },\n  computed: {\n    totalEmployees() {\n      // returns whatever the total is based on current state for numWorkers and numManagers\n      return this.numWorkers +  this.numManagers\n    }\n  }\n```\n\n### Reactivity in Vue 2\n\nThe reactivity system in both Vue 2 and Vue 3 is based on state being an object, but there are big differences in how the properties are made reactive.\n\nIn Vue 2 the data option returns an object:\n\n```js\n  data() {\n    return {\n      numWorkers: 4,\n      numManagers: 6\n    }\n  }\n```\n\nUnder the hood, Vue 2 uses `Object.defineProperty` to define all the data properties on a component instance, converting them to getters and setters. There's a deep dive into the Vue 2's reactivity system in the [Vue.js docs](https://v2.vuejs.org/v2/guide/reactivity.html) that's worth spending some time with.\n\nBecause defining the properties happens at the time of the component instance's initialization, it results in some small drawbacks:\n\n*   data properties cannot be added or deleted after component instance initialization. They have to be present during initialization for them to be reactive\n\n*   If the data property is an array, it is not possible to set an item directly to the array through assignment by using the array index (as in `arr[0] = value`), and it also isn't possible to update the length of the array (as in `arr.length = 0`)\n\nThis isn't a *major* problem because the `Vue.$set` method can be used in cases where these updates need to be made after component instance initialization. However, Vue 3's reactivity system is so improved that now these issues are no longer a problem, making it unnecessary to use `Vue.$set`.\n\n### Reactivity in Vue 3\n\nVue 3's reactivity system had a major rewrite from what it was in Vue 2. The fundamental idea of tracking all the data properties and their dependencies so they can update automatically is still the same, but Vue 3 now uses the JavaScript [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) API to achieve this (instead of `Object.defineProperty` like in Vue 2).\n\nThere's a rabbit hole to go down for anyone who wants to learn more about the Vue 3 reactivity system, and the [Vue.js docs](https://v3.vuejs.org/guide/reactivity.html#how-vue-tracks-these-changes) are fantastic. Even though I'm not going to explain it all (there's no way I could!), there are a few things I think are helpful to understand.\n\nThe docs state:\n\n> Proxy is an object that encases another object and allows you to intercept any interactions with that object.\n\nAwareness of reactive properties using proxies is helpful when debugging code in the console. If I `console.log` a reactive property such as this property `company`:\n\n```js\nconst company = reactive({\n  employees: ['Tom', 'Sara', 'Joe'],\n  managers: ['Julie', 'Jorge'],\n})\n```\n\nin the console, I see:\n\n![A console.log for a reactive property which shows the proxy](https://res.cloudinary.com/deepgram/image/upload/v1644436537/blog/2022/02/diving-into-vue-3-reactivity-api/console_1.png)\n\nClicking on it will open the object to show that there is a Handler and a Target. A proxy always contains a Handler and a Target, and since Vue 3 uses proxies, I find it helpful to be comfortable with the shape of this data as a proxy.\n\n![Same console.log for a reactive property which shows the proxy, now open to show handler and target](https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_2.png)\n\nThe Target is where to look for the actual values. It contains the data that I might be looking for. The Handler contains the special logic for making the data properties reactive. The Handler contains methods like `get` and `set`.\n\nThe Handler is the rabbit hole if you want to learn about reactivity. The Target is where I need to look for my data values.\n\n![Same console.log for a reactive property which shows the proxy, now open to show handler and target with target open to show data values](https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_3.png)\n\nBecause reactive data is wrapped in a proxy, something to get used to when working with the data is the idea of having to 'unwrap' the data object to get to the value. After reading a lot of different resources about working with Vue 3 reactive data, I now feel comfortable with the idea that using strategies to 'unwrap' the data, such as destructuring or drilling down to the value property, are using the metaphor of unwrapping because Vue 3 reactive data is wrapped in a `Proxy` object.\n\n## How to make data properties reactive\n\nAs I said earlier, if I want to make data properties reactive in Vue 2, I have to return them in an object inside the data option of the Options API.\n\n```js\n  data() {\n    return {\n      president: \"Mickey Mouse\",\n      vicePresident: \"Donald Duck\"\n    }\n  }\n```\n\nIf I am using the Vue 3 setup function (see my [post on the setup function](https://blog.deepgram.com/diving-into-vue-3-setup-function/) if you need an explainer on that), I can make data reactive by using the `reactive` or `ref` helpers.\n\n### ref\n\nFor this first example, I will use `ref`. I'm using `ref` because `\"Mickey Mouse\"` and `\"Donald Duck\"` are strings, and the recommendation is to use `ref` with primitive values (i.e. Javascript types that are not objects, such as strings, numbers, etc.)\n\nFirst, I import `ref`:\n\n```js\n<script>import { ref } from \"vue\";<\/script>\n```\n\nThen in the `setup` function, I set my variable to the `ref()` helper, which takes in the initial value. I must include the data in the return object if I want it to be available to the template.\n\n```js\n  setup() {\n    let president = ref(\"Mickey Mouse\");\n    let vicePresident = ref(\"Donald Duck\");\n\n    return { president, vicePresident };\n    },\n```\n\nAn important difference between `ref` and `reactive` is that if I want to do something to the value of my `ref` properties inside the `setup` function, I have to unwrap the object to access that value. So if I want to change the value of `president`, I will change `president.value`:\n\n```js\n  function changePresident() {\n    president.value = 'Goofy'\n  }\n```\n\nI don't have to worry about unwrapping the values for `president` and `vicePresident` in the `template`. Vue can shallow unwrap those for me. 'Shallow unwrap' means the first level of properties in an object are available in the template without having to use `.value` (but nested properties would still need to be unwrapped).\n\n```html\n<template>\n  <div>\n    <p><b>President:</b> {{ president }}</p>\n    <p><b>Vice President:</b> {{ vicePresident }}</p>\n  </div>\n</template>\n```\n\nFYI, it's fine not to use `ref` if I don't need the data to be reactive, just writing the data like this:\n\n```js\nsetup() {\n  let president = \"Mickey Mouse\"\n  let vicePresident = \"Donald Duck\"\n\n  return { president, vicePresident };\n},\n```\n\nBut it would mean the data isn't reactive, so I can't ever see updates to the data. If I use a method to change the data, I would never see that update change anything on the screen, and I would have to be happy with Mickey Mouse and Donald Duck showing as president and vice president forever.\n\nThere are times when you don't need the data to be reactive, so in those instances, just don't use `ref` or `reactive`!\n\n### reactive\n\nI can use `reactive` for the same example, but I would only do so if I wanted the data to start out in the form of an object rather than separate string values. So in Vue 2, if I have this:\n\n```js\ndata() {\n  return {\n    executiveTeam: {\n      president: \"Mickey Mouse\",\n      vicePresident: \"Donald Duck\",\n    },\n  };\n},\n```\n\nTo change this to Vue 3 using `reactive`, I will first import `reactive`:\n\n```js\nimport { reactive } from 'vue'\n```\n\nIn the `setup` function, I will create an object for `executiveTeam` and define the properties on the object. I can set the object to `const` since the object itself won't change, just the properties inside.\n\n```js\nsetup() {\n  const executiveTeam = reactive({\n    president: \"Mickey Mouse\",\n    vicePresident: \"Donald Duck\",\n  });\n\n  return { executiveTeam };\n},\n```\n\nAnd if I want to update the data, I do not have to unwrap it with `.value `like I do with `ref`.\n\n```js\nfunction changePresident() {\n  executiveTeam.president = 'Goofy'\n}\n```\n\nThis is because `reactive` is used with objects, and objects pass values by *reference* (which lends itself better to reactivity). Reactive references (`ref`) are used for primitive types, and primitives in Javascript pass values by *value*, so Vue has to wrap them in an object to make them reactive. Since `ref` properties are wrapped to make them reactive, they have to be unwrapped down to the `.value` to get the value. Read more about this concept in the  [Composition API RFC](https://github.com/vuejs/composition-api-rfc/blob/master/index.md#computed-state-and-refs) if this concept is something you want to understand more deeply.\n\nHowever, because I'm returning the object `executiveTeam` and I want to access the properties `president` and `vicePresident` on that object in the template, I will have to drill down into the `executiveTeam` object to get each property I need:\n\n```html\n<template>\n  <div>\n    <p><b>President:</b> {{ executiveTeam.president }}</p>\n    <p><b>Vice President:</b> {{ executiveTeam.vicePresident }}</p>\n  </div>\n</template>\n```\n\nI cannot destructure the object that I return because if I do, the properties inside `executiveTeam` will lose reactivity. I'll demonstrate this in the next example to make this more clear.\n\nWhen using `reactive` to give an object's properties reactivity, like this:\n\n```js\nconst executiveTeam = reactive({\n  president: 'Mickey Mouse',\n  vicePresident: 'Donald Duck',\n})\n```\n\nI cannot destructure to try and return those properties by their key, as in:\n\n```js\n//LOSES REACTIVITY:\nlet { president, vicePresident } = executiveTeam\n\nreturn { president, vicePresident }\n```\n\nThis is where `toRefs` comes in handy.\n\n### toRefs\n\nThe helper `toRefs` will allow me to turn each of the properties in the object into a `ref`, which means I won't have to use `executiveTeam.president` in the template; I'll be able to just write `president`. Here's the full example now using `toRefs`:\n\n```js\n<script>\nimport { reactive, toRefs } from \"vue\";\nexport default {\n  setup() {\n    const executiveTeam = reactive({\n      president: \"Mickey Mouse\",\n      vicePresident: \"Donald Duck\",\n    });\n\n    //toRefs allows me to destructure\n    let { president, vicePresident } = toRefs(executiveTeam);\n\n    return { president, vicePresident };\n  },\n};\n<\/script>\n\n```\n\nSince `toRefs` turns each property into a `ref`, I need to go back to unwrapping them down to their value using `.value `if I want to do something to them in the `setup` function:\n\n```js\nfunction changePresident() {\n  president.value = 'Goofy'\n}\n```\n\n### toRef\n\nJust like `toRefs`, the helper `toRef` is used to turn reactive object properties into reactive references (`ref`), but I would use `toRef` if I just need to turn one property in a reactive object into a `ref`:\n\n```js\nsetup() {\n  const executiveTeam = reactive({\n    president: \"Mickey Mouse\",\n    vicePresident: \"Donald Duck\",\n  });\n  //toRef used to turn just one property into a ref\n  let presidentRef = toRef(executiveTeam, \"president\");\n\n  const changePresident = () => {\n    presidentRef.value = \"Goofy\";\n  };\n\n  return { presidentRef, changePresident };\n},\n```\n\nI will have to use `.value` if I want to update the ref's value inside the setup function, but in the template, Vue will unwrap `president` for me:\n\n```html\n<template>\n  <div>\n    <h1>Company Roles</h1>\n    <p><b>President:</b> {{ presidentRef }}</p>\n    <button @click=\"changePresident\">Change President</button>\n  </div>\n</template>\n```\n\nIt can be challenging to remember which variables are `reactive` properties and which ones are `ref`. Something that helps is to use a naming convention where I add the suffix **Ref** to anything that is a `ref`, such as `presidentRef`. I don't have a lot of experience with Vue 3 yet, but for the time being, I plan to use that naming convention to see if it helps me get a better handle on the distinction between `ref` and `reactive` properties.\n\n### isRef\n\nVue 3 also provides the helper `isRef` that I can use to check if something is a `ref`.\n\n```js\nconsole.log(isRef(executiveTeam.president)) //false\nconsole.log(isRef(presidentRef)) //true\n```\n\n## My Thoughts on the Vue 3 Reactivity API\n\nThis topic of `ref` and `reactive` has been the most challenging for me in my goal to learn Vue 3. There is more nuance to how these helpers are used in practice, and it becomes too much for an introduction post to try to cover all the different situations where I might have to make informed decisions about using `ref` and/or `reactive` and all the other helpers.\n\nThe Vue.js team is aware that this is one of the challenges of Vue 3 - the question of when to use `ref` or `reactive` does not always receive a simple answer. In the Composition API RFC they state:\n\n> Understandably, users may get confused regarding which to use between ref and reactive. First thing to know is that you will need to understand both to efficiently make use of the Composition API. Using one exclusively will most likely lead to esoteric workarounds or reinvented wheels.\n\nI have come across many resources that suggest using just `ref` or just `reactive` to start. But I think it is worth the effort to learn the nuances of both. I agree with the Vue.js team: it's better to understand both `ref` and `reactive` if I'm going to use Vue 3 to its fullest potential. And that's what I plan to do.\n\nWhile using just `ref` for primitives and `reactive` for objects is one suggested approach (suggested by the Vue.js team [here](https://github.com/vuejs/composition-api-rfc/blob/master/index.md#ref-vs-reactive)), I would encourage you to dig deeper into the docs and resources out there to learn more about the Reactivity APIs. For a nuanced feature such as this, it's important to understand why certain approaches can be taken.\n\n## Conclusion\n\nPlease join me for my next post about reusability in Vue 3, including a discussion of composition functions (i.e. Vue composables). In my opinion, composables are the best thing about this new Composition API and they make it worth putting in the time to learn the harder concepts of Vue 3.\n\nPlease reach out on [Twitter](https://twitter.com/sandra_rodgers_) and let me know if you are enjoying this series on Vue 3.\n\n        ", "html": '<p>This is the fourth post in my \u2018Diving Into Vue 3\u2019 series. Today I hope to give a clear and practical description of how to use the new Reactivity APIs, focusing on <code is:raw>ref</code> and <code is:raw>reactive</code>. I\u2019ll also introduce how to use related helpers such as <code is:raw>toRef</code>, <code is:raw>toRefs</code>, and <code is:raw>isRef</code>.</p>\n<p>The other posts in this series that have already come out are:</p>\n<ul>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3 - Getting Started</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-setup-function/">Diving Into Vue 3 - The Setup Function</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/">Diving Into Vue 3: Methods, Watch, and Computed</a></li>\n</ul>\n<p>But first, a little background on <strong>reactivity</strong>. Feel free to skip ahead to the section on <a href="#how-to-make-data-properties-reactive">how to make data properties reactive</a> if you just want to learn about <code is:raw>ref</code> and <code is:raw>reactive</code>.</p>\n<h2 id="what-is-reactivity">What is reactivity?</h2>\n<p>The term <strong>reactivity</strong> in relation to Vue generally refers to a feature where what you see on the screen automatically updates in-sync with any changes to the state. It\u2019s the Vue \u2018magic\u2019 that makes the template re-render instantly if a data property changes.</p>\n<p>When talking about <strong>reactivity</strong> in JavaScript or in programming in general, the term means programming something to work the way Vue does by implementing a design pattern called the <strong>Observer Pattern</strong>, which is explained in <a href="https://github.com/sohamkamani/javascript-design-patterns-for-humans#-observer">Design Patterns for Humans</a> as :</p>\n<blockquote>\n<p>whenever an object changes its state, all its dependents are notified.</p>\n</blockquote>\n<p>Vue automatically updating the DOM when a data property changes is a result of Vue being built using the <strong>Observer Pattern</strong> - Vue state is an object with properties that have dependencies, so if one of those properties changes, its dependents react to the change by updating if they need to, and that triggers the re-render in the browser.</p>\n<p>JavaScript on its own is not reactive, as shown in this example:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> numWorkers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">50</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> numManagers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">4</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> totalEmployees </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> numWorkers </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> numManagers</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(totalEmployees) </span><span style="color: #8B949E">// 54</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">numWorkers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">48</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(totalEmployees) </span><span style="color: #8B949E">// Still 54</span></span></code></pre>\n<p>Vue is reactive because the core Vue.js team built it to be. So in the following example, <code is:raw>totalEmployees</code> will automatically update anytime <code is:raw>numWorkers</code> or <code is:raw>numManagers</code> (two properties in the state object) changes:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//returns the state object</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { numWorkers: </span><span style="color: #79C0FF">4</span><span style="color: #C9D1D9">, numManagers: </span><span style="color: #79C0FF">6</span><span style="color: #C9D1D9"> }</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FFA657">computed</span><span style="color: #C9D1D9">: {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">totalEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// returns whatever the total is based on current state for numWorkers and numManagers</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numWorkers </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9">  </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numManagers</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>\n<h3 id="reactivity-in-vue-2">Reactivity in Vue 2</h3>\n<p>The reactivity system in both Vue 2 and Vue 3 is based on state being an object, but there are big differences in how the properties are made reactive.</p>\n<p>In Vue 2 the data option returns an object:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      numWorkers: </span><span style="color: #79C0FF">4</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">      numManagers: </span><span style="color: #79C0FF">6</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>\n<p>Under the hood, Vue 2 uses <code is:raw>Object.defineProperty</code> to define all the data properties on a component instance, converting them to getters and setters. There\u2019s a deep dive into the Vue 2\u2019s reactivity system in the <a href="https://v2.vuejs.org/v2/guide/reactivity.html">Vue.js docs</a> that\u2019s worth spending some time with.</p>\n<p>Because defining the properties happens at the time of the component instance\u2019s initialization, it results in some small drawbacks:</p>\n<ul>\n<li>\n<p>data properties cannot be added or deleted after component instance initialization. They have to be present during initialization for them to be reactive</p>\n</li>\n<li>\n<p>If the data property is an array, it is not possible to set an item directly to the array through assignment by using the array index (as in <code is:raw>arr[0] = value</code>), and it also isn\u2019t possible to update the length of the array (as in <code is:raw>arr.length = 0</code>)</p>\n</li>\n</ul>\n<p>This isn\u2019t a <em>major</em> problem because the <code is:raw>Vue.$set</code> method can be used in cases where these updates need to be made after component instance initialization. However, Vue 3\u2019s reactivity system is so improved that now these issues are no longer a problem, making it unnecessary to use <code is:raw>Vue.$set</code>.</p>\n<h3 id="reactivity-in-vue-3">Reactivity in Vue 3</h3>\n<p>Vue 3\u2019s reactivity system had a major rewrite from what it was in Vue 2. The fundamental idea of tracking all the data properties and their dependencies so they can update automatically is still the same, but Vue 3 now uses the JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> API to achieve this (instead of <code is:raw>Object.defineProperty</code> like in Vue 2).</p>\n<p>There\u2019s a rabbit hole to go down for anyone who wants to learn more about the Vue 3 reactivity system, and the <a href="https://v3.vuejs.org/guide/reactivity.html#how-vue-tracks-these-changes">Vue.js docs</a> are fantastic. Even though I\u2019m not going to explain it all (there\u2019s no way I could!), there are a few things I think are helpful to understand.</p>\n<p>The docs state:</p>\n<blockquote>\n<p>Proxy is an object that encases another object and allows you to intercept any interactions with that object.</p>\n</blockquote>\n<p>Awareness of reactive properties using proxies is helpful when debugging code in the console. If I <code is:raw>console.log</code> a reactive property such as this property <code is:raw>company</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">company</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">  employees: [</span><span style="color: #A5D6FF">&#39;Tom&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;Sara&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;Joe&#39;</span><span style="color: #C9D1D9">],</span></span>\n<span class="line"><span style="color: #C9D1D9">  managers: [</span><span style="color: #A5D6FF">&#39;Julie&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;Jorge&#39;</span><span style="color: #C9D1D9">],</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>in the console, I see:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1644436537/blog/2022/02/diving-into-vue-3-reactivity-api/console_1.png" alt="A console.log for a reactive property which shows the proxy"></p>\n<p>Clicking on it will open the object to show that there is a Handler and a Target. A proxy always contains a Handler and a Target, and since Vue 3 uses proxies, I find it helpful to be comfortable with the shape of this data as a proxy.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_2.png" alt="Same console.log for a reactive property which shows the proxy, now open to show handler and target"></p>\n<p>The Target is where to look for the actual values. It contains the data that I might be looking for. The Handler contains the special logic for making the data properties reactive. The Handler contains methods like <code is:raw>get</code> and <code is:raw>set</code>.</p>\n<p>The Handler is the rabbit hole if you want to learn about reactivity. The Target is where I need to look for my data values.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_3.png" alt="Same console.log for a reactive property which shows the proxy, now open to show handler and target with target open to show data values"></p>\n<p>Because reactive data is wrapped in a proxy, something to get used to when working with the data is the idea of having to \u2018unwrap\u2019 the data object to get to the value. After reading a lot of different resources about working with Vue 3 reactive data, I now feel comfortable with the idea that using strategies to \u2018unwrap\u2019 the data, such as destructuring or drilling down to the value property, are using the metaphor of unwrapping because Vue 3 reactive data is wrapped in a <code is:raw>Proxy</code> object.</p>\n<h2 id="how-to-make-data-properties-reactive">How to make data properties reactive</h2>\n<p>As I said earlier, if I want to make data properties reactive in Vue 2, I have to return them in an object inside the data option of the Options API.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">      vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>\n<p>If I am using the Vue 3 setup function (see my <a href="https://blog.deepgram.com/diving-into-vue-3-setup-function/">post on the setup function</a> if you need an explainer on that), I can make data reactive by using the <code is:raw>reactive</code> or <code is:raw>ref</code> helpers.</p>\n<h3 id="ref">ref</h3>\n<p>For this first example, I will use <code is:raw>ref</code>. I\u2019m using <code is:raw>ref</code> because <code is:raw>"Mickey Mouse"</code> and <code is:raw>"Donald Duck"</code> are strings, and the recommendation is to use <code is:raw>ref</code> with primitive values (i.e. Javascript types that are not objects, such as strings, numbers, etc.)</p>\n<p>First, I import <code is:raw>ref</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>Then in the <code is:raw>setup</code> function, I set my variable to the <code is:raw>ref()</code> helper, which takes in the initial value. I must include the data in the return object if I want it to be available to the template.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> president </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> vicePresident </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { president, vicePresident };</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span></code></pre>\n<p>An important difference between <code is:raw>ref</code> and <code is:raw>reactive</code> is that if I want to do something to the value of my <code is:raw>ref</code> properties inside the <code is:raw>setup</code> function, I have to unwrap the object to access that value. So if I want to change the value of <code is:raw>president</code>, I will change <code is:raw>president.value</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    president.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Goofy&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>\n<p>I don\u2019t have to worry about unwrapping the values for <code is:raw>president</code> and <code is:raw>vicePresident</code> in the <code is:raw>template</code>. Vue can shallow unwrap those for me. \u2018Shallow unwrap\u2019 means the first level of properties in an object are available in the template without having to use <code is:raw>.value</code> (but nested properties would still need to be unwrapped).</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ president }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;Vice President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ vicePresident }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>FYI, it\u2019s fine not to use <code is:raw>ref</code> if I don\u2019t need the data to be reactive, just writing the data like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> president </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> vicePresident </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { president, vicePresident };</span></span>\n<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>\n<p>But it would mean the data isn\u2019t reactive, so I can\u2019t ever see updates to the data. If I use a method to change the data, I would never see that update change anything on the screen, and I would have to be happy with Mickey Mouse and Donald Duck showing as president and vice president forever.</p>\n<p>There are times when you don\u2019t need the data to be reactive, so in those instances, just don\u2019t use <code is:raw>ref</code> or <code is:raw>reactive</code>!</p>\n<h3 id="reactive">reactive</h3>\n<p>I can use <code is:raw>reactive</code> for the same example, but I would only do so if I wanted the data to start out in the form of an object rather than separate string values. So in Vue 2, if I have this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    executiveTeam: {</span></span>\n<span class="line"><span style="color: #C9D1D9">      president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">      vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span>\n<span class="line"><span style="color: #C9D1D9">  };</span></span>\n<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>\n<p>To change this to Vue 3 using <code is:raw>reactive</code>, I will first import <code is:raw>reactive</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { reactive } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span></code></pre>\n<p>In the <code is:raw>setup</code> function, I will create an object for <code is:raw>executiveTeam</code> and define the properties on the object. I can set the object to <code is:raw>const</code> since the object itself won\u2019t change, just the properties inside.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">executiveTeam</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">    president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">  });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { executiveTeam };</span></span>\n<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>\n<p>And if I want to update the data, I do not have to unwrap it with <code is:raw>.value </code>like I do with <code is:raw>ref</code>.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  executiveTeam.president </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Goofy&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>This is because <code is:raw>reactive</code> is used with objects, and objects pass values by <em>reference</em> (which lends itself better to reactivity). Reactive references (<code is:raw>ref</code>) are used for primitive types, and primitives in Javascript pass values by <em>value</em>, so Vue has to wrap them in an object to make them reactive. Since <code is:raw>ref</code> properties are wrapped to make them reactive, they have to be unwrapped down to the <code is:raw>.value</code> to get the value. Read more about this concept in the  <a href="https://github.com/vuejs/composition-api-rfc/blob/master/index.md#computed-state-and-refs">Composition API RFC</a> if this concept is something you want to understand more deeply.</p>\n<p>However, because I\u2019m returning the object <code is:raw>executiveTeam</code> and I want to access the properties <code is:raw>president</code> and <code is:raw>vicePresident</code> on that object in the template, I will have to drill down into the <code is:raw>executiveTeam</code> object to get each property I need:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ executiveTeam.president }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;Vice President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ executiveTeam.vicePresident }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>I cannot destructure the object that I return because if I do, the properties inside <code is:raw>executiveTeam</code> will lose reactivity. I\u2019ll demonstrate this in the next example to make this more clear.</p>\n<p>When using <code is:raw>reactive</code> to give an object\u2019s properties reactivity, like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">executiveTeam</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">  president: </span><span style="color: #A5D6FF">&#39;Mickey Mouse&#39;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">  vicePresident: </span><span style="color: #A5D6FF">&#39;Donald Duck&#39;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>I cannot destructure to try and return those properties by their key, as in:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//LOSES REACTIVITY:</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> { president, vicePresident } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> executiveTeam</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { president, vicePresident }</span></span></code></pre>\n<p>This is where <code is:raw>toRefs</code> comes in handy.</p>\n<h3 id="torefs">toRefs</h3>\n<p>The helper <code is:raw>toRefs</code> will allow me to turn each of the properties in the object into a <code is:raw>ref</code>, which means I won\u2019t have to use <code is:raw>executiveTeam.president</code> in the template; I\u2019ll be able to just write <code is:raw>president</code>. Here\u2019s the full example now using <code is:raw>toRefs</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> reactive, toRefs </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    const executiveTeam </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">      president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">      vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//toRefs allows me to destructure</span></span>\n<span class="line"><span style="color: #C9D1D9">    let { president, vicePresident } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">toRefs</span><span style="color: #C9D1D9">(executiveTeam);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { president, vicePresident };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span></code></pre>\n<p>Since <code is:raw>toRefs</code> turns each property into a <code is:raw>ref</code>, I need to go back to unwrapping them down to their value using <code is:raw>.value </code>if I want to do something to them in the <code is:raw>setup</code> function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  president.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Goofy&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<h3 id="toref">toRef</h3>\n<p>Just like <code is:raw>toRefs</code>, the helper <code is:raw>toRef</code> is used to turn reactive object properties into reactive references (<code is:raw>ref</code>), but I would use <code is:raw>toRef</code> if I just need to turn one property in a reactive object into a <code is:raw>ref</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">executiveTeam</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">    president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">  });</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//toRef used to turn just one property into a ref</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> presidentRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">toRef</span><span style="color: #C9D1D9">(executiveTeam, </span><span style="color: #A5D6FF">&quot;president&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    presidentRef.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;Goofy&quot;</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">  };</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { presidentRef, changePresident };</span></span>\n<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>\n<p>I will have to use <code is:raw>.value</code> if I want to update the ref\u2019s value inside the setup function, but in the template, Vue will unwrap <code is:raw>president</code> for me:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;Company Roles&lt;/</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ presidentRef }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">@click</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;changePresident&quot;</span><span style="color: #C9D1D9">&gt;Change President&lt;/</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>It can be challenging to remember which variables are <code is:raw>reactive</code> properties and which ones are <code is:raw>ref</code>. Something that helps is to use a naming convention where I add the suffix <strong>Ref</strong> to anything that is a <code is:raw>ref</code>, such as <code is:raw>presidentRef</code>. I don\u2019t have a lot of experience with Vue 3 yet, but for the time being, I plan to use that naming convention to see if it helps me get a better handle on the distinction between <code is:raw>ref</code> and <code is:raw>reactive</code> properties.</p>\n<h3 id="isref">isRef</h3>\n<p>Vue 3 also provides the helper <code is:raw>isRef</code> that I can use to check if something is a <code is:raw>ref</code>.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">isRef</span><span style="color: #C9D1D9">(executiveTeam.president)) </span><span style="color: #8B949E">//false</span></span>\n<span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">isRef</span><span style="color: #C9D1D9">(presidentRef)) </span><span style="color: #8B949E">//true</span></span></code></pre>\n<h2 id="my-thoughts-on-the-vue-3-reactivity-api">My Thoughts on the Vue 3 Reactivity API</h2>\n<p>This topic of <code is:raw>ref</code> and <code is:raw>reactive</code> has been the most challenging for me in my goal to learn Vue 3. There is more nuance to how these helpers are used in practice, and it becomes too much for an introduction post to try to cover all the different situations where I might have to make informed decisions about using <code is:raw>ref</code> and/or <code is:raw>reactive</code> and all the other helpers.</p>\n<p>The Vue.js team is aware that this is one of the challenges of Vue 3 - the question of when to use <code is:raw>ref</code> or <code is:raw>reactive</code> does not always receive a simple answer. In the Composition API RFC they state:</p>\n<blockquote>\n<p>Understandably, users may get confused regarding which to use between ref and reactive. First thing to know is that you will need to understand both to efficiently make use of the Composition API. Using one exclusively will most likely lead to esoteric workarounds or reinvented wheels.</p>\n</blockquote>\n<p>I have come across many resources that suggest using just <code is:raw>ref</code> or just <code is:raw>reactive</code> to start. But I think it is worth the effort to learn the nuances of both. I agree with the Vue.js team: it\u2019s better to understand both <code is:raw>ref</code> and <code is:raw>reactive</code> if I\u2019m going to use Vue 3 to its fullest potential. And that\u2019s what I plan to do.</p>\n<p>While using just <code is:raw>ref</code> for primitives and <code is:raw>reactive</code> for objects is one suggested approach (suggested by the Vue.js team <a href="https://github.com/vuejs/composition-api-rfc/blob/master/index.md#ref-vs-reactive">here</a>), I would encourage you to dig deeper into the docs and resources out there to learn more about the Reactivity APIs. For a nuanced feature such as this, it\u2019s important to understand why certain approaches can be taken.</p>\n<h2 id="conclusion">Conclusion</h2>\n<p>Please join me for my next post about reusability in Vue 3, including a discussion of composition functions (i.e. Vue composables). In my opinion, composables are the best thing about this new Composition API and they make it worth putting in the time to learn the harder concepts of Vue 3.</p>\n<p>Please reach out on <a href="https://twitter.com/sandra_rodgers_">Twitter</a> and let me know if you are enjoying this series on Vue 3.</p>' };
const frontmatter = { "title": "Diving Into Vue 3 - The Reactivity API", "description": "Learn about reactivity in Vue 3 and how to use ref and reactive helpers", "date": "2022-02-18T00:00:00.000Z", "cover": "https://res.cloudinary.com/deepgram/image/upload/v1644435060/blog/2022/02/diving-into-vue-3-reactivity-api/dive-into-vue-3%402x.jpg", "authors": ["sandra-rodgers"], "category": "tutorial", "tags": ["vuejs", "javascript"], "seo": { "title": "Diving Into Vue 3 - The Reactivity API", "description": "Learn about reactivity in Vue 3 and how to use ref and reactive helpers" }, "shorturls": { "share": "https://dpgr.am/98e7070", "twitter": "https://dpgr.am/fa58f26", "linkedin": "https://dpgr.am/1ce34ef", "reddit": "https://dpgr.am/571a1b6", "facebook": "https://dpgr.am/3bf430e" }, "og": { "image": "https://res.cloudinary.com/deepgram/image/upload/v1661453991/blog/diving-into-vue-3-reactivity-api/ograph.png" }, "astro": { "headings": [{ "depth": 2, "slug": "what-is-reactivity", "text": "What is reactivity?" }, { "depth": 3, "slug": "reactivity-in-vue-2", "text": "Reactivity in Vue 2" }, { "depth": 3, "slug": "reactivity-in-vue-3", "text": "Reactivity in Vue 3" }, { "depth": 2, "slug": "how-to-make-data-properties-reactive", "text": "How to make data properties reactive" }, { "depth": 3, "slug": "ref", "text": "ref" }, { "depth": 3, "slug": "reactive", "text": "reactive" }, { "depth": 3, "slug": "torefs", "text": "toRefs" }, { "depth": 3, "slug": "toref", "text": "toRef" }, { "depth": 3, "slug": "isref", "text": "isRef" }, { "depth": 2, "slug": "my-thoughts-on-the-vue-3-reactivity-api", "text": "My Thoughts on the Vue 3 Reactivity API" }, { "depth": 2, "slug": "conclusion", "text": "Conclusion" }], "source": "\nThis is the fourth post in my 'Diving Into Vue 3' series. Today I hope to give a clear and practical description of how to use the new Reactivity APIs, focusing on `ref` and `reactive`. I'll also introduce how to use related helpers such as `toRef`, `toRefs`, and `isRef`.\n\nThe other posts in this series that have already come out are:\n\n*   [Diving Into Vue 3 - Getting Started](https://blog.deepgram.com/diving-into-vue-3-getting-started/)\n*   [Diving Into Vue 3 - The Setup Function](https://blog.deepgram.com/diving-into-vue-3-setup-function/)\n*   [Diving Into Vue 3: Methods, Watch, and Computed](https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/)\n\nBut first, a little background on **reactivity**. Feel free to skip ahead to the section on [how to make data properties reactive](#how-to-make-data-properties-reactive) if you just want to learn about `ref` and `reactive`.\n\n## What is reactivity?\n\nThe term **reactivity** in relation to Vue generally refers to a feature where what you see on the screen automatically updates in-sync with any changes to the state. It's the Vue 'magic' that makes the template re-render instantly if a data property changes.\n\nWhen talking about **reactivity** in JavaScript or in programming in general, the term means programming something to work the way Vue does by implementing a design pattern called the **Observer Pattern**, which is explained in [Design Patterns for Humans](https://github.com/sohamkamani/javascript-design-patterns-for-humans#-observer) as :\n\n> whenever an object changes its state, all its dependents are notified.\n\nVue automatically updating the DOM when a data property changes is a result of Vue being built using the **Observer Pattern** - Vue state is an object with properties that have dependencies, so if one of those properties changes, its dependents react to the change by updating if they need to, and that triggers the re-render in the browser.\n\nJavaScript on its own is not reactive, as shown in this example:\n\n```js\nlet numWorkers = 50\nlet numManagers = 4\nlet totalEmployees = numWorkers + numManagers\n\nconsole.log(totalEmployees) // 54\n\nnumWorkers = 48\n\nconsole.log(totalEmployees) // Still 54\n```\n\nVue is reactive because the core Vue.js team built it to be. So in the following example, `totalEmployees` will automatically update anytime `numWorkers` or `numManagers` (two properties in the state object) changes:\n\n```js\n  data() {\n    //returns the state object\n    return { numWorkers: 4, numManagers: 6 }\n  },\n  computed: {\n    totalEmployees() {\n      // returns whatever the total is based on current state for numWorkers and numManagers\n      return this.numWorkers +  this.numManagers\n    }\n  }\n```\n\n### Reactivity in Vue 2\n\nThe reactivity system in both Vue 2 and Vue 3 is based on state being an object, but there are big differences in how the properties are made reactive.\n\nIn Vue 2 the data option returns an object:\n\n```js\n  data() {\n    return {\n      numWorkers: 4,\n      numManagers: 6\n    }\n  }\n```\n\nUnder the hood, Vue 2 uses `Object.defineProperty` to define all the data properties on a component instance, converting them to getters and setters. There's a deep dive into the Vue 2's reactivity system in the [Vue.js docs](https://v2.vuejs.org/v2/guide/reactivity.html) that's worth spending some time with.\n\nBecause defining the properties happens at the time of the component instance's initialization, it results in some small drawbacks:\n\n*   data properties cannot be added or deleted after component instance initialization. They have to be present during initialization for them to be reactive\n\n*   If the data property is an array, it is not possible to set an item directly to the array through assignment by using the array index (as in `arr[0] = value`), and it also isn't possible to update the length of the array (as in `arr.length = 0`)\n\nThis isn't a *major* problem because the `Vue.$set` method can be used in cases where these updates need to be made after component instance initialization. However, Vue 3's reactivity system is so improved that now these issues are no longer a problem, making it unnecessary to use `Vue.$set`.\n\n### Reactivity in Vue 3\n\nVue 3's reactivity system had a major rewrite from what it was in Vue 2. The fundamental idea of tracking all the data properties and their dependencies so they can update automatically is still the same, but Vue 3 now uses the JavaScript [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) API to achieve this (instead of `Object.defineProperty` like in Vue 2).\n\nThere's a rabbit hole to go down for anyone who wants to learn more about the Vue 3 reactivity system, and the [Vue.js docs](https://v3.vuejs.org/guide/reactivity.html#how-vue-tracks-these-changes) are fantastic. Even though I'm not going to explain it all (there's no way I could!), there are a few things I think are helpful to understand.\n\nThe docs state:\n\n> Proxy is an object that encases another object and allows you to intercept any interactions with that object.\n\nAwareness of reactive properties using proxies is helpful when debugging code in the console. If I `console.log` a reactive property such as this property `company`:\n\n```js\nconst company = reactive({\n  employees: ['Tom', 'Sara', 'Joe'],\n  managers: ['Julie', 'Jorge'],\n})\n```\n\nin the console, I see:\n\n![A console.log for a reactive property which shows the proxy](https://res.cloudinary.com/deepgram/image/upload/v1644436537/blog/2022/02/diving-into-vue-3-reactivity-api/console_1.png)\n\nClicking on it will open the object to show that there is a Handler and a Target. A proxy always contains a Handler and a Target, and since Vue 3 uses proxies, I find it helpful to be comfortable with the shape of this data as a proxy.\n\n![Same console.log for a reactive property which shows the proxy, now open to show handler and target](https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_2.png)\n\nThe Target is where to look for the actual values. It contains the data that I might be looking for. The Handler contains the special logic for making the data properties reactive. The Handler contains methods like `get` and `set`.\n\nThe Handler is the rabbit hole if you want to learn about reactivity. The Target is where I need to look for my data values.\n\n![Same console.log for a reactive property which shows the proxy, now open to show handler and target with target open to show data values](https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_3.png)\n\nBecause reactive data is wrapped in a proxy, something to get used to when working with the data is the idea of having to 'unwrap' the data object to get to the value. After reading a lot of different resources about working with Vue 3 reactive data, I now feel comfortable with the idea that using strategies to 'unwrap' the data, such as destructuring or drilling down to the value property, are using the metaphor of unwrapping because Vue 3 reactive data is wrapped in a `Proxy` object.\n\n## How to make data properties reactive\n\nAs I said earlier, if I want to make data properties reactive in Vue 2, I have to return them in an object inside the data option of the Options API.\n\n```js\n  data() {\n    return {\n      president: \"Mickey Mouse\",\n      vicePresident: \"Donald Duck\"\n    }\n  }\n```\n\nIf I am using the Vue 3 setup function (see my [post on the setup function](https://blog.deepgram.com/diving-into-vue-3-setup-function/) if you need an explainer on that), I can make data reactive by using the `reactive` or `ref` helpers.\n\n### ref\n\nFor this first example, I will use `ref`. I'm using `ref` because `\"Mickey Mouse\"` and `\"Donald Duck\"` are strings, and the recommendation is to use `ref` with primitive values (i.e. Javascript types that are not objects, such as strings, numbers, etc.)\n\nFirst, I import `ref`:\n\n```js\n<script>import { ref } from \"vue\";<\/script>\n```\n\nThen in the `setup` function, I set my variable to the `ref()` helper, which takes in the initial value. I must include the data in the return object if I want it to be available to the template.\n\n```js\n  setup() {\n    let president = ref(\"Mickey Mouse\");\n    let vicePresident = ref(\"Donald Duck\");\n\n    return { president, vicePresident };\n    },\n```\n\nAn important difference between `ref` and `reactive` is that if I want to do something to the value of my `ref` properties inside the `setup` function, I have to unwrap the object to access that value. So if I want to change the value of `president`, I will change `president.value`:\n\n```js\n  function changePresident() {\n    president.value = 'Goofy'\n  }\n```\n\nI don't have to worry about unwrapping the values for `president` and `vicePresident` in the `template`. Vue can shallow unwrap those for me. 'Shallow unwrap' means the first level of properties in an object are available in the template without having to use `.value` (but nested properties would still need to be unwrapped).\n\n```html\n<template>\n  <div>\n    <p><b>President:</b> {{ president }}</p>\n    <p><b>Vice President:</b> {{ vicePresident }}</p>\n  </div>\n</template>\n```\n\nFYI, it's fine not to use `ref` if I don't need the data to be reactive, just writing the data like this:\n\n```js\nsetup() {\n  let president = \"Mickey Mouse\"\n  let vicePresident = \"Donald Duck\"\n\n  return { president, vicePresident };\n},\n```\n\nBut it would mean the data isn't reactive, so I can't ever see updates to the data. If I use a method to change the data, I would never see that update change anything on the screen, and I would have to be happy with Mickey Mouse and Donald Duck showing as president and vice president forever.\n\nThere are times when you don't need the data to be reactive, so in those instances, just don't use `ref` or `reactive`!\n\n### reactive\n\nI can use `reactive` for the same example, but I would only do so if I wanted the data to start out in the form of an object rather than separate string values. So in Vue 2, if I have this:\n\n```js\ndata() {\n  return {\n    executiveTeam: {\n      president: \"Mickey Mouse\",\n      vicePresident: \"Donald Duck\",\n    },\n  };\n},\n```\n\nTo change this to Vue 3 using `reactive`, I will first import `reactive`:\n\n```js\nimport { reactive } from 'vue'\n```\n\nIn the `setup` function, I will create an object for `executiveTeam` and define the properties on the object. I can set the object to `const` since the object itself won't change, just the properties inside.\n\n```js\nsetup() {\n  const executiveTeam = reactive({\n    president: \"Mickey Mouse\",\n    vicePresident: \"Donald Duck\",\n  });\n\n  return { executiveTeam };\n},\n```\n\nAnd if I want to update the data, I do not have to unwrap it with `.value `like I do with `ref`.\n\n```js\nfunction changePresident() {\n  executiveTeam.president = 'Goofy'\n}\n```\n\nThis is because `reactive` is used with objects, and objects pass values by *reference* (which lends itself better to reactivity). Reactive references (`ref`) are used for primitive types, and primitives in Javascript pass values by *value*, so Vue has to wrap them in an object to make them reactive. Since `ref` properties are wrapped to make them reactive, they have to be unwrapped down to the `.value` to get the value. Read more about this concept in the  [Composition API RFC](https://github.com/vuejs/composition-api-rfc/blob/master/index.md#computed-state-and-refs) if this concept is something you want to understand more deeply.\n\nHowever, because I'm returning the object `executiveTeam` and I want to access the properties `president` and `vicePresident` on that object in the template, I will have to drill down into the `executiveTeam` object to get each property I need:\n\n```html\n<template>\n  <div>\n    <p><b>President:</b> {{ executiveTeam.president }}</p>\n    <p><b>Vice President:</b> {{ executiveTeam.vicePresident }}</p>\n  </div>\n</template>\n```\n\nI cannot destructure the object that I return because if I do, the properties inside `executiveTeam` will lose reactivity. I'll demonstrate this in the next example to make this more clear.\n\nWhen using `reactive` to give an object's properties reactivity, like this:\n\n```js\nconst executiveTeam = reactive({\n  president: 'Mickey Mouse',\n  vicePresident: 'Donald Duck',\n})\n```\n\nI cannot destructure to try and return those properties by their key, as in:\n\n```js\n//LOSES REACTIVITY:\nlet { president, vicePresident } = executiveTeam\n\nreturn { president, vicePresident }\n```\n\nThis is where `toRefs` comes in handy.\n\n### toRefs\n\nThe helper `toRefs` will allow me to turn each of the properties in the object into a `ref`, which means I won't have to use `executiveTeam.president` in the template; I'll be able to just write `president`. Here's the full example now using `toRefs`:\n\n```js\n<script>\nimport { reactive, toRefs } from \"vue\";\nexport default {\n  setup() {\n    const executiveTeam = reactive({\n      president: \"Mickey Mouse\",\n      vicePresident: \"Donald Duck\",\n    });\n\n    //toRefs allows me to destructure\n    let { president, vicePresident } = toRefs(executiveTeam);\n\n    return { president, vicePresident };\n  },\n};\n<\/script>\n\n```\n\nSince `toRefs` turns each property into a `ref`, I need to go back to unwrapping them down to their value using `.value `if I want to do something to them in the `setup` function:\n\n```js\nfunction changePresident() {\n  president.value = 'Goofy'\n}\n```\n\n### toRef\n\nJust like `toRefs`, the helper `toRef` is used to turn reactive object properties into reactive references (`ref`), but I would use `toRef` if I just need to turn one property in a reactive object into a `ref`:\n\n```js\nsetup() {\n  const executiveTeam = reactive({\n    president: \"Mickey Mouse\",\n    vicePresident: \"Donald Duck\",\n  });\n  //toRef used to turn just one property into a ref\n  let presidentRef = toRef(executiveTeam, \"president\");\n\n  const changePresident = () => {\n    presidentRef.value = \"Goofy\";\n  };\n\n  return { presidentRef, changePresident };\n},\n```\n\nI will have to use `.value` if I want to update the ref's value inside the setup function, but in the template, Vue will unwrap `president` for me:\n\n```html\n<template>\n  <div>\n    <h1>Company Roles</h1>\n    <p><b>President:</b> {{ presidentRef }}</p>\n    <button @click=\"changePresident\">Change President</button>\n  </div>\n</template>\n```\n\nIt can be challenging to remember which variables are `reactive` properties and which ones are `ref`. Something that helps is to use a naming convention where I add the suffix **Ref** to anything that is a `ref`, such as `presidentRef`. I don't have a lot of experience with Vue 3 yet, but for the time being, I plan to use that naming convention to see if it helps me get a better handle on the distinction between `ref` and `reactive` properties.\n\n### isRef\n\nVue 3 also provides the helper `isRef` that I can use to check if something is a `ref`.\n\n```js\nconsole.log(isRef(executiveTeam.president)) //false\nconsole.log(isRef(presidentRef)) //true\n```\n\n## My Thoughts on the Vue 3 Reactivity API\n\nThis topic of `ref` and `reactive` has been the most challenging for me in my goal to learn Vue 3. There is more nuance to how these helpers are used in practice, and it becomes too much for an introduction post to try to cover all the different situations where I might have to make informed decisions about using `ref` and/or `reactive` and all the other helpers.\n\nThe Vue.js team is aware that this is one of the challenges of Vue 3 - the question of when to use `ref` or `reactive` does not always receive a simple answer. In the Composition API RFC they state:\n\n> Understandably, users may get confused regarding which to use between ref and reactive. First thing to know is that you will need to understand both to efficiently make use of the Composition API. Using one exclusively will most likely lead to esoteric workarounds or reinvented wheels.\n\nI have come across many resources that suggest using just `ref` or just `reactive` to start. But I think it is worth the effort to learn the nuances of both. I agree with the Vue.js team: it's better to understand both `ref` and `reactive` if I'm going to use Vue 3 to its fullest potential. And that's what I plan to do.\n\nWhile using just `ref` for primitives and `reactive` for objects is one suggested approach (suggested by the Vue.js team [here](https://github.com/vuejs/composition-api-rfc/blob/master/index.md#ref-vs-reactive)), I would encourage you to dig deeper into the docs and resources out there to learn more about the Reactivity APIs. For a nuanced feature such as this, it's important to understand why certain approaches can be taken.\n\n## Conclusion\n\nPlease join me for my next post about reusability in Vue 3, including a discussion of composition functions (i.e. Vue composables). In my opinion, composables are the best thing about this new Composition API and they make it worth putting in the time to learn the harder concepts of Vue 3.\n\nPlease reach out on [Twitter](https://twitter.com/sandra_rodgers_) and let me know if you are enjoying this series on Vue 3.\n\n        ", "html": '<p>This is the fourth post in my \u2018Diving Into Vue 3\u2019 series. Today I hope to give a clear and practical description of how to use the new Reactivity APIs, focusing on <code is:raw>ref</code> and <code is:raw>reactive</code>. I\u2019ll also introduce how to use related helpers such as <code is:raw>toRef</code>, <code is:raw>toRefs</code>, and <code is:raw>isRef</code>.</p>\n<p>The other posts in this series that have already come out are:</p>\n<ul>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3 - Getting Started</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-setup-function/">Diving Into Vue 3 - The Setup Function</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/">Diving Into Vue 3: Methods, Watch, and Computed</a></li>\n</ul>\n<p>But first, a little background on <strong>reactivity</strong>. Feel free to skip ahead to the section on <a href="#how-to-make-data-properties-reactive">how to make data properties reactive</a> if you just want to learn about <code is:raw>ref</code> and <code is:raw>reactive</code>.</p>\n<h2 id="what-is-reactivity">What is reactivity?</h2>\n<p>The term <strong>reactivity</strong> in relation to Vue generally refers to a feature where what you see on the screen automatically updates in-sync with any changes to the state. It\u2019s the Vue \u2018magic\u2019 that makes the template re-render instantly if a data property changes.</p>\n<p>When talking about <strong>reactivity</strong> in JavaScript or in programming in general, the term means programming something to work the way Vue does by implementing a design pattern called the <strong>Observer Pattern</strong>, which is explained in <a href="https://github.com/sohamkamani/javascript-design-patterns-for-humans#-observer">Design Patterns for Humans</a> as :</p>\n<blockquote>\n<p>whenever an object changes its state, all its dependents are notified.</p>\n</blockquote>\n<p>Vue automatically updating the DOM when a data property changes is a result of Vue being built using the <strong>Observer Pattern</strong> - Vue state is an object with properties that have dependencies, so if one of those properties changes, its dependents react to the change by updating if they need to, and that triggers the re-render in the browser.</p>\n<p>JavaScript on its own is not reactive, as shown in this example:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> numWorkers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">50</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> numManagers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">4</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> totalEmployees </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> numWorkers </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> numManagers</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(totalEmployees) </span><span style="color: #8B949E">// 54</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">numWorkers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">48</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(totalEmployees) </span><span style="color: #8B949E">// Still 54</span></span></code></pre>\n<p>Vue is reactive because the core Vue.js team built it to be. So in the following example, <code is:raw>totalEmployees</code> will automatically update anytime <code is:raw>numWorkers</code> or <code is:raw>numManagers</code> (two properties in the state object) changes:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//returns the state object</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { numWorkers: </span><span style="color: #79C0FF">4</span><span style="color: #C9D1D9">, numManagers: </span><span style="color: #79C0FF">6</span><span style="color: #C9D1D9"> }</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FFA657">computed</span><span style="color: #C9D1D9">: {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">totalEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// returns whatever the total is based on current state for numWorkers and numManagers</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numWorkers </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9">  </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numManagers</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>\n<h3 id="reactivity-in-vue-2">Reactivity in Vue 2</h3>\n<p>The reactivity system in both Vue 2 and Vue 3 is based on state being an object, but there are big differences in how the properties are made reactive.</p>\n<p>In Vue 2 the data option returns an object:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      numWorkers: </span><span style="color: #79C0FF">4</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">      numManagers: </span><span style="color: #79C0FF">6</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>\n<p>Under the hood, Vue 2 uses <code is:raw>Object.defineProperty</code> to define all the data properties on a component instance, converting them to getters and setters. There\u2019s a deep dive into the Vue 2\u2019s reactivity system in the <a href="https://v2.vuejs.org/v2/guide/reactivity.html">Vue.js docs</a> that\u2019s worth spending some time with.</p>\n<p>Because defining the properties happens at the time of the component instance\u2019s initialization, it results in some small drawbacks:</p>\n<ul>\n<li>\n<p>data properties cannot be added or deleted after component instance initialization. They have to be present during initialization for them to be reactive</p>\n</li>\n<li>\n<p>If the data property is an array, it is not possible to set an item directly to the array through assignment by using the array index (as in <code is:raw>arr[0] = value</code>), and it also isn\u2019t possible to update the length of the array (as in <code is:raw>arr.length = 0</code>)</p>\n</li>\n</ul>\n<p>This isn\u2019t a <em>major</em> problem because the <code is:raw>Vue.$set</code> method can be used in cases where these updates need to be made after component instance initialization. However, Vue 3\u2019s reactivity system is so improved that now these issues are no longer a problem, making it unnecessary to use <code is:raw>Vue.$set</code>.</p>\n<h3 id="reactivity-in-vue-3">Reactivity in Vue 3</h3>\n<p>Vue 3\u2019s reactivity system had a major rewrite from what it was in Vue 2. The fundamental idea of tracking all the data properties and their dependencies so they can update automatically is still the same, but Vue 3 now uses the JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> API to achieve this (instead of <code is:raw>Object.defineProperty</code> like in Vue 2).</p>\n<p>There\u2019s a rabbit hole to go down for anyone who wants to learn more about the Vue 3 reactivity system, and the <a href="https://v3.vuejs.org/guide/reactivity.html#how-vue-tracks-these-changes">Vue.js docs</a> are fantastic. Even though I\u2019m not going to explain it all (there\u2019s no way I could!), there are a few things I think are helpful to understand.</p>\n<p>The docs state:</p>\n<blockquote>\n<p>Proxy is an object that encases another object and allows you to intercept any interactions with that object.</p>\n</blockquote>\n<p>Awareness of reactive properties using proxies is helpful when debugging code in the console. If I <code is:raw>console.log</code> a reactive property such as this property <code is:raw>company</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">company</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">  employees: [</span><span style="color: #A5D6FF">&#39;Tom&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;Sara&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;Joe&#39;</span><span style="color: #C9D1D9">],</span></span>\n<span class="line"><span style="color: #C9D1D9">  managers: [</span><span style="color: #A5D6FF">&#39;Julie&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;Jorge&#39;</span><span style="color: #C9D1D9">],</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>in the console, I see:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1644436537/blog/2022/02/diving-into-vue-3-reactivity-api/console_1.png" alt="A console.log for a reactive property which shows the proxy"></p>\n<p>Clicking on it will open the object to show that there is a Handler and a Target. A proxy always contains a Handler and a Target, and since Vue 3 uses proxies, I find it helpful to be comfortable with the shape of this data as a proxy.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_2.png" alt="Same console.log for a reactive property which shows the proxy, now open to show handler and target"></p>\n<p>The Target is where to look for the actual values. It contains the data that I might be looking for. The Handler contains the special logic for making the data properties reactive. The Handler contains methods like <code is:raw>get</code> and <code is:raw>set</code>.</p>\n<p>The Handler is the rabbit hole if you want to learn about reactivity. The Target is where I need to look for my data values.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_3.png" alt="Same console.log for a reactive property which shows the proxy, now open to show handler and target with target open to show data values"></p>\n<p>Because reactive data is wrapped in a proxy, something to get used to when working with the data is the idea of having to \u2018unwrap\u2019 the data object to get to the value. After reading a lot of different resources about working with Vue 3 reactive data, I now feel comfortable with the idea that using strategies to \u2018unwrap\u2019 the data, such as destructuring or drilling down to the value property, are using the metaphor of unwrapping because Vue 3 reactive data is wrapped in a <code is:raw>Proxy</code> object.</p>\n<h2 id="how-to-make-data-properties-reactive">How to make data properties reactive</h2>\n<p>As I said earlier, if I want to make data properties reactive in Vue 2, I have to return them in an object inside the data option of the Options API.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">      vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>\n<p>If I am using the Vue 3 setup function (see my <a href="https://blog.deepgram.com/diving-into-vue-3-setup-function/">post on the setup function</a> if you need an explainer on that), I can make data reactive by using the <code is:raw>reactive</code> or <code is:raw>ref</code> helpers.</p>\n<h3 id="ref">ref</h3>\n<p>For this first example, I will use <code is:raw>ref</code>. I\u2019m using <code is:raw>ref</code> because <code is:raw>"Mickey Mouse"</code> and <code is:raw>"Donald Duck"</code> are strings, and the recommendation is to use <code is:raw>ref</code> with primitive values (i.e. Javascript types that are not objects, such as strings, numbers, etc.)</p>\n<p>First, I import <code is:raw>ref</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>Then in the <code is:raw>setup</code> function, I set my variable to the <code is:raw>ref()</code> helper, which takes in the initial value. I must include the data in the return object if I want it to be available to the template.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> president </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> vicePresident </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { president, vicePresident };</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span></code></pre>\n<p>An important difference between <code is:raw>ref</code> and <code is:raw>reactive</code> is that if I want to do something to the value of my <code is:raw>ref</code> properties inside the <code is:raw>setup</code> function, I have to unwrap the object to access that value. So if I want to change the value of <code is:raw>president</code>, I will change <code is:raw>president.value</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    president.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Goofy&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>\n<p>I don\u2019t have to worry about unwrapping the values for <code is:raw>president</code> and <code is:raw>vicePresident</code> in the <code is:raw>template</code>. Vue can shallow unwrap those for me. \u2018Shallow unwrap\u2019 means the first level of properties in an object are available in the template without having to use <code is:raw>.value</code> (but nested properties would still need to be unwrapped).</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ president }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;Vice President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ vicePresident }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>FYI, it\u2019s fine not to use <code is:raw>ref</code> if I don\u2019t need the data to be reactive, just writing the data like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> president </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> vicePresident </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { president, vicePresident };</span></span>\n<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>\n<p>But it would mean the data isn\u2019t reactive, so I can\u2019t ever see updates to the data. If I use a method to change the data, I would never see that update change anything on the screen, and I would have to be happy with Mickey Mouse and Donald Duck showing as president and vice president forever.</p>\n<p>There are times when you don\u2019t need the data to be reactive, so in those instances, just don\u2019t use <code is:raw>ref</code> or <code is:raw>reactive</code>!</p>\n<h3 id="reactive">reactive</h3>\n<p>I can use <code is:raw>reactive</code> for the same example, but I would only do so if I wanted the data to start out in the form of an object rather than separate string values. So in Vue 2, if I have this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    executiveTeam: {</span></span>\n<span class="line"><span style="color: #C9D1D9">      president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">      vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span>\n<span class="line"><span style="color: #C9D1D9">  };</span></span>\n<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>\n<p>To change this to Vue 3 using <code is:raw>reactive</code>, I will first import <code is:raw>reactive</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { reactive } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span></code></pre>\n<p>In the <code is:raw>setup</code> function, I will create an object for <code is:raw>executiveTeam</code> and define the properties on the object. I can set the object to <code is:raw>const</code> since the object itself won\u2019t change, just the properties inside.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">executiveTeam</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">    president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">  });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { executiveTeam };</span></span>\n<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>\n<p>And if I want to update the data, I do not have to unwrap it with <code is:raw>.value </code>like I do with <code is:raw>ref</code>.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  executiveTeam.president </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Goofy&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>This is because <code is:raw>reactive</code> is used with objects, and objects pass values by <em>reference</em> (which lends itself better to reactivity). Reactive references (<code is:raw>ref</code>) are used for primitive types, and primitives in Javascript pass values by <em>value</em>, so Vue has to wrap them in an object to make them reactive. Since <code is:raw>ref</code> properties are wrapped to make them reactive, they have to be unwrapped down to the <code is:raw>.value</code> to get the value. Read more about this concept in the  <a href="https://github.com/vuejs/composition-api-rfc/blob/master/index.md#computed-state-and-refs">Composition API RFC</a> if this concept is something you want to understand more deeply.</p>\n<p>However, because I\u2019m returning the object <code is:raw>executiveTeam</code> and I want to access the properties <code is:raw>president</code> and <code is:raw>vicePresident</code> on that object in the template, I will have to drill down into the <code is:raw>executiveTeam</code> object to get each property I need:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ executiveTeam.president }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;Vice President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ executiveTeam.vicePresident }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>I cannot destructure the object that I return because if I do, the properties inside <code is:raw>executiveTeam</code> will lose reactivity. I\u2019ll demonstrate this in the next example to make this more clear.</p>\n<p>When using <code is:raw>reactive</code> to give an object\u2019s properties reactivity, like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">executiveTeam</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">  president: </span><span style="color: #A5D6FF">&#39;Mickey Mouse&#39;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">  vicePresident: </span><span style="color: #A5D6FF">&#39;Donald Duck&#39;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>I cannot destructure to try and return those properties by their key, as in:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//LOSES REACTIVITY:</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> { president, vicePresident } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> executiveTeam</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { president, vicePresident }</span></span></code></pre>\n<p>This is where <code is:raw>toRefs</code> comes in handy.</p>\n<h3 id="torefs">toRefs</h3>\n<p>The helper <code is:raw>toRefs</code> will allow me to turn each of the properties in the object into a <code is:raw>ref</code>, which means I won\u2019t have to use <code is:raw>executiveTeam.president</code> in the template; I\u2019ll be able to just write <code is:raw>president</code>. Here\u2019s the full example now using <code is:raw>toRefs</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> reactive, toRefs </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    const executiveTeam </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">      president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">      vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//toRefs allows me to destructure</span></span>\n<span class="line"><span style="color: #C9D1D9">    let { president, vicePresident } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">toRefs</span><span style="color: #C9D1D9">(executiveTeam);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { president, vicePresident };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span></code></pre>\n<p>Since <code is:raw>toRefs</code> turns each property into a <code is:raw>ref</code>, I need to go back to unwrapping them down to their value using <code is:raw>.value </code>if I want to do something to them in the <code is:raw>setup</code> function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  president.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Goofy&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<h3 id="toref">toRef</h3>\n<p>Just like <code is:raw>toRefs</code>, the helper <code is:raw>toRef</code> is used to turn reactive object properties into reactive references (<code is:raw>ref</code>), but I would use <code is:raw>toRef</code> if I just need to turn one property in a reactive object into a <code is:raw>ref</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">executiveTeam</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">    president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">  });</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//toRef used to turn just one property into a ref</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> presidentRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">toRef</span><span style="color: #C9D1D9">(executiveTeam, </span><span style="color: #A5D6FF">&quot;president&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    presidentRef.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;Goofy&quot;</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">  };</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { presidentRef, changePresident };</span></span>\n<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>\n<p>I will have to use <code is:raw>.value</code> if I want to update the ref\u2019s value inside the setup function, but in the template, Vue will unwrap <code is:raw>president</code> for me:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;Company Roles&lt;/</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ presidentRef }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">@click</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;changePresident&quot;</span><span style="color: #C9D1D9">&gt;Change President&lt;/</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>It can be challenging to remember which variables are <code is:raw>reactive</code> properties and which ones are <code is:raw>ref</code>. Something that helps is to use a naming convention where I add the suffix <strong>Ref</strong> to anything that is a <code is:raw>ref</code>, such as <code is:raw>presidentRef</code>. I don\u2019t have a lot of experience with Vue 3 yet, but for the time being, I plan to use that naming convention to see if it helps me get a better handle on the distinction between <code is:raw>ref</code> and <code is:raw>reactive</code> properties.</p>\n<h3 id="isref">isRef</h3>\n<p>Vue 3 also provides the helper <code is:raw>isRef</code> that I can use to check if something is a <code is:raw>ref</code>.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">isRef</span><span style="color: #C9D1D9">(executiveTeam.president)) </span><span style="color: #8B949E">//false</span></span>\n<span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">isRef</span><span style="color: #C9D1D9">(presidentRef)) </span><span style="color: #8B949E">//true</span></span></code></pre>\n<h2 id="my-thoughts-on-the-vue-3-reactivity-api">My Thoughts on the Vue 3 Reactivity API</h2>\n<p>This topic of <code is:raw>ref</code> and <code is:raw>reactive</code> has been the most challenging for me in my goal to learn Vue 3. There is more nuance to how these helpers are used in practice, and it becomes too much for an introduction post to try to cover all the different situations where I might have to make informed decisions about using <code is:raw>ref</code> and/or <code is:raw>reactive</code> and all the other helpers.</p>\n<p>The Vue.js team is aware that this is one of the challenges of Vue 3 - the question of when to use <code is:raw>ref</code> or <code is:raw>reactive</code> does not always receive a simple answer. In the Composition API RFC they state:</p>\n<blockquote>\n<p>Understandably, users may get confused regarding which to use between ref and reactive. First thing to know is that you will need to understand both to efficiently make use of the Composition API. Using one exclusively will most likely lead to esoteric workarounds or reinvented wheels.</p>\n</blockquote>\n<p>I have come across many resources that suggest using just <code is:raw>ref</code> or just <code is:raw>reactive</code> to start. But I think it is worth the effort to learn the nuances of both. I agree with the Vue.js team: it\u2019s better to understand both <code is:raw>ref</code> and <code is:raw>reactive</code> if I\u2019m going to use Vue 3 to its fullest potential. And that\u2019s what I plan to do.</p>\n<p>While using just <code is:raw>ref</code> for primitives and <code is:raw>reactive</code> for objects is one suggested approach (suggested by the Vue.js team <a href="https://github.com/vuejs/composition-api-rfc/blob/master/index.md#ref-vs-reactive">here</a>), I would encourage you to dig deeper into the docs and resources out there to learn more about the Reactivity APIs. For a nuanced feature such as this, it\u2019s important to understand why certain approaches can be taken.</p>\n<h2 id="conclusion">Conclusion</h2>\n<p>Please join me for my next post about reusability in Vue 3, including a discussion of composition functions (i.e. Vue composables). In my opinion, composables are the best thing about this new Composition API and they make it worth putting in the time to learn the harder concepts of Vue 3.</p>\n<p>Please reach out on <a href="https://twitter.com/sandra_rodgers_">Twitter</a> and let me know if you are enjoying this series on Vue 3.</p>' }, "file": "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/diving-into-vue-3-reactivity-api/index.md" };
function rawContent() {
  return "\nThis is the fourth post in my 'Diving Into Vue 3' series. Today I hope to give a clear and practical description of how to use the new Reactivity APIs, focusing on `ref` and `reactive`. I'll also introduce how to use related helpers such as `toRef`, `toRefs`, and `isRef`.\n\nThe other posts in this series that have already come out are:\n\n*   [Diving Into Vue 3 - Getting Started](https://blog.deepgram.com/diving-into-vue-3-getting-started/)\n*   [Diving Into Vue 3 - The Setup Function](https://blog.deepgram.com/diving-into-vue-3-setup-function/)\n*   [Diving Into Vue 3: Methods, Watch, and Computed](https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/)\n\nBut first, a little background on **reactivity**. Feel free to skip ahead to the section on [how to make data properties reactive](#how-to-make-data-properties-reactive) if you just want to learn about `ref` and `reactive`.\n\n## What is reactivity?\n\nThe term **reactivity** in relation to Vue generally refers to a feature where what you see on the screen automatically updates in-sync with any changes to the state. It's the Vue 'magic' that makes the template re-render instantly if a data property changes.\n\nWhen talking about **reactivity** in JavaScript or in programming in general, the term means programming something to work the way Vue does by implementing a design pattern called the **Observer Pattern**, which is explained in [Design Patterns for Humans](https://github.com/sohamkamani/javascript-design-patterns-for-humans#-observer) as :\n\n> whenever an object changes its state, all its dependents are notified.\n\nVue automatically updating the DOM when a data property changes is a result of Vue being built using the **Observer Pattern** - Vue state is an object with properties that have dependencies, so if one of those properties changes, its dependents react to the change by updating if they need to, and that triggers the re-render in the browser.\n\nJavaScript on its own is not reactive, as shown in this example:\n\n```js\nlet numWorkers = 50\nlet numManagers = 4\nlet totalEmployees = numWorkers + numManagers\n\nconsole.log(totalEmployees) // 54\n\nnumWorkers = 48\n\nconsole.log(totalEmployees) // Still 54\n```\n\nVue is reactive because the core Vue.js team built it to be. So in the following example, `totalEmployees` will automatically update anytime `numWorkers` or `numManagers` (two properties in the state object) changes:\n\n```js\n  data() {\n    //returns the state object\n    return { numWorkers: 4, numManagers: 6 }\n  },\n  computed: {\n    totalEmployees() {\n      // returns whatever the total is based on current state for numWorkers and numManagers\n      return this.numWorkers +  this.numManagers\n    }\n  }\n```\n\n### Reactivity in Vue 2\n\nThe reactivity system in both Vue 2 and Vue 3 is based on state being an object, but there are big differences in how the properties are made reactive.\n\nIn Vue 2 the data option returns an object:\n\n```js\n  data() {\n    return {\n      numWorkers: 4,\n      numManagers: 6\n    }\n  }\n```\n\nUnder the hood, Vue 2 uses `Object.defineProperty` to define all the data properties on a component instance, converting them to getters and setters. There's a deep dive into the Vue 2's reactivity system in the [Vue.js docs](https://v2.vuejs.org/v2/guide/reactivity.html) that's worth spending some time with.\n\nBecause defining the properties happens at the time of the component instance's initialization, it results in some small drawbacks:\n\n*   data properties cannot be added or deleted after component instance initialization. They have to be present during initialization for them to be reactive\n\n*   If the data property is an array, it is not possible to set an item directly to the array through assignment by using the array index (as in `arr[0] = value`), and it also isn't possible to update the length of the array (as in `arr.length = 0`)\n\nThis isn't a *major* problem because the `Vue.$set` method can be used in cases where these updates need to be made after component instance initialization. However, Vue 3's reactivity system is so improved that now these issues are no longer a problem, making it unnecessary to use `Vue.$set`.\n\n### Reactivity in Vue 3\n\nVue 3's reactivity system had a major rewrite from what it was in Vue 2. The fundamental idea of tracking all the data properties and their dependencies so they can update automatically is still the same, but Vue 3 now uses the JavaScript [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) API to achieve this (instead of `Object.defineProperty` like in Vue 2).\n\nThere's a rabbit hole to go down for anyone who wants to learn more about the Vue 3 reactivity system, and the [Vue.js docs](https://v3.vuejs.org/guide/reactivity.html#how-vue-tracks-these-changes) are fantastic. Even though I'm not going to explain it all (there's no way I could!), there are a few things I think are helpful to understand.\n\nThe docs state:\n\n> Proxy is an object that encases another object and allows you to intercept any interactions with that object.\n\nAwareness of reactive properties using proxies is helpful when debugging code in the console. If I `console.log` a reactive property such as this property `company`:\n\n```js\nconst company = reactive({\n  employees: ['Tom', 'Sara', 'Joe'],\n  managers: ['Julie', 'Jorge'],\n})\n```\n\nin the console, I see:\n\n![A console.log for a reactive property which shows the proxy](https://res.cloudinary.com/deepgram/image/upload/v1644436537/blog/2022/02/diving-into-vue-3-reactivity-api/console_1.png)\n\nClicking on it will open the object to show that there is a Handler and a Target. A proxy always contains a Handler and a Target, and since Vue 3 uses proxies, I find it helpful to be comfortable with the shape of this data as a proxy.\n\n![Same console.log for a reactive property which shows the proxy, now open to show handler and target](https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_2.png)\n\nThe Target is where to look for the actual values. It contains the data that I might be looking for. The Handler contains the special logic for making the data properties reactive. The Handler contains methods like `get` and `set`.\n\nThe Handler is the rabbit hole if you want to learn about reactivity. The Target is where I need to look for my data values.\n\n![Same console.log for a reactive property which shows the proxy, now open to show handler and target with target open to show data values](https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_3.png)\n\nBecause reactive data is wrapped in a proxy, something to get used to when working with the data is the idea of having to 'unwrap' the data object to get to the value. After reading a lot of different resources about working with Vue 3 reactive data, I now feel comfortable with the idea that using strategies to 'unwrap' the data, such as destructuring or drilling down to the value property, are using the metaphor of unwrapping because Vue 3 reactive data is wrapped in a `Proxy` object.\n\n## How to make data properties reactive\n\nAs I said earlier, if I want to make data properties reactive in Vue 2, I have to return them in an object inside the data option of the Options API.\n\n```js\n  data() {\n    return {\n      president: \"Mickey Mouse\",\n      vicePresident: \"Donald Duck\"\n    }\n  }\n```\n\nIf I am using the Vue 3 setup function (see my [post on the setup function](https://blog.deepgram.com/diving-into-vue-3-setup-function/) if you need an explainer on that), I can make data reactive by using the `reactive` or `ref` helpers.\n\n### ref\n\nFor this first example, I will use `ref`. I'm using `ref` because `\"Mickey Mouse\"` and `\"Donald Duck\"` are strings, and the recommendation is to use `ref` with primitive values (i.e. Javascript types that are not objects, such as strings, numbers, etc.)\n\nFirst, I import `ref`:\n\n```js\n<script>import { ref } from \"vue\";<\/script>\n```\n\nThen in the `setup` function, I set my variable to the `ref()` helper, which takes in the initial value. I must include the data in the return object if I want it to be available to the template.\n\n```js\n  setup() {\n    let president = ref(\"Mickey Mouse\");\n    let vicePresident = ref(\"Donald Duck\");\n\n    return { president, vicePresident };\n    },\n```\n\nAn important difference between `ref` and `reactive` is that if I want to do something to the value of my `ref` properties inside the `setup` function, I have to unwrap the object to access that value. So if I want to change the value of `president`, I will change `president.value`:\n\n```js\n  function changePresident() {\n    president.value = 'Goofy'\n  }\n```\n\nI don't have to worry about unwrapping the values for `president` and `vicePresident` in the `template`. Vue can shallow unwrap those for me. 'Shallow unwrap' means the first level of properties in an object are available in the template without having to use `.value` (but nested properties would still need to be unwrapped).\n\n```html\n<template>\n  <div>\n    <p><b>President:</b> {{ president }}</p>\n    <p><b>Vice President:</b> {{ vicePresident }}</p>\n  </div>\n</template>\n```\n\nFYI, it's fine not to use `ref` if I don't need the data to be reactive, just writing the data like this:\n\n```js\nsetup() {\n  let president = \"Mickey Mouse\"\n  let vicePresident = \"Donald Duck\"\n\n  return { president, vicePresident };\n},\n```\n\nBut it would mean the data isn't reactive, so I can't ever see updates to the data. If I use a method to change the data, I would never see that update change anything on the screen, and I would have to be happy with Mickey Mouse and Donald Duck showing as president and vice president forever.\n\nThere are times when you don't need the data to be reactive, so in those instances, just don't use `ref` or `reactive`!\n\n### reactive\n\nI can use `reactive` for the same example, but I would only do so if I wanted the data to start out in the form of an object rather than separate string values. So in Vue 2, if I have this:\n\n```js\ndata() {\n  return {\n    executiveTeam: {\n      president: \"Mickey Mouse\",\n      vicePresident: \"Donald Duck\",\n    },\n  };\n},\n```\n\nTo change this to Vue 3 using `reactive`, I will first import `reactive`:\n\n```js\nimport { reactive } from 'vue'\n```\n\nIn the `setup` function, I will create an object for `executiveTeam` and define the properties on the object. I can set the object to `const` since the object itself won't change, just the properties inside.\n\n```js\nsetup() {\n  const executiveTeam = reactive({\n    president: \"Mickey Mouse\",\n    vicePresident: \"Donald Duck\",\n  });\n\n  return { executiveTeam };\n},\n```\n\nAnd if I want to update the data, I do not have to unwrap it with `.value `like I do with `ref`.\n\n```js\nfunction changePresident() {\n  executiveTeam.president = 'Goofy'\n}\n```\n\nThis is because `reactive` is used with objects, and objects pass values by *reference* (which lends itself better to reactivity). Reactive references (`ref`) are used for primitive types, and primitives in Javascript pass values by *value*, so Vue has to wrap them in an object to make them reactive. Since `ref` properties are wrapped to make them reactive, they have to be unwrapped down to the `.value` to get the value. Read more about this concept in the  [Composition API RFC](https://github.com/vuejs/composition-api-rfc/blob/master/index.md#computed-state-and-refs) if this concept is something you want to understand more deeply.\n\nHowever, because I'm returning the object `executiveTeam` and I want to access the properties `president` and `vicePresident` on that object in the template, I will have to drill down into the `executiveTeam` object to get each property I need:\n\n```html\n<template>\n  <div>\n    <p><b>President:</b> {{ executiveTeam.president }}</p>\n    <p><b>Vice President:</b> {{ executiveTeam.vicePresident }}</p>\n  </div>\n</template>\n```\n\nI cannot destructure the object that I return because if I do, the properties inside `executiveTeam` will lose reactivity. I'll demonstrate this in the next example to make this more clear.\n\nWhen using `reactive` to give an object's properties reactivity, like this:\n\n```js\nconst executiveTeam = reactive({\n  president: 'Mickey Mouse',\n  vicePresident: 'Donald Duck',\n})\n```\n\nI cannot destructure to try and return those properties by their key, as in:\n\n```js\n//LOSES REACTIVITY:\nlet { president, vicePresident } = executiveTeam\n\nreturn { president, vicePresident }\n```\n\nThis is where `toRefs` comes in handy.\n\n### toRefs\n\nThe helper `toRefs` will allow me to turn each of the properties in the object into a `ref`, which means I won't have to use `executiveTeam.president` in the template; I'll be able to just write `president`. Here's the full example now using `toRefs`:\n\n```js\n<script>\nimport { reactive, toRefs } from \"vue\";\nexport default {\n  setup() {\n    const executiveTeam = reactive({\n      president: \"Mickey Mouse\",\n      vicePresident: \"Donald Duck\",\n    });\n\n    //toRefs allows me to destructure\n    let { president, vicePresident } = toRefs(executiveTeam);\n\n    return { president, vicePresident };\n  },\n};\n<\/script>\n\n```\n\nSince `toRefs` turns each property into a `ref`, I need to go back to unwrapping them down to their value using `.value `if I want to do something to them in the `setup` function:\n\n```js\nfunction changePresident() {\n  president.value = 'Goofy'\n}\n```\n\n### toRef\n\nJust like `toRefs`, the helper `toRef` is used to turn reactive object properties into reactive references (`ref`), but I would use `toRef` if I just need to turn one property in a reactive object into a `ref`:\n\n```js\nsetup() {\n  const executiveTeam = reactive({\n    president: \"Mickey Mouse\",\n    vicePresident: \"Donald Duck\",\n  });\n  //toRef used to turn just one property into a ref\n  let presidentRef = toRef(executiveTeam, \"president\");\n\n  const changePresident = () => {\n    presidentRef.value = \"Goofy\";\n  };\n\n  return { presidentRef, changePresident };\n},\n```\n\nI will have to use `.value` if I want to update the ref's value inside the setup function, but in the template, Vue will unwrap `president` for me:\n\n```html\n<template>\n  <div>\n    <h1>Company Roles</h1>\n    <p><b>President:</b> {{ presidentRef }}</p>\n    <button @click=\"changePresident\">Change President</button>\n  </div>\n</template>\n```\n\nIt can be challenging to remember which variables are `reactive` properties and which ones are `ref`. Something that helps is to use a naming convention where I add the suffix **Ref** to anything that is a `ref`, such as `presidentRef`. I don't have a lot of experience with Vue 3 yet, but for the time being, I plan to use that naming convention to see if it helps me get a better handle on the distinction between `ref` and `reactive` properties.\n\n### isRef\n\nVue 3 also provides the helper `isRef` that I can use to check if something is a `ref`.\n\n```js\nconsole.log(isRef(executiveTeam.president)) //false\nconsole.log(isRef(presidentRef)) //true\n```\n\n## My Thoughts on the Vue 3 Reactivity API\n\nThis topic of `ref` and `reactive` has been the most challenging for me in my goal to learn Vue 3. There is more nuance to how these helpers are used in practice, and it becomes too much for an introduction post to try to cover all the different situations where I might have to make informed decisions about using `ref` and/or `reactive` and all the other helpers.\n\nThe Vue.js team is aware that this is one of the challenges of Vue 3 - the question of when to use `ref` or `reactive` does not always receive a simple answer. In the Composition API RFC they state:\n\n> Understandably, users may get confused regarding which to use between ref and reactive. First thing to know is that you will need to understand both to efficiently make use of the Composition API. Using one exclusively will most likely lead to esoteric workarounds or reinvented wheels.\n\nI have come across many resources that suggest using just `ref` or just `reactive` to start. But I think it is worth the effort to learn the nuances of both. I agree with the Vue.js team: it's better to understand both `ref` and `reactive` if I'm going to use Vue 3 to its fullest potential. And that's what I plan to do.\n\nWhile using just `ref` for primitives and `reactive` for objects is one suggested approach (suggested by the Vue.js team [here](https://github.com/vuejs/composition-api-rfc/blob/master/index.md#ref-vs-reactive)), I would encourage you to dig deeper into the docs and resources out there to learn more about the Reactivity APIs. For a nuanced feature such as this, it's important to understand why certain approaches can be taken.\n\n## Conclusion\n\nPlease join me for my next post about reusability in Vue 3, including a discussion of composition functions (i.e. Vue composables). In my opinion, composables are the best thing about this new Composition API and they make it worth putting in the time to learn the harder concepts of Vue 3.\n\nPlease reach out on [Twitter](https://twitter.com/sandra_rodgers_) and let me know if you are enjoying this series on Vue 3.\n\n        ";
}
function compiledContent() {
  return '<p>This is the fourth post in my \u2018Diving Into Vue 3\u2019 series. Today I hope to give a clear and practical description of how to use the new Reactivity APIs, focusing on <code is:raw>ref</code> and <code is:raw>reactive</code>. I\u2019ll also introduce how to use related helpers such as <code is:raw>toRef</code>, <code is:raw>toRefs</code>, and <code is:raw>isRef</code>.</p>\n<p>The other posts in this series that have already come out are:</p>\n<ul>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3 - Getting Started</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-setup-function/">Diving Into Vue 3 - The Setup Function</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/">Diving Into Vue 3: Methods, Watch, and Computed</a></li>\n</ul>\n<p>But first, a little background on <strong>reactivity</strong>. Feel free to skip ahead to the section on <a href="#how-to-make-data-properties-reactive">how to make data properties reactive</a> if you just want to learn about <code is:raw>ref</code> and <code is:raw>reactive</code>.</p>\n<h2 id="what-is-reactivity">What is reactivity?</h2>\n<p>The term <strong>reactivity</strong> in relation to Vue generally refers to a feature where what you see on the screen automatically updates in-sync with any changes to the state. It\u2019s the Vue \u2018magic\u2019 that makes the template re-render instantly if a data property changes.</p>\n<p>When talking about <strong>reactivity</strong> in JavaScript or in programming in general, the term means programming something to work the way Vue does by implementing a design pattern called the <strong>Observer Pattern</strong>, which is explained in <a href="https://github.com/sohamkamani/javascript-design-patterns-for-humans#-observer">Design Patterns for Humans</a> as :</p>\n<blockquote>\n<p>whenever an object changes its state, all its dependents are notified.</p>\n</blockquote>\n<p>Vue automatically updating the DOM when a data property changes is a result of Vue being built using the <strong>Observer Pattern</strong> - Vue state is an object with properties that have dependencies, so if one of those properties changes, its dependents react to the change by updating if they need to, and that triggers the re-render in the browser.</p>\n<p>JavaScript on its own is not reactive, as shown in this example:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> numWorkers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">50</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> numManagers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">4</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> totalEmployees </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> numWorkers </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> numManagers</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(totalEmployees) </span><span style="color: #8B949E">// 54</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">numWorkers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">48</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(totalEmployees) </span><span style="color: #8B949E">// Still 54</span></span></code></pre>\n<p>Vue is reactive because the core Vue.js team built it to be. So in the following example, <code is:raw>totalEmployees</code> will automatically update anytime <code is:raw>numWorkers</code> or <code is:raw>numManagers</code> (two properties in the state object) changes:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//returns the state object</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { numWorkers: </span><span style="color: #79C0FF">4</span><span style="color: #C9D1D9">, numManagers: </span><span style="color: #79C0FF">6</span><span style="color: #C9D1D9"> }</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FFA657">computed</span><span style="color: #C9D1D9">: {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">totalEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// returns whatever the total is based on current state for numWorkers and numManagers</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numWorkers </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9">  </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numManagers</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>\n<h3 id="reactivity-in-vue-2">Reactivity in Vue 2</h3>\n<p>The reactivity system in both Vue 2 and Vue 3 is based on state being an object, but there are big differences in how the properties are made reactive.</p>\n<p>In Vue 2 the data option returns an object:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      numWorkers: </span><span style="color: #79C0FF">4</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">      numManagers: </span><span style="color: #79C0FF">6</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>\n<p>Under the hood, Vue 2 uses <code is:raw>Object.defineProperty</code> to define all the data properties on a component instance, converting them to getters and setters. There\u2019s a deep dive into the Vue 2\u2019s reactivity system in the <a href="https://v2.vuejs.org/v2/guide/reactivity.html">Vue.js docs</a> that\u2019s worth spending some time with.</p>\n<p>Because defining the properties happens at the time of the component instance\u2019s initialization, it results in some small drawbacks:</p>\n<ul>\n<li>\n<p>data properties cannot be added or deleted after component instance initialization. They have to be present during initialization for them to be reactive</p>\n</li>\n<li>\n<p>If the data property is an array, it is not possible to set an item directly to the array through assignment by using the array index (as in <code is:raw>arr[0] = value</code>), and it also isn\u2019t possible to update the length of the array (as in <code is:raw>arr.length = 0</code>)</p>\n</li>\n</ul>\n<p>This isn\u2019t a <em>major</em> problem because the <code is:raw>Vue.$set</code> method can be used in cases where these updates need to be made after component instance initialization. However, Vue 3\u2019s reactivity system is so improved that now these issues are no longer a problem, making it unnecessary to use <code is:raw>Vue.$set</code>.</p>\n<h3 id="reactivity-in-vue-3">Reactivity in Vue 3</h3>\n<p>Vue 3\u2019s reactivity system had a major rewrite from what it was in Vue 2. The fundamental idea of tracking all the data properties and their dependencies so they can update automatically is still the same, but Vue 3 now uses the JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> API to achieve this (instead of <code is:raw>Object.defineProperty</code> like in Vue 2).</p>\n<p>There\u2019s a rabbit hole to go down for anyone who wants to learn more about the Vue 3 reactivity system, and the <a href="https://v3.vuejs.org/guide/reactivity.html#how-vue-tracks-these-changes">Vue.js docs</a> are fantastic. Even though I\u2019m not going to explain it all (there\u2019s no way I could!), there are a few things I think are helpful to understand.</p>\n<p>The docs state:</p>\n<blockquote>\n<p>Proxy is an object that encases another object and allows you to intercept any interactions with that object.</p>\n</blockquote>\n<p>Awareness of reactive properties using proxies is helpful when debugging code in the console. If I <code is:raw>console.log</code> a reactive property such as this property <code is:raw>company</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">company</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">  employees: [</span><span style="color: #A5D6FF">&#39;Tom&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;Sara&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;Joe&#39;</span><span style="color: #C9D1D9">],</span></span>\n<span class="line"><span style="color: #C9D1D9">  managers: [</span><span style="color: #A5D6FF">&#39;Julie&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;Jorge&#39;</span><span style="color: #C9D1D9">],</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>in the console, I see:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1644436537/blog/2022/02/diving-into-vue-3-reactivity-api/console_1.png" alt="A console.log for a reactive property which shows the proxy"></p>\n<p>Clicking on it will open the object to show that there is a Handler and a Target. A proxy always contains a Handler and a Target, and since Vue 3 uses proxies, I find it helpful to be comfortable with the shape of this data as a proxy.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_2.png" alt="Same console.log for a reactive property which shows the proxy, now open to show handler and target"></p>\n<p>The Target is where to look for the actual values. It contains the data that I might be looking for. The Handler contains the special logic for making the data properties reactive. The Handler contains methods like <code is:raw>get</code> and <code is:raw>set</code>.</p>\n<p>The Handler is the rabbit hole if you want to learn about reactivity. The Target is where I need to look for my data values.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_3.png" alt="Same console.log for a reactive property which shows the proxy, now open to show handler and target with target open to show data values"></p>\n<p>Because reactive data is wrapped in a proxy, something to get used to when working with the data is the idea of having to \u2018unwrap\u2019 the data object to get to the value. After reading a lot of different resources about working with Vue 3 reactive data, I now feel comfortable with the idea that using strategies to \u2018unwrap\u2019 the data, such as destructuring or drilling down to the value property, are using the metaphor of unwrapping because Vue 3 reactive data is wrapped in a <code is:raw>Proxy</code> object.</p>\n<h2 id="how-to-make-data-properties-reactive">How to make data properties reactive</h2>\n<p>As I said earlier, if I want to make data properties reactive in Vue 2, I have to return them in an object inside the data option of the Options API.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">      vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>\n<p>If I am using the Vue 3 setup function (see my <a href="https://blog.deepgram.com/diving-into-vue-3-setup-function/">post on the setup function</a> if you need an explainer on that), I can make data reactive by using the <code is:raw>reactive</code> or <code is:raw>ref</code> helpers.</p>\n<h3 id="ref">ref</h3>\n<p>For this first example, I will use <code is:raw>ref</code>. I\u2019m using <code is:raw>ref</code> because <code is:raw>"Mickey Mouse"</code> and <code is:raw>"Donald Duck"</code> are strings, and the recommendation is to use <code is:raw>ref</code> with primitive values (i.e. Javascript types that are not objects, such as strings, numbers, etc.)</p>\n<p>First, I import <code is:raw>ref</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>Then in the <code is:raw>setup</code> function, I set my variable to the <code is:raw>ref()</code> helper, which takes in the initial value. I must include the data in the return object if I want it to be available to the template.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> president </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> vicePresident </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { president, vicePresident };</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span></code></pre>\n<p>An important difference between <code is:raw>ref</code> and <code is:raw>reactive</code> is that if I want to do something to the value of my <code is:raw>ref</code> properties inside the <code is:raw>setup</code> function, I have to unwrap the object to access that value. So if I want to change the value of <code is:raw>president</code>, I will change <code is:raw>president.value</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    president.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Goofy&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>\n<p>I don\u2019t have to worry about unwrapping the values for <code is:raw>president</code> and <code is:raw>vicePresident</code> in the <code is:raw>template</code>. Vue can shallow unwrap those for me. \u2018Shallow unwrap\u2019 means the first level of properties in an object are available in the template without having to use <code is:raw>.value</code> (but nested properties would still need to be unwrapped).</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ president }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;Vice President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ vicePresident }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>FYI, it\u2019s fine not to use <code is:raw>ref</code> if I don\u2019t need the data to be reactive, just writing the data like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> president </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> vicePresident </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { president, vicePresident };</span></span>\n<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>\n<p>But it would mean the data isn\u2019t reactive, so I can\u2019t ever see updates to the data. If I use a method to change the data, I would never see that update change anything on the screen, and I would have to be happy with Mickey Mouse and Donald Duck showing as president and vice president forever.</p>\n<p>There are times when you don\u2019t need the data to be reactive, so in those instances, just don\u2019t use <code is:raw>ref</code> or <code is:raw>reactive</code>!</p>\n<h3 id="reactive">reactive</h3>\n<p>I can use <code is:raw>reactive</code> for the same example, but I would only do so if I wanted the data to start out in the form of an object rather than separate string values. So in Vue 2, if I have this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    executiveTeam: {</span></span>\n<span class="line"><span style="color: #C9D1D9">      president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">      vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span>\n<span class="line"><span style="color: #C9D1D9">  };</span></span>\n<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>\n<p>To change this to Vue 3 using <code is:raw>reactive</code>, I will first import <code is:raw>reactive</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { reactive } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span></code></pre>\n<p>In the <code is:raw>setup</code> function, I will create an object for <code is:raw>executiveTeam</code> and define the properties on the object. I can set the object to <code is:raw>const</code> since the object itself won\u2019t change, just the properties inside.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">executiveTeam</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">    president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">  });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { executiveTeam };</span></span>\n<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>\n<p>And if I want to update the data, I do not have to unwrap it with <code is:raw>.value </code>like I do with <code is:raw>ref</code>.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  executiveTeam.president </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Goofy&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>This is because <code is:raw>reactive</code> is used with objects, and objects pass values by <em>reference</em> (which lends itself better to reactivity). Reactive references (<code is:raw>ref</code>) are used for primitive types, and primitives in Javascript pass values by <em>value</em>, so Vue has to wrap them in an object to make them reactive. Since <code is:raw>ref</code> properties are wrapped to make them reactive, they have to be unwrapped down to the <code is:raw>.value</code> to get the value. Read more about this concept in the  <a href="https://github.com/vuejs/composition-api-rfc/blob/master/index.md#computed-state-and-refs">Composition API RFC</a> if this concept is something you want to understand more deeply.</p>\n<p>However, because I\u2019m returning the object <code is:raw>executiveTeam</code> and I want to access the properties <code is:raw>president</code> and <code is:raw>vicePresident</code> on that object in the template, I will have to drill down into the <code is:raw>executiveTeam</code> object to get each property I need:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ executiveTeam.president }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;Vice President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ executiveTeam.vicePresident }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>I cannot destructure the object that I return because if I do, the properties inside <code is:raw>executiveTeam</code> will lose reactivity. I\u2019ll demonstrate this in the next example to make this more clear.</p>\n<p>When using <code is:raw>reactive</code> to give an object\u2019s properties reactivity, like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">executiveTeam</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">  president: </span><span style="color: #A5D6FF">&#39;Mickey Mouse&#39;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">  vicePresident: </span><span style="color: #A5D6FF">&#39;Donald Duck&#39;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>I cannot destructure to try and return those properties by their key, as in:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//LOSES REACTIVITY:</span></span>\n<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> { president, vicePresident } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> executiveTeam</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { president, vicePresident }</span></span></code></pre>\n<p>This is where <code is:raw>toRefs</code> comes in handy.</p>\n<h3 id="torefs">toRefs</h3>\n<p>The helper <code is:raw>toRefs</code> will allow me to turn each of the properties in the object into a <code is:raw>ref</code>, which means I won\u2019t have to use <code is:raw>executiveTeam.president</code> in the template; I\u2019ll be able to just write <code is:raw>president</code>. Here\u2019s the full example now using <code is:raw>toRefs</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> reactive, toRefs </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    const executiveTeam </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">      president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">      vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//toRefs allows me to destructure</span></span>\n<span class="line"><span style="color: #C9D1D9">    let { president, vicePresident } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">toRefs</span><span style="color: #C9D1D9">(executiveTeam);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { president, vicePresident };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span></code></pre>\n<p>Since <code is:raw>toRefs</code> turns each property into a <code is:raw>ref</code>, I need to go back to unwrapping them down to their value using <code is:raw>.value </code>if I want to do something to them in the <code is:raw>setup</code> function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  president.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Goofy&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<h3 id="toref">toRef</h3>\n<p>Just like <code is:raw>toRefs</code>, the helper <code is:raw>toRef</code> is used to turn reactive object properties into reactive references (<code is:raw>ref</code>), but I would use <code is:raw>toRef</code> if I just need to turn one property in a reactive object into a <code is:raw>ref</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">executiveTeam</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>\n<span class="line"><span style="color: #C9D1D9">    president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">  });</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//toRef used to turn just one property into a ref</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> presidentRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">toRef</span><span style="color: #C9D1D9">(executiveTeam, </span><span style="color: #A5D6FF">&quot;president&quot;</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    presidentRef.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;Goofy&quot;</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">  };</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { presidentRef, changePresident };</span></span>\n<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>\n<p>I will have to use <code is:raw>.value</code> if I want to update the ref\u2019s value inside the setup function, but in the template, Vue will unwrap <code is:raw>president</code> for me:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;Company Roles&lt;/</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ presidentRef }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">@click</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;changePresident&quot;</span><span style="color: #C9D1D9">&gt;Change President&lt;/</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>It can be challenging to remember which variables are <code is:raw>reactive</code> properties and which ones are <code is:raw>ref</code>. Something that helps is to use a naming convention where I add the suffix <strong>Ref</strong> to anything that is a <code is:raw>ref</code>, such as <code is:raw>presidentRef</code>. I don\u2019t have a lot of experience with Vue 3 yet, but for the time being, I plan to use that naming convention to see if it helps me get a better handle on the distinction between <code is:raw>ref</code> and <code is:raw>reactive</code> properties.</p>\n<h3 id="isref">isRef</h3>\n<p>Vue 3 also provides the helper <code is:raw>isRef</code> that I can use to check if something is a <code is:raw>ref</code>.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">isRef</span><span style="color: #C9D1D9">(executiveTeam.president)) </span><span style="color: #8B949E">//false</span></span>\n<span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">isRef</span><span style="color: #C9D1D9">(presidentRef)) </span><span style="color: #8B949E">//true</span></span></code></pre>\n<h2 id="my-thoughts-on-the-vue-3-reactivity-api">My Thoughts on the Vue 3 Reactivity API</h2>\n<p>This topic of <code is:raw>ref</code> and <code is:raw>reactive</code> has been the most challenging for me in my goal to learn Vue 3. There is more nuance to how these helpers are used in practice, and it becomes too much for an introduction post to try to cover all the different situations where I might have to make informed decisions about using <code is:raw>ref</code> and/or <code is:raw>reactive</code> and all the other helpers.</p>\n<p>The Vue.js team is aware that this is one of the challenges of Vue 3 - the question of when to use <code is:raw>ref</code> or <code is:raw>reactive</code> does not always receive a simple answer. In the Composition API RFC they state:</p>\n<blockquote>\n<p>Understandably, users may get confused regarding which to use between ref and reactive. First thing to know is that you will need to understand both to efficiently make use of the Composition API. Using one exclusively will most likely lead to esoteric workarounds or reinvented wheels.</p>\n</blockquote>\n<p>I have come across many resources that suggest using just <code is:raw>ref</code> or just <code is:raw>reactive</code> to start. But I think it is worth the effort to learn the nuances of both. I agree with the Vue.js team: it\u2019s better to understand both <code is:raw>ref</code> and <code is:raw>reactive</code> if I\u2019m going to use Vue 3 to its fullest potential. And that\u2019s what I plan to do.</p>\n<p>While using just <code is:raw>ref</code> for primitives and <code is:raw>reactive</code> for objects is one suggested approach (suggested by the Vue.js team <a href="https://github.com/vuejs/composition-api-rfc/blob/master/index.md#ref-vs-reactive">here</a>), I would encourage you to dig deeper into the docs and resources out there to learn more about the Reactivity APIs. For a nuanced feature such as this, it\u2019s important to understand why certain approaches can be taken.</p>\n<h2 id="conclusion">Conclusion</h2>\n<p>Please join me for my next post about reusability in Vue 3, including a discussion of composition functions (i.e. Vue composables). In my opinion, composables are the best thing about this new Composition API and they make it worth putting in the time to learn the harder concepts of Vue 3.</p>\n<p>Please reach out on <a href="https://twitter.com/sandra_rodgers_">Twitter</a> and let me know if you are enjoying this series on Vue 3.</p>';
}
const $$Astro = createAstro("/Users/sandrarodgers/web-next/blog/src/content/blog/posts/diving-into-vue-3-reactivity-api/index.md", "", "file:///Users/sandrarodgers/web-next/blog/");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  new Slugger();
  return renderTemplate`<head>${renderHead($$result)}</head><p>This is the fourth post in my ‘Diving Into Vue 3’ series. Today I hope to give a clear and practical description of how to use the new Reactivity APIs, focusing on <code>ref</code> and <code>reactive</code>. I’ll also introduce how to use related helpers such as <code>toRef</code>, <code>toRefs</code>, and <code>isRef</code>.</p>
<p>The other posts in this series that have already come out are:</p>
<ul>
<li><a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3 - Getting Started</a></li>
<li><a href="https://blog.deepgram.com/diving-into-vue-3-setup-function/">Diving Into Vue 3 - The Setup Function</a></li>
<li><a href="https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/">Diving Into Vue 3: Methods, Watch, and Computed</a></li>
</ul>
<p>But first, a little background on <strong>reactivity</strong>. Feel free to skip ahead to the section on <a href="#how-to-make-data-properties-reactive">how to make data properties reactive</a> if you just want to learn about <code>ref</code> and <code>reactive</code>.</p>
<h2 id="what-is-reactivity">What is reactivity?</h2>
<p>The term <strong>reactivity</strong> in relation to Vue generally refers to a feature where what you see on the screen automatically updates in-sync with any changes to the state. It’s the Vue ‘magic’ that makes the template re-render instantly if a data property changes.</p>
<p>When talking about <strong>reactivity</strong> in JavaScript or in programming in general, the term means programming something to work the way Vue does by implementing a design pattern called the <strong>Observer Pattern</strong>, which is explained in <a href="https://github.com/sohamkamani/javascript-design-patterns-for-humans#-observer">Design Patterns for Humans</a> as :</p>
<blockquote>
<p>whenever an object changes its state, all its dependents are notified.</p>
</blockquote>
<p>Vue automatically updating the DOM when a data property changes is a result of Vue being built using the <strong>Observer Pattern</strong> - Vue state is an object with properties that have dependencies, so if one of those properties changes, its dependents react to the change by updating if they need to, and that triggers the re-render in the browser.</p>
<p>JavaScript on its own is not reactive, as shown in this example:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> numWorkers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">50</span></span>
<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> numManagers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">4</span></span>
<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> totalEmployees </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> numWorkers </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> numManagers</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(totalEmployees) </span><span style="color: #8B949E">// 54</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">numWorkers </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">48</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(totalEmployees) </span><span style="color: #8B949E">// Still 54</span></span></code></pre>
<p>Vue is reactive because the core Vue.js team built it to be. So in the following example, <code>totalEmployees</code> will automatically update anytime <code>numWorkers</code> or <code>numManagers</code> (two properties in the state object) changes:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//returns the state object</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { numWorkers: </span><span style="color: #79C0FF">4</span><span style="color: #C9D1D9">, numManagers: </span><span style="color: #79C0FF">6</span><span style="color: #C9D1D9"> }</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FFA657">computed</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">totalEmployees</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// returns whatever the total is based on current state for numWorkers and numManagers</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numWorkers </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9">  </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numManagers</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>
<h3 id="reactivity-in-vue-2">Reactivity in Vue 2</h3>
<p>The reactivity system in both Vue 2 and Vue 3 is based on state being an object, but there are big differences in how the properties are made reactive.</p>
<p>In Vue 2 the data option returns an object:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      numWorkers: </span><span style="color: #79C0FF">4</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">      numManagers: </span><span style="color: #79C0FF">6</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>
<p>Under the hood, Vue 2 uses <code>Object.defineProperty</code> to define all the data properties on a component instance, converting them to getters and setters. There’s a deep dive into the Vue 2’s reactivity system in the <a href="https://v2.vuejs.org/v2/guide/reactivity.html">Vue.js docs</a> that’s worth spending some time with.</p>
<p>Because defining the properties happens at the time of the component instance’s initialization, it results in some small drawbacks:</p>
<ul>
<li>
<p>data properties cannot be added or deleted after component instance initialization. They have to be present during initialization for them to be reactive</p>
</li>
<li>
<p>If the data property is an array, it is not possible to set an item directly to the array through assignment by using the array index (as in <code>arr[0] = value</code>), and it also isn’t possible to update the length of the array (as in <code>arr.length = 0</code>)</p>
</li>
</ul>
<p>This isn’t a <em>major</em> problem because the <code>Vue.$set</code> method can be used in cases where these updates need to be made after component instance initialization. However, Vue 3’s reactivity system is so improved that now these issues are no longer a problem, making it unnecessary to use <code>Vue.$set</code>.</p>
<h3 id="reactivity-in-vue-3">Reactivity in Vue 3</h3>
<p>Vue 3’s reactivity system had a major rewrite from what it was in Vue 2. The fundamental idea of tracking all the data properties and their dependencies so they can update automatically is still the same, but Vue 3 now uses the JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> API to achieve this (instead of <code>Object.defineProperty</code> like in Vue 2).</p>
<p>There’s a rabbit hole to go down for anyone who wants to learn more about the Vue 3 reactivity system, and the <a href="https://v3.vuejs.org/guide/reactivity.html#how-vue-tracks-these-changes">Vue.js docs</a> are fantastic. Even though I’m not going to explain it all (there’s no way I could!), there are a few things I think are helpful to understand.</p>
<p>The docs state:</p>
<blockquote>
<p>Proxy is an object that encases another object and allows you to intercept any interactions with that object.</p>
</blockquote>
<p>Awareness of reactive properties using proxies is helpful when debugging code in the console. If I <code>console.log</code> a reactive property such as this property <code>company</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">company</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">  employees: [</span><span style="color: #A5D6FF">&#39;Tom&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;Sara&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;Joe&#39;</span><span style="color: #C9D1D9">],</span></span>
<span class="line"><span style="color: #C9D1D9">  managers: [</span><span style="color: #A5D6FF">&#39;Julie&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #A5D6FF">&#39;Jorge&#39;</span><span style="color: #C9D1D9">],</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>in the console, I see:</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1644436537/blog/2022/02/diving-into-vue-3-reactivity-api/console_1.png" alt="A console.log for a reactive property which shows the proxy"></p>
<p>Clicking on it will open the object to show that there is a Handler and a Target. A proxy always contains a Handler and a Target, and since Vue 3 uses proxies, I find it helpful to be comfortable with the shape of this data as a proxy.</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_2.png" alt="Same console.log for a reactive property which shows the proxy, now open to show handler and target"></p>
<p>The Target is where to look for the actual values. It contains the data that I might be looking for. The Handler contains the special logic for making the data properties reactive. The Handler contains methods like <code>get</code> and <code>set</code>.</p>
<p>The Handler is the rabbit hole if you want to learn about reactivity. The Target is where I need to look for my data values.</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1644436562/blog/2022/02/diving-into-vue-3-reactivity-api/console_3.png" alt="Same console.log for a reactive property which shows the proxy, now open to show handler and target with target open to show data values"></p>
<p>Because reactive data is wrapped in a proxy, something to get used to when working with the data is the idea of having to ‘unwrap’ the data object to get to the value. After reading a lot of different resources about working with Vue 3 reactive data, I now feel comfortable with the idea that using strategies to ‘unwrap’ the data, such as destructuring or drilling down to the value property, are using the metaphor of unwrapping because Vue 3 reactive data is wrapped in a <code>Proxy</code> object.</p>
<h2 id="how-to-make-data-properties-reactive">How to make data properties reactive</h2>
<p>As I said earlier, if I want to make data properties reactive in Vue 2, I have to return them in an object inside the data option of the Options API.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">      vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>
<p>If I am using the Vue 3 setup function (see my <a href="https://blog.deepgram.com/diving-into-vue-3-setup-function/">post on the setup function</a> if you need an explainer on that), I can make data reactive by using the <code>reactive</code> or <code>ref</code> helpers.</p>
<h3 id="ref">ref</h3>
<p>For this first example, I will use <code>ref</code>. I’m using <code>ref</code> because <code>"Mickey Mouse"</code> and <code>"Donald Duck"</code> are strings, and the recommendation is to use <code>ref</code> with primitive values (i.e. Javascript types that are not objects, such as strings, numbers, etc.)</p>
<p>First, I import <code>ref</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>Then in the <code>setup</code> function, I set my variable to the <code>ref()</code> helper, which takes in the initial value. I must include the data in the return object if I want it to be available to the template.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> president </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> vicePresident </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { president, vicePresident };</span></span>
<span class="line"><span style="color: #C9D1D9">    },</span></span></code></pre>
<p>An important difference between <code>ref</code> and <code>reactive</code> is that if I want to do something to the value of my <code>ref</code> properties inside the <code>setup</code> function, I have to unwrap the object to access that value. So if I want to change the value of <code>president</code>, I will change <code>president.value</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    president.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Goofy&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span></code></pre>
<p>I don’t have to worry about unwrapping the values for <code>president</code> and <code>vicePresident</code> in the <code>template</code>. Vue can shallow unwrap those for me. ‘Shallow unwrap’ means the first level of properties in an object are available in the template without having to use <code>.value</code> (but nested properties would still need to be unwrapped).</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ president }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;Vice President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ vicePresident }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>FYI, it’s fine not to use <code>ref</code> if I don’t need the data to be reactive, just writing the data like this:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> president </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> vicePresident </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { president, vicePresident };</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>But it would mean the data isn’t reactive, so I can’t ever see updates to the data. If I use a method to change the data, I would never see that update change anything on the screen, and I would have to be happy with Mickey Mouse and Donald Duck showing as president and vice president forever.</p>
<p>There are times when you don’t need the data to be reactive, so in those instances, just don’t use <code>ref</code> or <code>reactive</code>!</p>
<h3 id="reactive">reactive</h3>
<p>I can use <code>reactive</code> for the same example, but I would only do so if I wanted the data to start out in the form of an object rather than separate string values. So in Vue 2, if I have this:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">data</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    executiveTeam: {</span></span>
<span class="line"><span style="color: #C9D1D9">      president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">      vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    },</span></span>
<span class="line"><span style="color: #C9D1D9">  };</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>To change this to Vue 3 using <code>reactive</code>, I will first import <code>reactive</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { reactive } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span></code></pre>
<p>In the <code>setup</code> function, I will create an object for <code>executiveTeam</code> and define the properties on the object. I can set the object to <code>const</code> since the object itself won’t change, just the properties inside.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">executiveTeam</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">    president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">  });</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { executiveTeam };</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>And if I want to update the data, I do not have to unwrap it with <code>.value </code>like I do with <code>ref</code>.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  executiveTeam.president </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Goofy&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>This is because <code>reactive</code> is used with objects, and objects pass values by <em>reference</em> (which lends itself better to reactivity). Reactive references (<code>ref</code>) are used for primitive types, and primitives in Javascript pass values by <em>value</em>, so Vue has to wrap them in an object to make them reactive. Since <code>ref</code> properties are wrapped to make them reactive, they have to be unwrapped down to the <code>.value</code> to get the value. Read more about this concept in the  <a href="https://github.com/vuejs/composition-api-rfc/blob/master/index.md#computed-state-and-refs">Composition API RFC</a> if this concept is something you want to understand more deeply.</p>
<p>However, because I’m returning the object <code>executiveTeam</code> and I want to access the properties <code>president</code> and <code>vicePresident</code> on that object in the template, I will have to drill down into the <code>executiveTeam</code> object to get each property I need:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ executiveTeam.president }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;Vice President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ executiveTeam.vicePresident }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>I cannot destructure the object that I return because if I do, the properties inside <code>executiveTeam</code> will lose reactivity. I’ll demonstrate this in the next example to make this more clear.</p>
<p>When using <code>reactive</code> to give an object’s properties reactivity, like this:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">executiveTeam</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">  president: </span><span style="color: #A5D6FF">&#39;Mickey Mouse&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">  vicePresident: </span><span style="color: #A5D6FF">&#39;Donald Duck&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>I cannot destructure to try and return those properties by their key, as in:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//LOSES REACTIVITY:</span></span>
<span class="line"><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> { president, vicePresident } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> executiveTeam</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { president, vicePresident }</span></span></code></pre>
<p>This is where <code>toRefs</code> comes in handy.</p>
<h3 id="torefs">toRefs</h3>
<p>The helper <code>toRefs</code> will allow me to turn each of the properties in the object into a <code>ref</code>, which means I won’t have to use <code>executiveTeam.president</code> in the template; I’ll be able to just write <code>president</code>. Here’s the full example now using <code>toRefs</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> reactive, toRefs </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    const executiveTeam </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">      president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">      vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    });</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//toRefs allows me to destructure</span></span>
<span class="line"><span style="color: #C9D1D9">    let { president, vicePresident } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">toRefs</span><span style="color: #C9D1D9">(executiveTeam);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    return { president, vicePresident };</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"></span></code></pre>
<p>Since <code>toRefs</code> turns each property into a <code>ref</code>, I need to go back to unwrapping them down to their value using <code>.value </code>if I want to do something to them in the <code>setup</code> function:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  president.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Goofy&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<h3 id="toref">toRef</h3>
<p>Just like <code>toRefs</code>, the helper <code>toRef</code> is used to turn reactive object properties into reactive references (<code>ref</code>), but I would use <code>toRef</code> if I just need to turn one property in a reactive object into a <code>ref</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">executiveTeam</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">reactive</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">    president: </span><span style="color: #A5D6FF">&quot;Mickey Mouse&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    vicePresident: </span><span style="color: #A5D6FF">&quot;Donald Duck&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">  });</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//toRef used to turn just one property into a ref</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> presidentRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">toRef</span><span style="color: #C9D1D9">(executiveTeam, </span><span style="color: #A5D6FF">&quot;president&quot;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">changePresident</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    presidentRef.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;Goofy&quot;</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">  };</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { presidentRef, changePresident };</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>I will have to use <code>.value</code> if I want to update the ref’s value inside the setup function, but in the template, Vue will unwrap <code>president</code> for me:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;Company Roles&lt;/</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;&lt;</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt;President:&lt;/</span><span style="color: #7EE787">b</span><span style="color: #C9D1D9">&gt; {{ presidentRef }}&lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">@click</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;changePresident&quot;</span><span style="color: #C9D1D9">&gt;Change President&lt;/</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>It can be challenging to remember which variables are <code>reactive</code> properties and which ones are <code>ref</code>. Something that helps is to use a naming convention where I add the suffix <strong>Ref</strong> to anything that is a <code>ref</code>, such as <code>presidentRef</code>. I don’t have a lot of experience with Vue 3 yet, but for the time being, I plan to use that naming convention to see if it helps me get a better handle on the distinction between <code>ref</code> and <code>reactive</code> properties.</p>
<h3 id="isref">isRef</h3>
<p>Vue 3 also provides the helper <code>isRef</code> that I can use to check if something is a <code>ref</code>.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">isRef</span><span style="color: #C9D1D9">(executiveTeam.president)) </span><span style="color: #8B949E">//false</span></span>
<span class="line"><span style="color: #C9D1D9">console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">isRef</span><span style="color: #C9D1D9">(presidentRef)) </span><span style="color: #8B949E">//true</span></span></code></pre>
<h2 id="my-thoughts-on-the-vue-3-reactivity-api">My Thoughts on the Vue 3 Reactivity API</h2>
<p>This topic of <code>ref</code> and <code>reactive</code> has been the most challenging for me in my goal to learn Vue 3. There is more nuance to how these helpers are used in practice, and it becomes too much for an introduction post to try to cover all the different situations where I might have to make informed decisions about using <code>ref</code> and/or <code>reactive</code> and all the other helpers.</p>
<p>The Vue.js team is aware that this is one of the challenges of Vue 3 - the question of when to use <code>ref</code> or <code>reactive</code> does not always receive a simple answer. In the Composition API RFC they state:</p>
<blockquote>
<p>Understandably, users may get confused regarding which to use between ref and reactive. First thing to know is that you will need to understand both to efficiently make use of the Composition API. Using one exclusively will most likely lead to esoteric workarounds or reinvented wheels.</p>
</blockquote>
<p>I have come across many resources that suggest using just <code>ref</code> or just <code>reactive</code> to start. But I think it is worth the effort to learn the nuances of both. I agree with the Vue.js team: it’s better to understand both <code>ref</code> and <code>reactive</code> if I’m going to use Vue 3 to its fullest potential. And that’s what I plan to do.</p>
<p>While using just <code>ref</code> for primitives and <code>reactive</code> for objects is one suggested approach (suggested by the Vue.js team <a href="https://github.com/vuejs/composition-api-rfc/blob/master/index.md#ref-vs-reactive">here</a>), I would encourage you to dig deeper into the docs and resources out there to learn more about the Reactivity APIs. For a nuanced feature such as this, it’s important to understand why certain approaches can be taken.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Please join me for my next post about reusability in Vue 3, including a discussion of composition functions (i.e. Vue composables). In my opinion, composables are the best thing about this new Composition API and they make it worth putting in the time to learn the harder concepts of Vue 3.</p>
<p>Please reach out on <a href="https://twitter.com/sandra_rodgers_">Twitter</a> and let me know if you are enjoying this series on Vue 3.</p>`;
});

export { compiledContent, $$Index as default, frontmatter, metadata, rawContent };
