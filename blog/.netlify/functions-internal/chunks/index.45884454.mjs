import { c as createAstro, a as createComponent, r as renderTemplate, b as renderHead, d as renderComponent } from '../entry.mjs';
import Slugger from 'github-slugger';
import '@astrojs/netlify/netlify-functions.js';
import 'preact';
import 'preact-render-to-string';
import 'vue';
import 'vue/server-renderer';
import 'html-escaper';
import 'node-html-parser';
import 'axios';
/* empty css                           *//* empty css                           *//* empty css                           *//* empty css                           *//* empty css                          */import 'clone-deep';
import 'slugify';
import 'shiki';
/* empty css                           */import '@astrojs/rss';
/* empty css                           */import 'mime';
import 'cookie';
import 'kleur/colors';
import 'string-width';
import 'path-browserify';
import 'path-to-regexp';

const metadata = { "headings": [{ "depth": 2, "slug": "introduction", "text": "Introduction" }, { "depth": 2, "slug": "methods", "text": "Methods" }, { "depth": 3, "slug": "composables", "text": "Composables" }, { "depth": 2, "slug": "watch", "text": "Watch" }, { "depth": 3, "slug": "watcheffect", "text": "watchEffect" }, { "depth": 2, "slug": "computed", "text": "Computed" }, { "depth": 2, "slug": "putting-it-all-together", "text": "Putting It All Together" }, { "depth": 2, "slug": "conclusion", "text": "Conclusion" }], "source": "\r\nIn this series, I'm focusing on the basics needed to start working in **Vue 3** for people who might have some experience in **Vue 2**, but who haven't yet built anything in **Vue 3**.\r\n\r\nCheck out my previous posts in the series:\r\n\r\n1.  [Diving Into Vue 3: Getting Started](https://blog.deepgram.com/diving-into-vue-3-getting-started/)\r\n\r\n2.  [Diving Into Vue 3: The Setup Function]()\r\n\r\nToday, I'll introduce how to use `methods`, `watch`, and `computed` in **Vue 3**, and I'll also give a general comparison of `watch` and the new `watchEffect`.\r\n\r\n## Introduction\r\n\r\nThe way I learn best is by connecting abstract concepts to a real world situation, so I tried to think of a simple, realistic situation for using `methods`, `watch`, and `computed`. The situation would need to demonstrate the following:\r\n\r\n*   doing something to data properties to change them (using `methods`)\r\n*   making something else occur (i.e, a side effect) because of a change to the data properties (using `watch`)\r\n*   returning a value that is calculated based on data properties that have been changed (`computed`)\r\n\r\nI will use a real-world example of a company with employees and managers; the logic will help keep track of *number of employees*, *number of managers*, and *total company headcount*. Not the most exciting example, but I really just want to keep it simple.\r\n\r\n## Methods\r\n\r\nOne of the first things I need to be able to do, whether I'm using **Vue 2** or **Vue 3**, is be able to make stuff happen with methods/functions (note: I'm using the terms *functions* and *methods* interchangeably in this section). The magic of Vue is its reactivity, so local state updates automatically as stuff happens. The stuff that happens is often triggered by *methods*.\r\n\r\nIn my real-world example, I want to create a component that has a variable to represent the **number of employees** with buttons I click to **add or subtract the number of employees**, changing the **headcount**. I'll write functions to perform these basic actions.\r\n\r\nHere's what the rendered component looks like:\r\n\r\n![Rendered component to that uses method to increment and decrement](https://res.cloudinary.com/deepgram/image/upload/v1643663337/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/component-methods.png)\r\n\r\nI am familiar with the **Vue 2** way of adding functions to the component: add each function to the `methods` object:\r\n\r\n```html\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      numEmployees: 10,\r\n    };\r\n  },\r\n  methods: {\r\n    addEmployees() {\r\n      this.numEmployees++;\r\n    },\r\n    subtractEmployees() {\r\n      this.numEmployees--;\r\n    },\r\n  },\r\n};\r\n<\/script>\r\n```\r\n\r\nAnd the following line from the `template` shows that **Vue 2** and **Vue 3** are no different in how the methods are invoked in the `template`:\r\n\r\n```js\r\n<button @click=\"addToEmployees()\">+</button>\r\n```\r\n\r\nHowever, **Vue 3** is different now in regards to where we write the methods in the `script`. In **Vue 3**, I can now write my functions *inside* the `setup` function, which runs very early in the component lifecycle (before the component instance is even created). I no longer have to write all my functions in the `methods` property of the options API.\r\n\r\nIn this example, I have written two basic functions, and those functions are not separated into a separate methods block like in **Vue 2**, they are inside `setup` with the related logic like the variable for `numEmployees`. I can make the functions available to the template by returning an object that includes them:\r\n\r\n```js\r\n<script>\r\nimport { ref } from \"vue\";\r\nexport default {\r\n  setup() {\r\n    let numEmployees = ref(10);\r\n    function addEmployees() {\r\n      numEmployees.value++;\r\n    }\r\n    function subtractEmployees() {\r\n      numEmployees.value--;\r\n    }\r\n    return { numEmployees, addEmployees, subtractEmployees };\r\n  },\r\n};\r\n<\/script>\r\n```\r\n\r\nNotice that there is no keyword `this` when referring to `numEmployees`. Methods that are inside the `setup` function no longer use the keyword `this` to refer to properties on the component instance since `setup` runs before the component instance is even created. I was very used to writing `this`-dot everything in **Vue 2**, but that is no longer the experience in **Vue 3**.\r\n\r\nThe use of `ref()` surrounding the data property is something I introduced in the last post, and it's important here. For reactivity to work in Vue, the data being tracked needs to be wrapped in an object, which is why in **Vue 2**, the `data` method in the options API returned an object with those reactive data properties.\r\n\r\nNow, **Vue 3** uses `ref` to wrap primitive data in an object and `reactive` to make a copy of non-primitive data (I've only introduced `ref` so far in this series). This is important to methods because it helps me understand why I see `numEmployees.value` inside the function rather than just `numEmployees`. I have to use `.value` to reach the property inside the object created by `ref` and then perform the action on that value property. (I don't have to use the `.value` property in the template, however. Just writing `numEmployees` grabs the value).\r\n\r\nWriting all the methods inside the setup function may seem like it would get messy when there is more complexity going on in the component, but in practice, **related logic could all be grouped together to run within its own function**. This is where **Vue 3** starts to show its strengths. I could group all the logic for updating headcount into a function called `updateHeadcount`, then create a separate JS file where that logic lives. I'll actually name it `useUpdateHeadcount.js`, which is **Vue 3** best-practice for naming this type of file (the convention of starting composables with *use* is discussed in the Composition API RFC in [this section](https://github.com/vuejs/composition-api-rfc/blob/master/index.md#logical-concerns-vs-option-types)). Here's the `useUpdateHeadcount.js` file:\r\n\r\n```js\r\nimport { ref } from 'vue'\r\n\r\nexport default function useUpdateHeadcount() {\r\n  let numEmployees = ref(10)\r\n  function addToEmployees() {\r\n    numEmployees.value++\r\n  }\r\n  function subtractFromEmployees() {\r\n    numEmployees.value--\r\n  }\r\n\r\n  return { numEmployees, addToEmployees, subtractFromEmployees }\r\n}\r\n```\r\n\r\nNow, in my component, I just have to write this in the setup function:\r\n\r\n```js\r\n<script>\r\nimport useUpdateHeadcount from \"../composables/useUpdateHeadcount\";\r\nexport default {\r\n  setup() {\r\n\r\n    const { numEmployees, addToEmployees, subtractFromEmployees } =\r\n      useUpdateHeadcount();\r\n\r\n    return { numEmployees, addToEmployees, subtractFromEmployees };\r\n  },\r\n};\r\n<\/script>\r\n\r\n```\r\n\r\n### Composables\r\n\r\nNotice that I imported the `useUpdateHeadcount` file from a folder called *composables*. That's because these *functions to separate out logic by shared concerns* are known as **composables** in the **Vue 3** world. I'm not going to go over all the details of how I wrote the composable and brought it back into the component file because I'll be doing a later blog post in the series about composables. In fact, I don't even have to use a composable; I can just write all my logic in the setup function since it's a very simple component. But I wanted to also make it clear that as the component gets more complicated, there is a strategy for organizing the logic, and it's one of **Vue 3**'s most exciting features.\r\n\r\n## Watch\r\n\r\n`watch` is basically the same in **Vue 3**, so I am happy to know that I can use it as I have before. In my example, I want to track the value of `numEmployees` to make sure it doesn't go below zero, since it's not possible to have negative human beings as employees.\r\n\r\nHere's my rendered component. It looks the same, but I added a disclaimer that the headcount cannot go below zero.\r\n\r\n![Component for adding or subtracting employees but restricted to not go below zero](https://res.cloudinary.com/deepgram/image/upload/v1643663535/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watch-headcount.png)\r\n\r\nThis restriction - not going below zero - will be managed by the logic in `watch`:\r\n\r\n```js\r\nwatch(numEmployees, () => {\r\n  if (numEmployees.value < 0) {\r\n    numEmployees.value = 0\r\n  }\r\n})\r\n```\r\n\r\nI specify which data property to track (`numEmployees`) as the first argument, and a *callback* as the second argument. Inside the callback, I have my logic that causes the side effect. If `numEmployees` reaches below zero, that side effect happens, setting the value to zero. The callback makes sure the side effect happens on the next tick following the value reaching below zero.\r\n\r\n`watch` will not be triggered until that specific reactive property is changed, so if I want it to run immediately when the component is created, I can add an object with `immediate: true` like this:\r\n\r\n```js\r\nwatch(\r\n  employees,\r\n  (newVal, oldVal) => {\r\n    if (employees.value < 0) {\r\n      employees.value = 0\r\n    }\r\n  },\r\n  { immediate: true }\r\n)\r\n```\r\n\r\nThe callback argument can also take two arguments for the **new value** and the **old value**, which makes `watch` useful for doing logic based on the previous state of the reactive property or just checking if a property has been changed (i.e. it's a great debugging tool):\r\n\r\n```js\r\nwatch(employees, (newVal, oldVal) => {\r\n  console.log(oldVal, newVal)\r\n})\r\n```\r\n\r\nAs for comparing `watch` in **Vue 2** versus **Vue 3**, the only difference is that in Vue 3 I can now place `watch` inside the setup function. Like methods, it no longer has to be separated out into its own section as an option property on the component instance.\r\n\r\nHowever, **Vue 3** also has added a similar feature that gives some different capabilities from `watch`: it's called `watchEffect`.\r\n\r\n### watchEffect\r\n\r\nVue 3 keeps `watch` the same, but it adds `watchEffect` as another way to cause side effects based on what happens to the reactive properties. Both `watch` and `watchEffect` are useful in different situations; one isn't better than the other.\r\n\r\nIn this example, I will add another reactive property to the component - managers (`numManagers`). I want to track both managers and employees, and I want to restrict their values going below zero. Here is the component now:\r\n\r\n![Component for adding or subtracting employees and manager but restricted to not go below zero](https://res.cloudinary.com/deepgram/image/upload/v1643663591/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watchEffect-headcount.png)\r\n\r\nThe reason I added a second reactive property is because `watchEffect` makes it easier to track multiple reactive properties. I no longer have to specify each property I want to track as the first argument of watch. Notice that I don't have a first argument to name the properties I'm tracking:\r\n\r\n```js\r\nwatchEffect(() => {\r\n  if (numEmployees.value < 0) {\r\n    numEmployees.value = 0\r\n  }\r\n  if (numManagers.value < 0) {\r\n    numManagers.value = 0\r\n  }\r\n})\r\n```\r\n\r\nUnlike `watch`, `watchEffect` is not lazy loaded, so it will trigger automatically when the component is created. No need to add the object with `immediate: true`.\r\n\r\n`watchEffect` is useful when I want to track changes to whatever property I want, and when I want the tracking to happen immediately.\r\n\r\n`watch` is useful when I want to be more specific about tracking just one property, or if I want to have access to the new value and/or old value to use them in my logic.\r\n\r\nIt's great having both features!\r\n\r\n## Computed\r\n\r\nOne of the nice things about the Vue `template` is that I can write logic within double curly-braces, and that logic will be calculated based on whatever the values are represented by each variable:\r\n\r\n```html\r\n<h2>Headcount: {{ numEmployees + numManagers }}</h2>\r\n```\r\n\r\nThis will show a number which has been calculated, or *computed*, based on what `numEmployees` and `numManagers` are at the current point of time. And it will change if either of those data for `numEmployees` or `numManagers` change.\r\n\r\nSometimes, the logic can get complicated or long. That's when I write a `computed` property in the `script` section, and refer to it in the template. Here is how I would do that in Vue 2:\r\n\r\n```js\r\n\r\n<script>\r\n export default {\r\n  computed: {\r\n    headcount() {\r\n      return this.employees.value + this.managers.value;\r\n    },\r\n  },\r\n}\r\n<\/script>\r\n\r\n```\r\n\r\nThe computed property is another option that is part of the options API, and in **Vue 2**, it sits at the same level as `methods`, `data`, `watch`, and lifecycle methods like `mounted`.\r\n\r\nIn **Vue 3**, computed can now be used in the `setup` function (I bet you didn't see that one coming). I have to import `computed` from Vue like this:\r\n\r\n```js\r\nimport { computed } from 'vue'\r\n```\r\n\r\nTo compute the number of employees and the number of managers, giving me the total headcount, I could write a computed like this:\r\n\r\n```js\r\nconst headcount = computed(() => {\r\n  return numEmployees.value + numManagers.value\r\n})\r\n```\r\n\r\nThe only difference is that now I pass into the computed method an anonymous function, and I set it to the constant for headcount. I also have to return headcount from the setup function, along with everything else I want to be able to access from the template.\r\n\r\n```js\r\nreturn {\r\n  numEmployees,\r\n  numManagers,\r\n  addToEmployees,\r\n  subtractFromEmployees,\r\n  addToManagers,\r\n  subtractFromManagers,\r\n  headcount, //<----\r\n}\r\n```\r\n\r\n## Putting It All Together\r\n\r\nAt this point, I have logic that does the following:\r\n\r\n*   Adds or subtracts to the number of employees (numEmployees) or to the number of managers (numManagers)\r\n*   Makes sure employees and managers do not go below zero\r\n*   Computes the total headcount based on any changes\r\n\r\n<div>\r\n<CodeEmbed height=\"670\" src=\"https://codepen.io/sandrarodgers/embed/ZEaQRLR\"/>\r\n</div>\r\n\r\n## Conclusion\r\n\r\nAnd that wraps up this post in the series. Stay tuned for upcoming posts that cover topics like `ref` and `reactive`, `composables`, and the new `v-model`. And as always, feel free to reach out on [Twitter](https://twitter.com/sandra_rodgers_)!\r\n\r\n        ", "html": '<p>In this series, I\u2019m focusing on the basics needed to start working in <strong>Vue 3</strong> for people who might have some experience in <strong>Vue 2</strong>, but who haven\u2019t yet built anything in <strong>Vue 3</strong>.</p>\n<p>Check out my previous posts in the series:</p>\n<ol>\n<li>\n<p><a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3: Getting Started</a></p>\n</li>\n<li>\n<p><a href="">Diving Into Vue 3: The Setup Function</a></p>\n</li>\n</ol>\n<p>Today, I\u2019ll introduce how to use <code is:raw>methods</code>, <code is:raw>watch</code>, and <code is:raw>computed</code> in <strong>Vue 3</strong>, and I\u2019ll also give a general comparison of <code is:raw>watch</code> and the new <code is:raw>watchEffect</code>.</p>\n<h2 id="introduction">Introduction</h2>\n<p>The way I learn best is by connecting abstract concepts to a real world situation, so I tried to think of a simple, realistic situation for using <code is:raw>methods</code>, <code is:raw>watch</code>, and <code is:raw>computed</code>. The situation would need to demonstrate the following:</p>\n<ul>\n<li>doing something to data properties to change them (using <code is:raw>methods</code>)</li>\n<li>making something else occur (i.e, a side effect) because of a change to the data properties (using <code is:raw>watch</code>)</li>\n<li>returning a value that is calculated based on data properties that have been changed (<code is:raw>computed</code>)</li>\n</ul>\n<p>I will use a real-world example of a company with employees and managers; the logic will help keep track of <em>number of employees</em>, <em>number of managers</em>, and <em>total company headcount</em>. Not the most exciting example, but I really just want to keep it simple.</p>\n<h2 id="methods">Methods</h2>\n<p>One of the first things I need to be able to do, whether I\u2019m using <strong>Vue 2</strong> or <strong>Vue 3</strong>, is be able to make stuff happen with methods/functions (note: I\u2019m using the terms <em>functions</em> and <em>methods</em> interchangeably in this section). The magic of Vue is its reactivity, so local state updates automatically as stuff happens. The stuff that happens is often triggered by <em>methods</em>.</p>\n<p>In my real-world example, I want to create a component that has a variable to represent the <strong>number of employees</strong> with buttons I click to <strong>add or subtract the number of employees</strong>, changing the <strong>headcount</strong>. I\u2019ll write functions to perform these basic actions.</p>\n<p>Here\u2019s what the rendered component looks like:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1643663337/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/component-methods.png" alt="Rendered component to that uses method to increment and decrement"></p>\n<p>I am familiar with the <strong>Vue 2</strong> way of adding functions to the component: add each function to the <code is:raw>methods</code> object:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> {</span></span>\n<span class="line"><span style="color: #FFA657">  </span><span style="color: #D2A8FF">data</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      numEmployees: </span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    };</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span><span style="color: #FFA657">,</span></span>\n<span class="line"><span style="color: #FFA657">  </span><span style="color: #C9D1D9">methods: {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">addEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numEmployees</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">subtractEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numEmployees</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span><span style="color: #FFA657">,</span></span>\n<span class="line"><span style="color: #FFA657">}</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>And the following line from the <code is:raw>template</code> shows that <strong>Vue 2</strong> and <strong>Vue 3</strong> are no different in how the methods are invoked in the <code is:raw>template</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9"> </span><span style="color: #FFA198">@click=&quot;addToEmployees()&quot;&gt;+&lt;/button&gt;</span></span></code></pre>\n<p>However, <strong>Vue 3</strong> is different now in regards to where we write the methods in the <code is:raw>script</code>. In <strong>Vue 3</strong>, I can now write my functions <em>inside</em> the <code is:raw>setup</code> function, which runs very early in the component lifecycle (before the component instance is even created). I no longer have to write all my functions in the <code is:raw>methods</code> property of the options API.</p>\n<p>In this example, I have written two basic functions, and those functions are not separated into a separate methods block like in <strong>Vue 2</strong>, they are inside <code is:raw>setup</code> with the related logic like the variable for <code is:raw>numEmployees</code>. I can make the functions available to the template by returning an object that includes them:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let numEmployees </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    function </span><span style="color: #D2A8FF">addEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      numEmployees.value</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    function </span><span style="color: #D2A8FF">subtractEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      numEmployees.value</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    return { numEmployees, addEmployees, subtractEmployees };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>Notice that there is no keyword <code is:raw>this</code> when referring to <code is:raw>numEmployees</code>. Methods that are inside the <code is:raw>setup</code> function no longer use the keyword <code is:raw>this</code> to refer to properties on the component instance since <code is:raw>setup</code> runs before the component instance is even created. I was very used to writing <code is:raw>this</code>-dot everything in <strong>Vue 2</strong>, but that is no longer the experience in <strong>Vue 3</strong>.</p>\n<p>The use of <code is:raw>ref()</code> surrounding the data property is something I introduced in the last post, and it\u2019s important here. For reactivity to work in Vue, the data being tracked needs to be wrapped in an object, which is why in <strong>Vue 2</strong>, the <code is:raw>data</code> method in the options API returned an object with those reactive data properties.</p>\n<p>Now, <strong>Vue 3</strong> uses <code is:raw>ref</code> to wrap primitive data in an object and <code is:raw>reactive</code> to make a copy of non-primitive data (I\u2019ve only introduced <code is:raw>ref</code> so far in this series). This is important to methods because it helps me understand why I see <code is:raw>numEmployees.value</code> inside the function rather than just <code is:raw>numEmployees</code>. I have to use <code is:raw>.value</code> to reach the property inside the object created by <code is:raw>ref</code> and then perform the action on that value property. (I don\u2019t have to use the <code is:raw>.value</code> property in the template, however. Just writing <code is:raw>numEmployees</code> grabs the value).</p>\n<p>Writing all the methods inside the setup function may seem like it would get messy when there is more complexity going on in the component, but in practice, <strong>related logic could all be grouped together to run within its own function</strong>. This is where <strong>Vue 3</strong> starts to show its strengths. I could group all the logic for updating headcount into a function called <code is:raw>updateHeadcount</code>, then create a separate JS file where that logic lives. I\u2019ll actually name it <code is:raw>useUpdateHeadcount.js</code>, which is <strong>Vue 3</strong> best-practice for naming this type of file (the convention of starting composables with <em>use</em> is discussed in the Composition API RFC in <a href="https://github.com/vuejs/composition-api-rfc/blob/master/index.md#logical-concerns-vs-option-types">this section</a>). Here\u2019s the <code is:raw>useUpdateHeadcount.js</code> file:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useUpdateHeadcount</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> numEmployees </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">addToEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numEmployees.value</span><span style="color: #FF7B72">++</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">subtractFromEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numEmployees.value</span><span style="color: #FF7B72">--</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { numEmployees, addToEmployees, subtractFromEmployees }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now, in my component, I just have to write this in the setup function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useUpdateHeadcount from &quot;../composables/useUpdateHeadcount&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    const { numEmployees, addToEmployees, subtractFromEmployees } </span><span style="color: #FF7B72">=</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">useUpdateHeadcount</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { numEmployees, addToEmployees, subtractFromEmployees };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span></code></pre>\n<h3 id="composables">Composables</h3>\n<p>Notice that I imported the <code is:raw>useUpdateHeadcount</code> file from a folder called <em>composables</em>. That\u2019s because these <em>functions to separate out logic by shared concerns</em> are known as <strong>composables</strong> in the <strong>Vue 3</strong> world. I\u2019m not going to go over all the details of how I wrote the composable and brought it back into the component file because I\u2019ll be doing a later blog post in the series about composables. In fact, I don\u2019t even have to use a composable; I can just write all my logic in the setup function since it\u2019s a very simple component. But I wanted to also make it clear that as the component gets more complicated, there is a strategy for organizing the logic, and it\u2019s one of <strong>Vue 3</strong>\u2019s most exciting features.</p>\n<h2 id="watch">Watch</h2>\n<p><code is:raw>watch</code> is basically the same in <strong>Vue 3</strong>, so I am happy to know that I can use it as I have before. In my example, I want to track the value of <code is:raw>numEmployees</code> to make sure it doesn\u2019t go below zero, since it\u2019s not possible to have negative human beings as employees.</p>\n<p>Here\u2019s my rendered component. It looks the same, but I added a disclaimer that the headcount cannot go below zero.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1643663535/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watch-headcount.png" alt="Component for adding or subtracting employees but restricted to not go below zero"></p>\n<p>This restriction - not going below zero - will be managed by the logic in <code is:raw>watch</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(numEmployees, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (numEmployees.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numEmployees.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>I specify which data property to track (<code is:raw>numEmployees</code>) as the first argument, and a <em>callback</em> as the second argument. Inside the callback, I have my logic that causes the side effect. If <code is:raw>numEmployees</code> reaches below zero, that side effect happens, setting the value to zero. The callback makes sure the side effect happens on the next tick following the value reaching below zero.</p>\n<p><code is:raw>watch</code> will not be triggered until that specific reactive property is changed, so if I want it to run immediately when the component is created, I can add an object with <code is:raw>immediate: true</code> like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(</span></span>\n<span class="line"><span style="color: #C9D1D9">  employees,</span></span>\n<span class="line"><span style="color: #C9D1D9">  (</span><span style="color: #FFA657">newVal</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">oldVal</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (employees.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      employees.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span>\n<span class="line"><span style="color: #C9D1D9">  { immediate: </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9"> }</span></span>\n<span class="line"><span style="color: #C9D1D9">)</span></span></code></pre>\n<p>The callback argument can also take two arguments for the <strong>new value</strong> and the <strong>old value</strong>, which makes <code is:raw>watch</code> useful for doing logic based on the previous state of the reactive property or just checking if a property has been changed (i.e. it\u2019s a great debugging tool):</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(employees, (</span><span style="color: #FFA657">newVal</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">oldVal</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(oldVal, newVal)</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>As for comparing <code is:raw>watch</code> in <strong>Vue 2</strong> versus <strong>Vue 3</strong>, the only difference is that in Vue 3 I can now place <code is:raw>watch</code> inside the setup function. Like methods, it no longer has to be separated out into its own section as an option property on the component instance.</p>\n<p>However, <strong>Vue 3</strong> also has added a similar feature that gives some different capabilities from <code is:raw>watch</code>: it\u2019s called <code is:raw>watchEffect</code>.</p>\n<h3 id="watcheffect">watchEffect</h3>\n<p>Vue 3 keeps <code is:raw>watch</code> the same, but it adds <code is:raw>watchEffect</code> as another way to cause side effects based on what happens to the reactive properties. Both <code is:raw>watch</code> and <code is:raw>watchEffect</code> are useful in different situations; one isn\u2019t better than the other.</p>\n<p>In this example, I will add another reactive property to the component - managers (<code is:raw>numManagers</code>). I want to track both managers and employees, and I want to restrict their values going below zero. Here is the component now:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1643663591/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watchEffect-headcount.png" alt="Component for adding or subtracting employees and manager but restricted to not go below zero"></p>\n<p>The reason I added a second reactive property is because <code is:raw>watchEffect</code> makes it easier to track multiple reactive properties. I no longer have to specify each property I want to track as the first argument of watch. Notice that I don\u2019t have a first argument to name the properties I\u2019m tracking:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watchEffect</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (numEmployees.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numEmployees.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (numManagers.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numManagers.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>Unlike <code is:raw>watch</code>, <code is:raw>watchEffect</code> is not lazy loaded, so it will trigger automatically when the component is created. No need to add the object with <code is:raw>immediate: true</code>.</p>\n<p><code is:raw>watchEffect</code> is useful when I want to track changes to whatever property I want, and when I want the tracking to happen immediately.</p>\n<p><code is:raw>watch</code> is useful when I want to be more specific about tracking just one property, or if I want to have access to the new value and/or old value to use them in my logic.</p>\n<p>It\u2019s great having both features!</p>\n<h2 id="computed">Computed</h2>\n<p>One of the nice things about the Vue <code is:raw>template</code> is that I can write logic within double curly-braces, and that logic will be calculated based on whatever the values are represented by each variable:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">h2</span><span style="color: #C9D1D9">&gt;Headcount: {{ numEmployees + numManagers }}&lt;/</span><span style="color: #7EE787">h2</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>This will show a number which has been calculated, or <em>computed</em>, based on what <code is:raw>numEmployees</code> and <code is:raw>numManagers</code> are at the current point of time. And it will change if either of those data for <code is:raw>numEmployees</code> or <code is:raw>numManagers</code> change.</p>\n<p>Sometimes, the logic can get complicated or long. That\u2019s when I write a <code is:raw>computed</code> property in the <code is:raw>script</code> section, and refer to it in the template. Here is how I would do that in Vue 2:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9"> export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  computed: {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">headcount</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.employees.value </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.managers.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span>\n<span class="line"><span style="color: #FF7B72">}</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span></code></pre>\n<p>The computed property is another option that is part of the options API, and in <strong>Vue 2</strong>, it sits at the same level as <code is:raw>methods</code>, <code is:raw>data</code>, <code is:raw>watch</code>, and lifecycle methods like <code is:raw>mounted</code>.</p>\n<p>In <strong>Vue 3</strong>, computed can now be used in the <code is:raw>setup</code> function (I bet you didn\u2019t see that one coming). I have to import <code is:raw>computed</code> from Vue like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { computed } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span></code></pre>\n<p>To compute the number of employees and the number of managers, giving me the total headcount, I could write a computed like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">headcount</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">computed</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> numEmployees.value </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> numManagers.value</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>The only difference is that now I pass into the computed method an anonymous function, and I set it to the constant for headcount. I also have to return headcount from the setup function, along with everything else I want to be able to access from the template.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  numEmployees,</span></span>\n<span class="line"><span style="color: #C9D1D9">  numManagers,</span></span>\n<span class="line"><span style="color: #C9D1D9">  addToEmployees,</span></span>\n<span class="line"><span style="color: #C9D1D9">  subtractFromEmployees,</span></span>\n<span class="line"><span style="color: #C9D1D9">  addToManagers,</span></span>\n<span class="line"><span style="color: #C9D1D9">  subtractFromManagers,</span></span>\n<span class="line"><span style="color: #C9D1D9">  headcount, </span><span style="color: #8B949E">//&lt;----</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<h2 id="putting-it-all-together">Putting It All Together</h2>\n<p>At this point, I have logic that does the following:</p>\n<ul>\n<li>Adds or subtracts to the number of employees (numEmployees) or to the number of managers (numManagers)</li>\n<li>Makes sure employees and managers do not go below zero</li>\n<li>Computes the total headcount based on any changes</li>\n</ul>\n<div><CodeEmbed height="670" src="https://codepen.io/sandrarodgers/embed/ZEaQRLR" /></div>\n<h2 id="conclusion">Conclusion</h2>\n<p>And that wraps up this post in the series. Stay tuned for upcoming posts that cover topics like <code is:raw>ref</code> and <code is:raw>reactive</code>, <code is:raw>composables</code>, and the new <code is:raw>v-model</code>. And as always, feel free to reach out on <a href="https://twitter.com/sandra_rodgers_">Twitter</a>!</p>' };
const frontmatter = { "title": "Diving Into Vue 3 - Methods, Watch, and Computed", "description": "Learn about the basic features of methods, watch, and computed in Vue 3.", "date": "2022-02-11T00:00:00.000Z", "cover": "https://res.cloudinary.com/deepgram/image/upload/v1643663009/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/dive-into-vue-3%402x.jpg", "authors": ["sandra-rodgers"], "category": "tutorial", "tags": ["vuejs", "javascript"], "seo": { "title": "Diving Into Vue 3 - Methods, Watch, and Computed", "description": "Learn about the basic features of methods, watch, and computed in Vue 3." }, "shorturls": { "share": "https://dpgr.am/c58f2b2", "twitter": "https://dpgr.am/99bca25", "linkedin": "https://dpgr.am/262624f", "reddit": "https://dpgr.am/4ec20fe", "facebook": "https://dpgr.am/57aa167" }, "og": { "image": "https://res.cloudinary.com/deepgram/image/upload/v1661477089/blog/diving-into-vue-3-methods-watch-and-computed/ograph.png" }, "astro": { "headings": [{ "depth": 2, "slug": "introduction", "text": "Introduction" }, { "depth": 2, "slug": "methods", "text": "Methods" }, { "depth": 3, "slug": "composables", "text": "Composables" }, { "depth": 2, "slug": "watch", "text": "Watch" }, { "depth": 3, "slug": "watcheffect", "text": "watchEffect" }, { "depth": 2, "slug": "computed", "text": "Computed" }, { "depth": 2, "slug": "putting-it-all-together", "text": "Putting It All Together" }, { "depth": 2, "slug": "conclusion", "text": "Conclusion" }], "source": "\r\nIn this series, I'm focusing on the basics needed to start working in **Vue 3** for people who might have some experience in **Vue 2**, but who haven't yet built anything in **Vue 3**.\r\n\r\nCheck out my previous posts in the series:\r\n\r\n1.  [Diving Into Vue 3: Getting Started](https://blog.deepgram.com/diving-into-vue-3-getting-started/)\r\n\r\n2.  [Diving Into Vue 3: The Setup Function]()\r\n\r\nToday, I'll introduce how to use `methods`, `watch`, and `computed` in **Vue 3**, and I'll also give a general comparison of `watch` and the new `watchEffect`.\r\n\r\n## Introduction\r\n\r\nThe way I learn best is by connecting abstract concepts to a real world situation, so I tried to think of a simple, realistic situation for using `methods`, `watch`, and `computed`. The situation would need to demonstrate the following:\r\n\r\n*   doing something to data properties to change them (using `methods`)\r\n*   making something else occur (i.e, a side effect) because of a change to the data properties (using `watch`)\r\n*   returning a value that is calculated based on data properties that have been changed (`computed`)\r\n\r\nI will use a real-world example of a company with employees and managers; the logic will help keep track of *number of employees*, *number of managers*, and *total company headcount*. Not the most exciting example, but I really just want to keep it simple.\r\n\r\n## Methods\r\n\r\nOne of the first things I need to be able to do, whether I'm using **Vue 2** or **Vue 3**, is be able to make stuff happen with methods/functions (note: I'm using the terms *functions* and *methods* interchangeably in this section). The magic of Vue is its reactivity, so local state updates automatically as stuff happens. The stuff that happens is often triggered by *methods*.\r\n\r\nIn my real-world example, I want to create a component that has a variable to represent the **number of employees** with buttons I click to **add or subtract the number of employees**, changing the **headcount**. I'll write functions to perform these basic actions.\r\n\r\nHere's what the rendered component looks like:\r\n\r\n![Rendered component to that uses method to increment and decrement](https://res.cloudinary.com/deepgram/image/upload/v1643663337/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/component-methods.png)\r\n\r\nI am familiar with the **Vue 2** way of adding functions to the component: add each function to the `methods` object:\r\n\r\n```html\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      numEmployees: 10,\r\n    };\r\n  },\r\n  methods: {\r\n    addEmployees() {\r\n      this.numEmployees++;\r\n    },\r\n    subtractEmployees() {\r\n      this.numEmployees--;\r\n    },\r\n  },\r\n};\r\n<\/script>\r\n```\r\n\r\nAnd the following line from the `template` shows that **Vue 2** and **Vue 3** are no different in how the methods are invoked in the `template`:\r\n\r\n```js\r\n<button @click=\"addToEmployees()\">+</button>\r\n```\r\n\r\nHowever, **Vue 3** is different now in regards to where we write the methods in the `script`. In **Vue 3**, I can now write my functions *inside* the `setup` function, which runs very early in the component lifecycle (before the component instance is even created). I no longer have to write all my functions in the `methods` property of the options API.\r\n\r\nIn this example, I have written two basic functions, and those functions are not separated into a separate methods block like in **Vue 2**, they are inside `setup` with the related logic like the variable for `numEmployees`. I can make the functions available to the template by returning an object that includes them:\r\n\r\n```js\r\n<script>\r\nimport { ref } from \"vue\";\r\nexport default {\r\n  setup() {\r\n    let numEmployees = ref(10);\r\n    function addEmployees() {\r\n      numEmployees.value++;\r\n    }\r\n    function subtractEmployees() {\r\n      numEmployees.value--;\r\n    }\r\n    return { numEmployees, addEmployees, subtractEmployees };\r\n  },\r\n};\r\n<\/script>\r\n```\r\n\r\nNotice that there is no keyword `this` when referring to `numEmployees`. Methods that are inside the `setup` function no longer use the keyword `this` to refer to properties on the component instance since `setup` runs before the component instance is even created. I was very used to writing `this`-dot everything in **Vue 2**, but that is no longer the experience in **Vue 3**.\r\n\r\nThe use of `ref()` surrounding the data property is something I introduced in the last post, and it's important here. For reactivity to work in Vue, the data being tracked needs to be wrapped in an object, which is why in **Vue 2**, the `data` method in the options API returned an object with those reactive data properties.\r\n\r\nNow, **Vue 3** uses `ref` to wrap primitive data in an object and `reactive` to make a copy of non-primitive data (I've only introduced `ref` so far in this series). This is important to methods because it helps me understand why I see `numEmployees.value` inside the function rather than just `numEmployees`. I have to use `.value` to reach the property inside the object created by `ref` and then perform the action on that value property. (I don't have to use the `.value` property in the template, however. Just writing `numEmployees` grabs the value).\r\n\r\nWriting all the methods inside the setup function may seem like it would get messy when there is more complexity going on in the component, but in practice, **related logic could all be grouped together to run within its own function**. This is where **Vue 3** starts to show its strengths. I could group all the logic for updating headcount into a function called `updateHeadcount`, then create a separate JS file where that logic lives. I'll actually name it `useUpdateHeadcount.js`, which is **Vue 3** best-practice for naming this type of file (the convention of starting composables with *use* is discussed in the Composition API RFC in [this section](https://github.com/vuejs/composition-api-rfc/blob/master/index.md#logical-concerns-vs-option-types)). Here's the `useUpdateHeadcount.js` file:\r\n\r\n```js\r\nimport { ref } from 'vue'\r\n\r\nexport default function useUpdateHeadcount() {\r\n  let numEmployees = ref(10)\r\n  function addToEmployees() {\r\n    numEmployees.value++\r\n  }\r\n  function subtractFromEmployees() {\r\n    numEmployees.value--\r\n  }\r\n\r\n  return { numEmployees, addToEmployees, subtractFromEmployees }\r\n}\r\n```\r\n\r\nNow, in my component, I just have to write this in the setup function:\r\n\r\n```js\r\n<script>\r\nimport useUpdateHeadcount from \"../composables/useUpdateHeadcount\";\r\nexport default {\r\n  setup() {\r\n\r\n    const { numEmployees, addToEmployees, subtractFromEmployees } =\r\n      useUpdateHeadcount();\r\n\r\n    return { numEmployees, addToEmployees, subtractFromEmployees };\r\n  },\r\n};\r\n<\/script>\r\n\r\n```\r\n\r\n### Composables\r\n\r\nNotice that I imported the `useUpdateHeadcount` file from a folder called *composables*. That's because these *functions to separate out logic by shared concerns* are known as **composables** in the **Vue 3** world. I'm not going to go over all the details of how I wrote the composable and brought it back into the component file because I'll be doing a later blog post in the series about composables. In fact, I don't even have to use a composable; I can just write all my logic in the setup function since it's a very simple component. But I wanted to also make it clear that as the component gets more complicated, there is a strategy for organizing the logic, and it's one of **Vue 3**'s most exciting features.\r\n\r\n## Watch\r\n\r\n`watch` is basically the same in **Vue 3**, so I am happy to know that I can use it as I have before. In my example, I want to track the value of `numEmployees` to make sure it doesn't go below zero, since it's not possible to have negative human beings as employees.\r\n\r\nHere's my rendered component. It looks the same, but I added a disclaimer that the headcount cannot go below zero.\r\n\r\n![Component for adding or subtracting employees but restricted to not go below zero](https://res.cloudinary.com/deepgram/image/upload/v1643663535/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watch-headcount.png)\r\n\r\nThis restriction - not going below zero - will be managed by the logic in `watch`:\r\n\r\n```js\r\nwatch(numEmployees, () => {\r\n  if (numEmployees.value < 0) {\r\n    numEmployees.value = 0\r\n  }\r\n})\r\n```\r\n\r\nI specify which data property to track (`numEmployees`) as the first argument, and a *callback* as the second argument. Inside the callback, I have my logic that causes the side effect. If `numEmployees` reaches below zero, that side effect happens, setting the value to zero. The callback makes sure the side effect happens on the next tick following the value reaching below zero.\r\n\r\n`watch` will not be triggered until that specific reactive property is changed, so if I want it to run immediately when the component is created, I can add an object with `immediate: true` like this:\r\n\r\n```js\r\nwatch(\r\n  employees,\r\n  (newVal, oldVal) => {\r\n    if (employees.value < 0) {\r\n      employees.value = 0\r\n    }\r\n  },\r\n  { immediate: true }\r\n)\r\n```\r\n\r\nThe callback argument can also take two arguments for the **new value** and the **old value**, which makes `watch` useful for doing logic based on the previous state of the reactive property or just checking if a property has been changed (i.e. it's a great debugging tool):\r\n\r\n```js\r\nwatch(employees, (newVal, oldVal) => {\r\n  console.log(oldVal, newVal)\r\n})\r\n```\r\n\r\nAs for comparing `watch` in **Vue 2** versus **Vue 3**, the only difference is that in Vue 3 I can now place `watch` inside the setup function. Like methods, it no longer has to be separated out into its own section as an option property on the component instance.\r\n\r\nHowever, **Vue 3** also has added a similar feature that gives some different capabilities from `watch`: it's called `watchEffect`.\r\n\r\n### watchEffect\r\n\r\nVue 3 keeps `watch` the same, but it adds `watchEffect` as another way to cause side effects based on what happens to the reactive properties. Both `watch` and `watchEffect` are useful in different situations; one isn't better than the other.\r\n\r\nIn this example, I will add another reactive property to the component - managers (`numManagers`). I want to track both managers and employees, and I want to restrict their values going below zero. Here is the component now:\r\n\r\n![Component for adding or subtracting employees and manager but restricted to not go below zero](https://res.cloudinary.com/deepgram/image/upload/v1643663591/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watchEffect-headcount.png)\r\n\r\nThe reason I added a second reactive property is because `watchEffect` makes it easier to track multiple reactive properties. I no longer have to specify each property I want to track as the first argument of watch. Notice that I don't have a first argument to name the properties I'm tracking:\r\n\r\n```js\r\nwatchEffect(() => {\r\n  if (numEmployees.value < 0) {\r\n    numEmployees.value = 0\r\n  }\r\n  if (numManagers.value < 0) {\r\n    numManagers.value = 0\r\n  }\r\n})\r\n```\r\n\r\nUnlike `watch`, `watchEffect` is not lazy loaded, so it will trigger automatically when the component is created. No need to add the object with `immediate: true`.\r\n\r\n`watchEffect` is useful when I want to track changes to whatever property I want, and when I want the tracking to happen immediately.\r\n\r\n`watch` is useful when I want to be more specific about tracking just one property, or if I want to have access to the new value and/or old value to use them in my logic.\r\n\r\nIt's great having both features!\r\n\r\n## Computed\r\n\r\nOne of the nice things about the Vue `template` is that I can write logic within double curly-braces, and that logic will be calculated based on whatever the values are represented by each variable:\r\n\r\n```html\r\n<h2>Headcount: {{ numEmployees + numManagers }}</h2>\r\n```\r\n\r\nThis will show a number which has been calculated, or *computed*, based on what `numEmployees` and `numManagers` are at the current point of time. And it will change if either of those data for `numEmployees` or `numManagers` change.\r\n\r\nSometimes, the logic can get complicated or long. That's when I write a `computed` property in the `script` section, and refer to it in the template. Here is how I would do that in Vue 2:\r\n\r\n```js\r\n\r\n<script>\r\n export default {\r\n  computed: {\r\n    headcount() {\r\n      return this.employees.value + this.managers.value;\r\n    },\r\n  },\r\n}\r\n<\/script>\r\n\r\n```\r\n\r\nThe computed property is another option that is part of the options API, and in **Vue 2**, it sits at the same level as `methods`, `data`, `watch`, and lifecycle methods like `mounted`.\r\n\r\nIn **Vue 3**, computed can now be used in the `setup` function (I bet you didn't see that one coming). I have to import `computed` from Vue like this:\r\n\r\n```js\r\nimport { computed } from 'vue'\r\n```\r\n\r\nTo compute the number of employees and the number of managers, giving me the total headcount, I could write a computed like this:\r\n\r\n```js\r\nconst headcount = computed(() => {\r\n  return numEmployees.value + numManagers.value\r\n})\r\n```\r\n\r\nThe only difference is that now I pass into the computed method an anonymous function, and I set it to the constant for headcount. I also have to return headcount from the setup function, along with everything else I want to be able to access from the template.\r\n\r\n```js\r\nreturn {\r\n  numEmployees,\r\n  numManagers,\r\n  addToEmployees,\r\n  subtractFromEmployees,\r\n  addToManagers,\r\n  subtractFromManagers,\r\n  headcount, //<----\r\n}\r\n```\r\n\r\n## Putting It All Together\r\n\r\nAt this point, I have logic that does the following:\r\n\r\n*   Adds or subtracts to the number of employees (numEmployees) or to the number of managers (numManagers)\r\n*   Makes sure employees and managers do not go below zero\r\n*   Computes the total headcount based on any changes\r\n\r\n<div>\r\n<CodeEmbed height=\"670\" src=\"https://codepen.io/sandrarodgers/embed/ZEaQRLR\"/>\r\n</div>\r\n\r\n## Conclusion\r\n\r\nAnd that wraps up this post in the series. Stay tuned for upcoming posts that cover topics like `ref` and `reactive`, `composables`, and the new `v-model`. And as always, feel free to reach out on [Twitter](https://twitter.com/sandra_rodgers_)!\r\n\r\n        ", "html": '<p>In this series, I\u2019m focusing on the basics needed to start working in <strong>Vue 3</strong> for people who might have some experience in <strong>Vue 2</strong>, but who haven\u2019t yet built anything in <strong>Vue 3</strong>.</p>\n<p>Check out my previous posts in the series:</p>\n<ol>\n<li>\n<p><a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3: Getting Started</a></p>\n</li>\n<li>\n<p><a href="">Diving Into Vue 3: The Setup Function</a></p>\n</li>\n</ol>\n<p>Today, I\u2019ll introduce how to use <code is:raw>methods</code>, <code is:raw>watch</code>, and <code is:raw>computed</code> in <strong>Vue 3</strong>, and I\u2019ll also give a general comparison of <code is:raw>watch</code> and the new <code is:raw>watchEffect</code>.</p>\n<h2 id="introduction">Introduction</h2>\n<p>The way I learn best is by connecting abstract concepts to a real world situation, so I tried to think of a simple, realistic situation for using <code is:raw>methods</code>, <code is:raw>watch</code>, and <code is:raw>computed</code>. The situation would need to demonstrate the following:</p>\n<ul>\n<li>doing something to data properties to change them (using <code is:raw>methods</code>)</li>\n<li>making something else occur (i.e, a side effect) because of a change to the data properties (using <code is:raw>watch</code>)</li>\n<li>returning a value that is calculated based on data properties that have been changed (<code is:raw>computed</code>)</li>\n</ul>\n<p>I will use a real-world example of a company with employees and managers; the logic will help keep track of <em>number of employees</em>, <em>number of managers</em>, and <em>total company headcount</em>. Not the most exciting example, but I really just want to keep it simple.</p>\n<h2 id="methods">Methods</h2>\n<p>One of the first things I need to be able to do, whether I\u2019m using <strong>Vue 2</strong> or <strong>Vue 3</strong>, is be able to make stuff happen with methods/functions (note: I\u2019m using the terms <em>functions</em> and <em>methods</em> interchangeably in this section). The magic of Vue is its reactivity, so local state updates automatically as stuff happens. The stuff that happens is often triggered by <em>methods</em>.</p>\n<p>In my real-world example, I want to create a component that has a variable to represent the <strong>number of employees</strong> with buttons I click to <strong>add or subtract the number of employees</strong>, changing the <strong>headcount</strong>. I\u2019ll write functions to perform these basic actions.</p>\n<p>Here\u2019s what the rendered component looks like:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1643663337/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/component-methods.png" alt="Rendered component to that uses method to increment and decrement"></p>\n<p>I am familiar with the <strong>Vue 2</strong> way of adding functions to the component: add each function to the <code is:raw>methods</code> object:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> {</span></span>\n<span class="line"><span style="color: #FFA657">  </span><span style="color: #D2A8FF">data</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      numEmployees: </span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    };</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span><span style="color: #FFA657">,</span></span>\n<span class="line"><span style="color: #FFA657">  </span><span style="color: #C9D1D9">methods: {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">addEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numEmployees</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">subtractEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numEmployees</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span><span style="color: #FFA657">,</span></span>\n<span class="line"><span style="color: #FFA657">}</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>And the following line from the <code is:raw>template</code> shows that <strong>Vue 2</strong> and <strong>Vue 3</strong> are no different in how the methods are invoked in the <code is:raw>template</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9"> </span><span style="color: #FFA198">@click=&quot;addToEmployees()&quot;&gt;+&lt;/button&gt;</span></span></code></pre>\n<p>However, <strong>Vue 3</strong> is different now in regards to where we write the methods in the <code is:raw>script</code>. In <strong>Vue 3</strong>, I can now write my functions <em>inside</em> the <code is:raw>setup</code> function, which runs very early in the component lifecycle (before the component instance is even created). I no longer have to write all my functions in the <code is:raw>methods</code> property of the options API.</p>\n<p>In this example, I have written two basic functions, and those functions are not separated into a separate methods block like in <strong>Vue 2</strong>, they are inside <code is:raw>setup</code> with the related logic like the variable for <code is:raw>numEmployees</code>. I can make the functions available to the template by returning an object that includes them:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let numEmployees </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    function </span><span style="color: #D2A8FF">addEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      numEmployees.value</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    function </span><span style="color: #D2A8FF">subtractEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      numEmployees.value</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    return { numEmployees, addEmployees, subtractEmployees };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>Notice that there is no keyword <code is:raw>this</code> when referring to <code is:raw>numEmployees</code>. Methods that are inside the <code is:raw>setup</code> function no longer use the keyword <code is:raw>this</code> to refer to properties on the component instance since <code is:raw>setup</code> runs before the component instance is even created. I was very used to writing <code is:raw>this</code>-dot everything in <strong>Vue 2</strong>, but that is no longer the experience in <strong>Vue 3</strong>.</p>\n<p>The use of <code is:raw>ref()</code> surrounding the data property is something I introduced in the last post, and it\u2019s important here. For reactivity to work in Vue, the data being tracked needs to be wrapped in an object, which is why in <strong>Vue 2</strong>, the <code is:raw>data</code> method in the options API returned an object with those reactive data properties.</p>\n<p>Now, <strong>Vue 3</strong> uses <code is:raw>ref</code> to wrap primitive data in an object and <code is:raw>reactive</code> to make a copy of non-primitive data (I\u2019ve only introduced <code is:raw>ref</code> so far in this series). This is important to methods because it helps me understand why I see <code is:raw>numEmployees.value</code> inside the function rather than just <code is:raw>numEmployees</code>. I have to use <code is:raw>.value</code> to reach the property inside the object created by <code is:raw>ref</code> and then perform the action on that value property. (I don\u2019t have to use the <code is:raw>.value</code> property in the template, however. Just writing <code is:raw>numEmployees</code> grabs the value).</p>\n<p>Writing all the methods inside the setup function may seem like it would get messy when there is more complexity going on in the component, but in practice, <strong>related logic could all be grouped together to run within its own function</strong>. This is where <strong>Vue 3</strong> starts to show its strengths. I could group all the logic for updating headcount into a function called <code is:raw>updateHeadcount</code>, then create a separate JS file where that logic lives. I\u2019ll actually name it <code is:raw>useUpdateHeadcount.js</code>, which is <strong>Vue 3</strong> best-practice for naming this type of file (the convention of starting composables with <em>use</em> is discussed in the Composition API RFC in <a href="https://github.com/vuejs/composition-api-rfc/blob/master/index.md#logical-concerns-vs-option-types">this section</a>). Here\u2019s the <code is:raw>useUpdateHeadcount.js</code> file:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useUpdateHeadcount</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> numEmployees </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">addToEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numEmployees.value</span><span style="color: #FF7B72">++</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">subtractFromEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numEmployees.value</span><span style="color: #FF7B72">--</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { numEmployees, addToEmployees, subtractFromEmployees }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now, in my component, I just have to write this in the setup function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useUpdateHeadcount from &quot;../composables/useUpdateHeadcount&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    const { numEmployees, addToEmployees, subtractFromEmployees } </span><span style="color: #FF7B72">=</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">useUpdateHeadcount</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { numEmployees, addToEmployees, subtractFromEmployees };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span></code></pre>\n<h3 id="composables">Composables</h3>\n<p>Notice that I imported the <code is:raw>useUpdateHeadcount</code> file from a folder called <em>composables</em>. That\u2019s because these <em>functions to separate out logic by shared concerns</em> are known as <strong>composables</strong> in the <strong>Vue 3</strong> world. I\u2019m not going to go over all the details of how I wrote the composable and brought it back into the component file because I\u2019ll be doing a later blog post in the series about composables. In fact, I don\u2019t even have to use a composable; I can just write all my logic in the setup function since it\u2019s a very simple component. But I wanted to also make it clear that as the component gets more complicated, there is a strategy for organizing the logic, and it\u2019s one of <strong>Vue 3</strong>\u2019s most exciting features.</p>\n<h2 id="watch">Watch</h2>\n<p><code is:raw>watch</code> is basically the same in <strong>Vue 3</strong>, so I am happy to know that I can use it as I have before. In my example, I want to track the value of <code is:raw>numEmployees</code> to make sure it doesn\u2019t go below zero, since it\u2019s not possible to have negative human beings as employees.</p>\n<p>Here\u2019s my rendered component. It looks the same, but I added a disclaimer that the headcount cannot go below zero.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1643663535/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watch-headcount.png" alt="Component for adding or subtracting employees but restricted to not go below zero"></p>\n<p>This restriction - not going below zero - will be managed by the logic in <code is:raw>watch</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(numEmployees, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (numEmployees.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numEmployees.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>I specify which data property to track (<code is:raw>numEmployees</code>) as the first argument, and a <em>callback</em> as the second argument. Inside the callback, I have my logic that causes the side effect. If <code is:raw>numEmployees</code> reaches below zero, that side effect happens, setting the value to zero. The callback makes sure the side effect happens on the next tick following the value reaching below zero.</p>\n<p><code is:raw>watch</code> will not be triggered until that specific reactive property is changed, so if I want it to run immediately when the component is created, I can add an object with <code is:raw>immediate: true</code> like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(</span></span>\n<span class="line"><span style="color: #C9D1D9">  employees,</span></span>\n<span class="line"><span style="color: #C9D1D9">  (</span><span style="color: #FFA657">newVal</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">oldVal</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (employees.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      employees.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span>\n<span class="line"><span style="color: #C9D1D9">  { immediate: </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9"> }</span></span>\n<span class="line"><span style="color: #C9D1D9">)</span></span></code></pre>\n<p>The callback argument can also take two arguments for the <strong>new value</strong> and the <strong>old value</strong>, which makes <code is:raw>watch</code> useful for doing logic based on the previous state of the reactive property or just checking if a property has been changed (i.e. it\u2019s a great debugging tool):</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(employees, (</span><span style="color: #FFA657">newVal</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">oldVal</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(oldVal, newVal)</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>As for comparing <code is:raw>watch</code> in <strong>Vue 2</strong> versus <strong>Vue 3</strong>, the only difference is that in Vue 3 I can now place <code is:raw>watch</code> inside the setup function. Like methods, it no longer has to be separated out into its own section as an option property on the component instance.</p>\n<p>However, <strong>Vue 3</strong> also has added a similar feature that gives some different capabilities from <code is:raw>watch</code>: it\u2019s called <code is:raw>watchEffect</code>.</p>\n<h3 id="watcheffect">watchEffect</h3>\n<p>Vue 3 keeps <code is:raw>watch</code> the same, but it adds <code is:raw>watchEffect</code> as another way to cause side effects based on what happens to the reactive properties. Both <code is:raw>watch</code> and <code is:raw>watchEffect</code> are useful in different situations; one isn\u2019t better than the other.</p>\n<p>In this example, I will add another reactive property to the component - managers (<code is:raw>numManagers</code>). I want to track both managers and employees, and I want to restrict their values going below zero. Here is the component now:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1643663591/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watchEffect-headcount.png" alt="Component for adding or subtracting employees and manager but restricted to not go below zero"></p>\n<p>The reason I added a second reactive property is because <code is:raw>watchEffect</code> makes it easier to track multiple reactive properties. I no longer have to specify each property I want to track as the first argument of watch. Notice that I don\u2019t have a first argument to name the properties I\u2019m tracking:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watchEffect</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (numEmployees.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numEmployees.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (numManagers.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numManagers.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>Unlike <code is:raw>watch</code>, <code is:raw>watchEffect</code> is not lazy loaded, so it will trigger automatically when the component is created. No need to add the object with <code is:raw>immediate: true</code>.</p>\n<p><code is:raw>watchEffect</code> is useful when I want to track changes to whatever property I want, and when I want the tracking to happen immediately.</p>\n<p><code is:raw>watch</code> is useful when I want to be more specific about tracking just one property, or if I want to have access to the new value and/or old value to use them in my logic.</p>\n<p>It\u2019s great having both features!</p>\n<h2 id="computed">Computed</h2>\n<p>One of the nice things about the Vue <code is:raw>template</code> is that I can write logic within double curly-braces, and that logic will be calculated based on whatever the values are represented by each variable:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">h2</span><span style="color: #C9D1D9">&gt;Headcount: {{ numEmployees + numManagers }}&lt;/</span><span style="color: #7EE787">h2</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>This will show a number which has been calculated, or <em>computed</em>, based on what <code is:raw>numEmployees</code> and <code is:raw>numManagers</code> are at the current point of time. And it will change if either of those data for <code is:raw>numEmployees</code> or <code is:raw>numManagers</code> change.</p>\n<p>Sometimes, the logic can get complicated or long. That\u2019s when I write a <code is:raw>computed</code> property in the <code is:raw>script</code> section, and refer to it in the template. Here is how I would do that in Vue 2:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9"> export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  computed: {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">headcount</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.employees.value </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.managers.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span>\n<span class="line"><span style="color: #FF7B72">}</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span></code></pre>\n<p>The computed property is another option that is part of the options API, and in <strong>Vue 2</strong>, it sits at the same level as <code is:raw>methods</code>, <code is:raw>data</code>, <code is:raw>watch</code>, and lifecycle methods like <code is:raw>mounted</code>.</p>\n<p>In <strong>Vue 3</strong>, computed can now be used in the <code is:raw>setup</code> function (I bet you didn\u2019t see that one coming). I have to import <code is:raw>computed</code> from Vue like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { computed } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span></code></pre>\n<p>To compute the number of employees and the number of managers, giving me the total headcount, I could write a computed like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">headcount</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">computed</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> numEmployees.value </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> numManagers.value</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>The only difference is that now I pass into the computed method an anonymous function, and I set it to the constant for headcount. I also have to return headcount from the setup function, along with everything else I want to be able to access from the template.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  numEmployees,</span></span>\n<span class="line"><span style="color: #C9D1D9">  numManagers,</span></span>\n<span class="line"><span style="color: #C9D1D9">  addToEmployees,</span></span>\n<span class="line"><span style="color: #C9D1D9">  subtractFromEmployees,</span></span>\n<span class="line"><span style="color: #C9D1D9">  addToManagers,</span></span>\n<span class="line"><span style="color: #C9D1D9">  subtractFromManagers,</span></span>\n<span class="line"><span style="color: #C9D1D9">  headcount, </span><span style="color: #8B949E">//&lt;----</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<h2 id="putting-it-all-together">Putting It All Together</h2>\n<p>At this point, I have logic that does the following:</p>\n<ul>\n<li>Adds or subtracts to the number of employees (numEmployees) or to the number of managers (numManagers)</li>\n<li>Makes sure employees and managers do not go below zero</li>\n<li>Computes the total headcount based on any changes</li>\n</ul>\n<div><CodeEmbed height="670" src="https://codepen.io/sandrarodgers/embed/ZEaQRLR" /></div>\n<h2 id="conclusion">Conclusion</h2>\n<p>And that wraps up this post in the series. Stay tuned for upcoming posts that cover topics like <code is:raw>ref</code> and <code is:raw>reactive</code>, <code is:raw>composables</code>, and the new <code is:raw>v-model</code>. And as always, feel free to reach out on <a href="https://twitter.com/sandra_rodgers_">Twitter</a>!</p>' }, "file": "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/diving-into-vue-3-methods-watch-and-computed/index.md" };
function rawContent() {
  return "\r\nIn this series, I'm focusing on the basics needed to start working in **Vue 3** for people who might have some experience in **Vue 2**, but who haven't yet built anything in **Vue 3**.\r\n\r\nCheck out my previous posts in the series:\r\n\r\n1.  [Diving Into Vue 3: Getting Started](https://blog.deepgram.com/diving-into-vue-3-getting-started/)\r\n\r\n2.  [Diving Into Vue 3: The Setup Function]()\r\n\r\nToday, I'll introduce how to use `methods`, `watch`, and `computed` in **Vue 3**, and I'll also give a general comparison of `watch` and the new `watchEffect`.\r\n\r\n## Introduction\r\n\r\nThe way I learn best is by connecting abstract concepts to a real world situation, so I tried to think of a simple, realistic situation for using `methods`, `watch`, and `computed`. The situation would need to demonstrate the following:\r\n\r\n*   doing something to data properties to change them (using `methods`)\r\n*   making something else occur (i.e, a side effect) because of a change to the data properties (using `watch`)\r\n*   returning a value that is calculated based on data properties that have been changed (`computed`)\r\n\r\nI will use a real-world example of a company with employees and managers; the logic will help keep track of *number of employees*, *number of managers*, and *total company headcount*. Not the most exciting example, but I really just want to keep it simple.\r\n\r\n## Methods\r\n\r\nOne of the first things I need to be able to do, whether I'm using **Vue 2** or **Vue 3**, is be able to make stuff happen with methods/functions (note: I'm using the terms *functions* and *methods* interchangeably in this section). The magic of Vue is its reactivity, so local state updates automatically as stuff happens. The stuff that happens is often triggered by *methods*.\r\n\r\nIn my real-world example, I want to create a component that has a variable to represent the **number of employees** with buttons I click to **add or subtract the number of employees**, changing the **headcount**. I'll write functions to perform these basic actions.\r\n\r\nHere's what the rendered component looks like:\r\n\r\n![Rendered component to that uses method to increment and decrement](https://res.cloudinary.com/deepgram/image/upload/v1643663337/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/component-methods.png)\r\n\r\nI am familiar with the **Vue 2** way of adding functions to the component: add each function to the `methods` object:\r\n\r\n```html\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      numEmployees: 10,\r\n    };\r\n  },\r\n  methods: {\r\n    addEmployees() {\r\n      this.numEmployees++;\r\n    },\r\n    subtractEmployees() {\r\n      this.numEmployees--;\r\n    },\r\n  },\r\n};\r\n<\/script>\r\n```\r\n\r\nAnd the following line from the `template` shows that **Vue 2** and **Vue 3** are no different in how the methods are invoked in the `template`:\r\n\r\n```js\r\n<button @click=\"addToEmployees()\">+</button>\r\n```\r\n\r\nHowever, **Vue 3** is different now in regards to where we write the methods in the `script`. In **Vue 3**, I can now write my functions *inside* the `setup` function, which runs very early in the component lifecycle (before the component instance is even created). I no longer have to write all my functions in the `methods` property of the options API.\r\n\r\nIn this example, I have written two basic functions, and those functions are not separated into a separate methods block like in **Vue 2**, they are inside `setup` with the related logic like the variable for `numEmployees`. I can make the functions available to the template by returning an object that includes them:\r\n\r\n```js\r\n<script>\r\nimport { ref } from \"vue\";\r\nexport default {\r\n  setup() {\r\n    let numEmployees = ref(10);\r\n    function addEmployees() {\r\n      numEmployees.value++;\r\n    }\r\n    function subtractEmployees() {\r\n      numEmployees.value--;\r\n    }\r\n    return { numEmployees, addEmployees, subtractEmployees };\r\n  },\r\n};\r\n<\/script>\r\n```\r\n\r\nNotice that there is no keyword `this` when referring to `numEmployees`. Methods that are inside the `setup` function no longer use the keyword `this` to refer to properties on the component instance since `setup` runs before the component instance is even created. I was very used to writing `this`-dot everything in **Vue 2**, but that is no longer the experience in **Vue 3**.\r\n\r\nThe use of `ref()` surrounding the data property is something I introduced in the last post, and it's important here. For reactivity to work in Vue, the data being tracked needs to be wrapped in an object, which is why in **Vue 2**, the `data` method in the options API returned an object with those reactive data properties.\r\n\r\nNow, **Vue 3** uses `ref` to wrap primitive data in an object and `reactive` to make a copy of non-primitive data (I've only introduced `ref` so far in this series). This is important to methods because it helps me understand why I see `numEmployees.value` inside the function rather than just `numEmployees`. I have to use `.value` to reach the property inside the object created by `ref` and then perform the action on that value property. (I don't have to use the `.value` property in the template, however. Just writing `numEmployees` grabs the value).\r\n\r\nWriting all the methods inside the setup function may seem like it would get messy when there is more complexity going on in the component, but in practice, **related logic could all be grouped together to run within its own function**. This is where **Vue 3** starts to show its strengths. I could group all the logic for updating headcount into a function called `updateHeadcount`, then create a separate JS file where that logic lives. I'll actually name it `useUpdateHeadcount.js`, which is **Vue 3** best-practice for naming this type of file (the convention of starting composables with *use* is discussed in the Composition API RFC in [this section](https://github.com/vuejs/composition-api-rfc/blob/master/index.md#logical-concerns-vs-option-types)). Here's the `useUpdateHeadcount.js` file:\r\n\r\n```js\r\nimport { ref } from 'vue'\r\n\r\nexport default function useUpdateHeadcount() {\r\n  let numEmployees = ref(10)\r\n  function addToEmployees() {\r\n    numEmployees.value++\r\n  }\r\n  function subtractFromEmployees() {\r\n    numEmployees.value--\r\n  }\r\n\r\n  return { numEmployees, addToEmployees, subtractFromEmployees }\r\n}\r\n```\r\n\r\nNow, in my component, I just have to write this in the setup function:\r\n\r\n```js\r\n<script>\r\nimport useUpdateHeadcount from \"../composables/useUpdateHeadcount\";\r\nexport default {\r\n  setup() {\r\n\r\n    const { numEmployees, addToEmployees, subtractFromEmployees } =\r\n      useUpdateHeadcount();\r\n\r\n    return { numEmployees, addToEmployees, subtractFromEmployees };\r\n  },\r\n};\r\n<\/script>\r\n\r\n```\r\n\r\n### Composables\r\n\r\nNotice that I imported the `useUpdateHeadcount` file from a folder called *composables*. That's because these *functions to separate out logic by shared concerns* are known as **composables** in the **Vue 3** world. I'm not going to go over all the details of how I wrote the composable and brought it back into the component file because I'll be doing a later blog post in the series about composables. In fact, I don't even have to use a composable; I can just write all my logic in the setup function since it's a very simple component. But I wanted to also make it clear that as the component gets more complicated, there is a strategy for organizing the logic, and it's one of **Vue 3**'s most exciting features.\r\n\r\n## Watch\r\n\r\n`watch` is basically the same in **Vue 3**, so I am happy to know that I can use it as I have before. In my example, I want to track the value of `numEmployees` to make sure it doesn't go below zero, since it's not possible to have negative human beings as employees.\r\n\r\nHere's my rendered component. It looks the same, but I added a disclaimer that the headcount cannot go below zero.\r\n\r\n![Component for adding or subtracting employees but restricted to not go below zero](https://res.cloudinary.com/deepgram/image/upload/v1643663535/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watch-headcount.png)\r\n\r\nThis restriction - not going below zero - will be managed by the logic in `watch`:\r\n\r\n```js\r\nwatch(numEmployees, () => {\r\n  if (numEmployees.value < 0) {\r\n    numEmployees.value = 0\r\n  }\r\n})\r\n```\r\n\r\nI specify which data property to track (`numEmployees`) as the first argument, and a *callback* as the second argument. Inside the callback, I have my logic that causes the side effect. If `numEmployees` reaches below zero, that side effect happens, setting the value to zero. The callback makes sure the side effect happens on the next tick following the value reaching below zero.\r\n\r\n`watch` will not be triggered until that specific reactive property is changed, so if I want it to run immediately when the component is created, I can add an object with `immediate: true` like this:\r\n\r\n```js\r\nwatch(\r\n  employees,\r\n  (newVal, oldVal) => {\r\n    if (employees.value < 0) {\r\n      employees.value = 0\r\n    }\r\n  },\r\n  { immediate: true }\r\n)\r\n```\r\n\r\nThe callback argument can also take two arguments for the **new value** and the **old value**, which makes `watch` useful for doing logic based on the previous state of the reactive property or just checking if a property has been changed (i.e. it's a great debugging tool):\r\n\r\n```js\r\nwatch(employees, (newVal, oldVal) => {\r\n  console.log(oldVal, newVal)\r\n})\r\n```\r\n\r\nAs for comparing `watch` in **Vue 2** versus **Vue 3**, the only difference is that in Vue 3 I can now place `watch` inside the setup function. Like methods, it no longer has to be separated out into its own section as an option property on the component instance.\r\n\r\nHowever, **Vue 3** also has added a similar feature that gives some different capabilities from `watch`: it's called `watchEffect`.\r\n\r\n### watchEffect\r\n\r\nVue 3 keeps `watch` the same, but it adds `watchEffect` as another way to cause side effects based on what happens to the reactive properties. Both `watch` and `watchEffect` are useful in different situations; one isn't better than the other.\r\n\r\nIn this example, I will add another reactive property to the component - managers (`numManagers`). I want to track both managers and employees, and I want to restrict their values going below zero. Here is the component now:\r\n\r\n![Component for adding or subtracting employees and manager but restricted to not go below zero](https://res.cloudinary.com/deepgram/image/upload/v1643663591/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watchEffect-headcount.png)\r\n\r\nThe reason I added a second reactive property is because `watchEffect` makes it easier to track multiple reactive properties. I no longer have to specify each property I want to track as the first argument of watch. Notice that I don't have a first argument to name the properties I'm tracking:\r\n\r\n```js\r\nwatchEffect(() => {\r\n  if (numEmployees.value < 0) {\r\n    numEmployees.value = 0\r\n  }\r\n  if (numManagers.value < 0) {\r\n    numManagers.value = 0\r\n  }\r\n})\r\n```\r\n\r\nUnlike `watch`, `watchEffect` is not lazy loaded, so it will trigger automatically when the component is created. No need to add the object with `immediate: true`.\r\n\r\n`watchEffect` is useful when I want to track changes to whatever property I want, and when I want the tracking to happen immediately.\r\n\r\n`watch` is useful when I want to be more specific about tracking just one property, or if I want to have access to the new value and/or old value to use them in my logic.\r\n\r\nIt's great having both features!\r\n\r\n## Computed\r\n\r\nOne of the nice things about the Vue `template` is that I can write logic within double curly-braces, and that logic will be calculated based on whatever the values are represented by each variable:\r\n\r\n```html\r\n<h2>Headcount: {{ numEmployees + numManagers }}</h2>\r\n```\r\n\r\nThis will show a number which has been calculated, or *computed*, based on what `numEmployees` and `numManagers` are at the current point of time. And it will change if either of those data for `numEmployees` or `numManagers` change.\r\n\r\nSometimes, the logic can get complicated or long. That's when I write a `computed` property in the `script` section, and refer to it in the template. Here is how I would do that in Vue 2:\r\n\r\n```js\r\n\r\n<script>\r\n export default {\r\n  computed: {\r\n    headcount() {\r\n      return this.employees.value + this.managers.value;\r\n    },\r\n  },\r\n}\r\n<\/script>\r\n\r\n```\r\n\r\nThe computed property is another option that is part of the options API, and in **Vue 2**, it sits at the same level as `methods`, `data`, `watch`, and lifecycle methods like `mounted`.\r\n\r\nIn **Vue 3**, computed can now be used in the `setup` function (I bet you didn't see that one coming). I have to import `computed` from Vue like this:\r\n\r\n```js\r\nimport { computed } from 'vue'\r\n```\r\n\r\nTo compute the number of employees and the number of managers, giving me the total headcount, I could write a computed like this:\r\n\r\n```js\r\nconst headcount = computed(() => {\r\n  return numEmployees.value + numManagers.value\r\n})\r\n```\r\n\r\nThe only difference is that now I pass into the computed method an anonymous function, and I set it to the constant for headcount. I also have to return headcount from the setup function, along with everything else I want to be able to access from the template.\r\n\r\n```js\r\nreturn {\r\n  numEmployees,\r\n  numManagers,\r\n  addToEmployees,\r\n  subtractFromEmployees,\r\n  addToManagers,\r\n  subtractFromManagers,\r\n  headcount, //<----\r\n}\r\n```\r\n\r\n## Putting It All Together\r\n\r\nAt this point, I have logic that does the following:\r\n\r\n*   Adds or subtracts to the number of employees (numEmployees) or to the number of managers (numManagers)\r\n*   Makes sure employees and managers do not go below zero\r\n*   Computes the total headcount based on any changes\r\n\r\n<div>\r\n<CodeEmbed height=\"670\" src=\"https://codepen.io/sandrarodgers/embed/ZEaQRLR\"/>\r\n</div>\r\n\r\n## Conclusion\r\n\r\nAnd that wraps up this post in the series. Stay tuned for upcoming posts that cover topics like `ref` and `reactive`, `composables`, and the new `v-model`. And as always, feel free to reach out on [Twitter](https://twitter.com/sandra_rodgers_)!\r\n\r\n        ";
}
function compiledContent() {
  return '<p>In this series, I\u2019m focusing on the basics needed to start working in <strong>Vue 3</strong> for people who might have some experience in <strong>Vue 2</strong>, but who haven\u2019t yet built anything in <strong>Vue 3</strong>.</p>\n<p>Check out my previous posts in the series:</p>\n<ol>\n<li>\n<p><a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3: Getting Started</a></p>\n</li>\n<li>\n<p><a href="">Diving Into Vue 3: The Setup Function</a></p>\n</li>\n</ol>\n<p>Today, I\u2019ll introduce how to use <code is:raw>methods</code>, <code is:raw>watch</code>, and <code is:raw>computed</code> in <strong>Vue 3</strong>, and I\u2019ll also give a general comparison of <code is:raw>watch</code> and the new <code is:raw>watchEffect</code>.</p>\n<h2 id="introduction">Introduction</h2>\n<p>The way I learn best is by connecting abstract concepts to a real world situation, so I tried to think of a simple, realistic situation for using <code is:raw>methods</code>, <code is:raw>watch</code>, and <code is:raw>computed</code>. The situation would need to demonstrate the following:</p>\n<ul>\n<li>doing something to data properties to change them (using <code is:raw>methods</code>)</li>\n<li>making something else occur (i.e, a side effect) because of a change to the data properties (using <code is:raw>watch</code>)</li>\n<li>returning a value that is calculated based on data properties that have been changed (<code is:raw>computed</code>)</li>\n</ul>\n<p>I will use a real-world example of a company with employees and managers; the logic will help keep track of <em>number of employees</em>, <em>number of managers</em>, and <em>total company headcount</em>. Not the most exciting example, but I really just want to keep it simple.</p>\n<h2 id="methods">Methods</h2>\n<p>One of the first things I need to be able to do, whether I\u2019m using <strong>Vue 2</strong> or <strong>Vue 3</strong>, is be able to make stuff happen with methods/functions (note: I\u2019m using the terms <em>functions</em> and <em>methods</em> interchangeably in this section). The magic of Vue is its reactivity, so local state updates automatically as stuff happens. The stuff that happens is often triggered by <em>methods</em>.</p>\n<p>In my real-world example, I want to create a component that has a variable to represent the <strong>number of employees</strong> with buttons I click to <strong>add or subtract the number of employees</strong>, changing the <strong>headcount</strong>. I\u2019ll write functions to perform these basic actions.</p>\n<p>Here\u2019s what the rendered component looks like:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1643663337/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/component-methods.png" alt="Rendered component to that uses method to increment and decrement"></p>\n<p>I am familiar with the <strong>Vue 2</strong> way of adding functions to the component: add each function to the <code is:raw>methods</code> object:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> {</span></span>\n<span class="line"><span style="color: #FFA657">  </span><span style="color: #D2A8FF">data</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">      numEmployees: </span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">    };</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span><span style="color: #FFA657">,</span></span>\n<span class="line"><span style="color: #FFA657">  </span><span style="color: #C9D1D9">methods: {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">addEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numEmployees</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">subtractEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numEmployees</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span><span style="color: #FFA657">,</span></span>\n<span class="line"><span style="color: #FFA657">}</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>And the following line from the <code is:raw>template</code> shows that <strong>Vue 2</strong> and <strong>Vue 3</strong> are no different in how the methods are invoked in the <code is:raw>template</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9"> </span><span style="color: #FFA198">@click=&quot;addToEmployees()&quot;&gt;+&lt;/button&gt;</span></span></code></pre>\n<p>However, <strong>Vue 3</strong> is different now in regards to where we write the methods in the <code is:raw>script</code>. In <strong>Vue 3</strong>, I can now write my functions <em>inside</em> the <code is:raw>setup</code> function, which runs very early in the component lifecycle (before the component instance is even created). I no longer have to write all my functions in the <code is:raw>methods</code> property of the options API.</p>\n<p>In this example, I have written two basic functions, and those functions are not separated into a separate methods block like in <strong>Vue 2</strong>, they are inside <code is:raw>setup</code> with the related logic like the variable for <code is:raw>numEmployees</code>. I can make the functions available to the template by returning an object that includes them:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let numEmployees </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    function </span><span style="color: #D2A8FF">addEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      numEmployees.value</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    function </span><span style="color: #D2A8FF">subtractEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      numEmployees.value</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    return { numEmployees, addEmployees, subtractEmployees };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>Notice that there is no keyword <code is:raw>this</code> when referring to <code is:raw>numEmployees</code>. Methods that are inside the <code is:raw>setup</code> function no longer use the keyword <code is:raw>this</code> to refer to properties on the component instance since <code is:raw>setup</code> runs before the component instance is even created. I was very used to writing <code is:raw>this</code>-dot everything in <strong>Vue 2</strong>, but that is no longer the experience in <strong>Vue 3</strong>.</p>\n<p>The use of <code is:raw>ref()</code> surrounding the data property is something I introduced in the last post, and it\u2019s important here. For reactivity to work in Vue, the data being tracked needs to be wrapped in an object, which is why in <strong>Vue 2</strong>, the <code is:raw>data</code> method in the options API returned an object with those reactive data properties.</p>\n<p>Now, <strong>Vue 3</strong> uses <code is:raw>ref</code> to wrap primitive data in an object and <code is:raw>reactive</code> to make a copy of non-primitive data (I\u2019ve only introduced <code is:raw>ref</code> so far in this series). This is important to methods because it helps me understand why I see <code is:raw>numEmployees.value</code> inside the function rather than just <code is:raw>numEmployees</code>. I have to use <code is:raw>.value</code> to reach the property inside the object created by <code is:raw>ref</code> and then perform the action on that value property. (I don\u2019t have to use the <code is:raw>.value</code> property in the template, however. Just writing <code is:raw>numEmployees</code> grabs the value).</p>\n<p>Writing all the methods inside the setup function may seem like it would get messy when there is more complexity going on in the component, but in practice, <strong>related logic could all be grouped together to run within its own function</strong>. This is where <strong>Vue 3</strong> starts to show its strengths. I could group all the logic for updating headcount into a function called <code is:raw>updateHeadcount</code>, then create a separate JS file where that logic lives. I\u2019ll actually name it <code is:raw>useUpdateHeadcount.js</code>, which is <strong>Vue 3</strong> best-practice for naming this type of file (the convention of starting composables with <em>use</em> is discussed in the Composition API RFC in <a href="https://github.com/vuejs/composition-api-rfc/blob/master/index.md#logical-concerns-vs-option-types">this section</a>). Here\u2019s the <code is:raw>useUpdateHeadcount.js</code> file:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useUpdateHeadcount</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> numEmployees </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">addToEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numEmployees.value</span><span style="color: #FF7B72">++</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">subtractFromEmployees</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numEmployees.value</span><span style="color: #FF7B72">--</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { numEmployees, addToEmployees, subtractFromEmployees }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now, in my component, I just have to write this in the setup function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import useUpdateHeadcount from &quot;../composables/useUpdateHeadcount&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    const { numEmployees, addToEmployees, subtractFromEmployees } </span><span style="color: #FF7B72">=</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">useUpdateHeadcount</span><span style="color: #C9D1D9">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { numEmployees, addToEmployees, subtractFromEmployees };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span></code></pre>\n<h3 id="composables">Composables</h3>\n<p>Notice that I imported the <code is:raw>useUpdateHeadcount</code> file from a folder called <em>composables</em>. That\u2019s because these <em>functions to separate out logic by shared concerns</em> are known as <strong>composables</strong> in the <strong>Vue 3</strong> world. I\u2019m not going to go over all the details of how I wrote the composable and brought it back into the component file because I\u2019ll be doing a later blog post in the series about composables. In fact, I don\u2019t even have to use a composable; I can just write all my logic in the setup function since it\u2019s a very simple component. But I wanted to also make it clear that as the component gets more complicated, there is a strategy for organizing the logic, and it\u2019s one of <strong>Vue 3</strong>\u2019s most exciting features.</p>\n<h2 id="watch">Watch</h2>\n<p><code is:raw>watch</code> is basically the same in <strong>Vue 3</strong>, so I am happy to know that I can use it as I have before. In my example, I want to track the value of <code is:raw>numEmployees</code> to make sure it doesn\u2019t go below zero, since it\u2019s not possible to have negative human beings as employees.</p>\n<p>Here\u2019s my rendered component. It looks the same, but I added a disclaimer that the headcount cannot go below zero.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1643663535/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watch-headcount.png" alt="Component for adding or subtracting employees but restricted to not go below zero"></p>\n<p>This restriction - not going below zero - will be managed by the logic in <code is:raw>watch</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(numEmployees, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (numEmployees.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numEmployees.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>I specify which data property to track (<code is:raw>numEmployees</code>) as the first argument, and a <em>callback</em> as the second argument. Inside the callback, I have my logic that causes the side effect. If <code is:raw>numEmployees</code> reaches below zero, that side effect happens, setting the value to zero. The callback makes sure the side effect happens on the next tick following the value reaching below zero.</p>\n<p><code is:raw>watch</code> will not be triggered until that specific reactive property is changed, so if I want it to run immediately when the component is created, I can add an object with <code is:raw>immediate: true</code> like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(</span></span>\n<span class="line"><span style="color: #C9D1D9">  employees,</span></span>\n<span class="line"><span style="color: #C9D1D9">  (</span><span style="color: #FFA657">newVal</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">oldVal</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (employees.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      employees.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span>\n<span class="line"><span style="color: #C9D1D9">  { immediate: </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9"> }</span></span>\n<span class="line"><span style="color: #C9D1D9">)</span></span></code></pre>\n<p>The callback argument can also take two arguments for the <strong>new value</strong> and the <strong>old value</strong>, which makes <code is:raw>watch</code> useful for doing logic based on the previous state of the reactive property or just checking if a property has been changed (i.e. it\u2019s a great debugging tool):</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(employees, (</span><span style="color: #FFA657">newVal</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">oldVal</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(oldVal, newVal)</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>As for comparing <code is:raw>watch</code> in <strong>Vue 2</strong> versus <strong>Vue 3</strong>, the only difference is that in Vue 3 I can now place <code is:raw>watch</code> inside the setup function. Like methods, it no longer has to be separated out into its own section as an option property on the component instance.</p>\n<p>However, <strong>Vue 3</strong> also has added a similar feature that gives some different capabilities from <code is:raw>watch</code>: it\u2019s called <code is:raw>watchEffect</code>.</p>\n<h3 id="watcheffect">watchEffect</h3>\n<p>Vue 3 keeps <code is:raw>watch</code> the same, but it adds <code is:raw>watchEffect</code> as another way to cause side effects based on what happens to the reactive properties. Both <code is:raw>watch</code> and <code is:raw>watchEffect</code> are useful in different situations; one isn\u2019t better than the other.</p>\n<p>In this example, I will add another reactive property to the component - managers (<code is:raw>numManagers</code>). I want to track both managers and employees, and I want to restrict their values going below zero. Here is the component now:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1643663591/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watchEffect-headcount.png" alt="Component for adding or subtracting employees and manager but restricted to not go below zero"></p>\n<p>The reason I added a second reactive property is because <code is:raw>watchEffect</code> makes it easier to track multiple reactive properties. I no longer have to specify each property I want to track as the first argument of watch. Notice that I don\u2019t have a first argument to name the properties I\u2019m tracking:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watchEffect</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (numEmployees.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numEmployees.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (numManagers.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    numManagers.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>Unlike <code is:raw>watch</code>, <code is:raw>watchEffect</code> is not lazy loaded, so it will trigger automatically when the component is created. No need to add the object with <code is:raw>immediate: true</code>.</p>\n<p><code is:raw>watchEffect</code> is useful when I want to track changes to whatever property I want, and when I want the tracking to happen immediately.</p>\n<p><code is:raw>watch</code> is useful when I want to be more specific about tracking just one property, or if I want to have access to the new value and/or old value to use them in my logic.</p>\n<p>It\u2019s great having both features!</p>\n<h2 id="computed">Computed</h2>\n<p>One of the nice things about the Vue <code is:raw>template</code> is that I can write logic within double curly-braces, and that logic will be calculated based on whatever the values are represented by each variable:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">h2</span><span style="color: #C9D1D9">&gt;Headcount: {{ numEmployees + numManagers }}&lt;/</span><span style="color: #7EE787">h2</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>This will show a number which has been calculated, or <em>computed</em>, based on what <code is:raw>numEmployees</code> and <code is:raw>numManagers</code> are at the current point of time. And it will change if either of those data for <code is:raw>numEmployees</code> or <code is:raw>numManagers</code> change.</p>\n<p>Sometimes, the logic can get complicated or long. That\u2019s when I write a <code is:raw>computed</code> property in the <code is:raw>script</code> section, and refer to it in the template. Here is how I would do that in Vue 2:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9"> export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  computed: {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">headcount</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.employees.value </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.managers.value;</span></span>\n<span class="line"><span style="color: #C9D1D9">    },</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span>\n<span class="line"><span style="color: #FF7B72">}</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"></span></code></pre>\n<p>The computed property is another option that is part of the options API, and in <strong>Vue 2</strong>, it sits at the same level as <code is:raw>methods</code>, <code is:raw>data</code>, <code is:raw>watch</code>, and lifecycle methods like <code is:raw>mounted</code>.</p>\n<p>In <strong>Vue 3</strong>, computed can now be used in the <code is:raw>setup</code> function (I bet you didn\u2019t see that one coming). I have to import <code is:raw>computed</code> from Vue like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { computed } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span></code></pre>\n<p>To compute the number of employees and the number of managers, giving me the total headcount, I could write a computed like this:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">headcount</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">computed</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> numEmployees.value </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> numManagers.value</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>The only difference is that now I pass into the computed method an anonymous function, and I set it to the constant for headcount. I also have to return headcount from the setup function, along with everything else I want to be able to access from the template.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  numEmployees,</span></span>\n<span class="line"><span style="color: #C9D1D9">  numManagers,</span></span>\n<span class="line"><span style="color: #C9D1D9">  addToEmployees,</span></span>\n<span class="line"><span style="color: #C9D1D9">  subtractFromEmployees,</span></span>\n<span class="line"><span style="color: #C9D1D9">  addToManagers,</span></span>\n<span class="line"><span style="color: #C9D1D9">  subtractFromManagers,</span></span>\n<span class="line"><span style="color: #C9D1D9">  headcount, </span><span style="color: #8B949E">//&lt;----</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<h2 id="putting-it-all-together">Putting It All Together</h2>\n<p>At this point, I have logic that does the following:</p>\n<ul>\n<li>Adds or subtracts to the number of employees (numEmployees) or to the number of managers (numManagers)</li>\n<li>Makes sure employees and managers do not go below zero</li>\n<li>Computes the total headcount based on any changes</li>\n</ul>\n<div><CodeEmbed height="670" src="https://codepen.io/sandrarodgers/embed/ZEaQRLR" /></div>\n<h2 id="conclusion">Conclusion</h2>\n<p>And that wraps up this post in the series. Stay tuned for upcoming posts that cover topics like <code is:raw>ref</code> and <code is:raw>reactive</code>, <code is:raw>composables</code>, and the new <code is:raw>v-model</code>. And as always, feel free to reach out on <a href="https://twitter.com/sandra_rodgers_">Twitter</a>!</p>';
}
const $$Astro = createAstro("/Users/sandrarodgers/web-next/blog/src/content/blog/posts/diving-into-vue-3-methods-watch-and-computed/index.md", "https://blog.deepgram.com/", "file:///Users/sandrarodgers/web-next/blog/");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  new Slugger();
  return renderTemplate`<head>${renderHead($$result)}</head><p>In this series, I’m focusing on the basics needed to start working in <strong>Vue 3</strong> for people who might have some experience in <strong>Vue 2</strong>, but who haven’t yet built anything in <strong>Vue 3</strong>.</p>
<p>Check out my previous posts in the series:</p>
<ol>
<li>
<p><a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3: Getting Started</a></p>
</li>
<li>
<p><a href="">Diving Into Vue 3: The Setup Function</a></p>
</li>
</ol>
<p>Today, I’ll introduce how to use <code>methods</code>, <code>watch</code>, and <code>computed</code> in <strong>Vue 3</strong>, and I’ll also give a general comparison of <code>watch</code> and the new <code>watchEffect</code>.</p>
<h2 id="introduction">Introduction</h2>
<p>The way I learn best is by connecting abstract concepts to a real world situation, so I tried to think of a simple, realistic situation for using <code>methods</code>, <code>watch</code>, and <code>computed</code>. The situation would need to demonstrate the following:</p>
<ul>
<li>doing something to data properties to change them (using <code>methods</code>)</li>
<li>making something else occur (i.e, a side effect) because of a change to the data properties (using <code>watch</code>)</li>
<li>returning a value that is calculated based on data properties that have been changed (<code>computed</code>)</li>
</ul>
<p>I will use a real-world example of a company with employees and managers; the logic will help keep track of <em>number of employees</em>, <em>number of managers</em>, and <em>total company headcount</em>. Not the most exciting example, but I really just want to keep it simple.</p>
<h2 id="methods">Methods</h2>
<p>One of the first things I need to be able to do, whether I’m using <strong>Vue 2</strong> or <strong>Vue 3</strong>, is be able to make stuff happen with methods/functions (note: I’m using the terms <em>functions</em> and <em>methods</em> interchangeably in this section). The magic of Vue is its reactivity, so local state updates automatically as stuff happens. The stuff that happens is often triggered by <em>methods</em>.</p>
<p>In my real-world example, I want to create a component that has a variable to represent the <strong>number of employees</strong> with buttons I click to <strong>add or subtract the number of employees</strong>, changing the <strong>headcount</strong>. I’ll write functions to perform these basic actions.</p>
<p>Here’s what the rendered component looks like:</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1643663337/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/component-methods.png" alt="Rendered component to that uses method to increment and decrement"></p>
<p>I am familiar with the <strong>Vue 2</strong> way of adding functions to the component: add each function to the <code>methods</code> object:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> {</span></span>
<span class="line"><span style="color: #FFA657">  </span><span style="color: #D2A8FF">data</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      numEmployees: </span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    };</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span><span style="color: #FFA657">,</span></span>
<span class="line"><span style="color: #FFA657">  </span><span style="color: #C9D1D9">methods: {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">addEmployees</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numEmployees</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    },</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">subtractEmployees</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.numEmployees</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    },</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span><span style="color: #FFA657">,</span></span>
<span class="line"><span style="color: #FFA657">}</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>And the following line from the <code>template</code> shows that <strong>Vue 2</strong> and <strong>Vue 3</strong> are no different in how the methods are invoked in the <code>template</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9"> </span><span style="color: #FFA198">@click=&quot;addToEmployees()&quot;&gt;+&lt;/button&gt;</span></span></code></pre>
<p>However, <strong>Vue 3</strong> is different now in regards to where we write the methods in the <code>script</code>. In <strong>Vue 3</strong>, I can now write my functions <em>inside</em> the <code>setup</code> function, which runs very early in the component lifecycle (before the component instance is even created). I no longer have to write all my functions in the <code>methods</code> property of the options API.</p>
<p>In this example, I have written two basic functions, and those functions are not separated into a separate methods block like in <strong>Vue 2</strong>, they are inside <code>setup</code> with the related logic like the variable for <code>numEmployees</code>. I can make the functions available to the template by returning an object that includes them:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    let numEmployees </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    function </span><span style="color: #D2A8FF">addEmployees</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">      numEmployees.value</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    function </span><span style="color: #D2A8FF">subtractEmployees</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">      numEmployees.value</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    return { numEmployees, addEmployees, subtractEmployees };</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>Notice that there is no keyword <code>this</code> when referring to <code>numEmployees</code>. Methods that are inside the <code>setup</code> function no longer use the keyword <code>this</code> to refer to properties on the component instance since <code>setup</code> runs before the component instance is even created. I was very used to writing <code>this</code>-dot everything in <strong>Vue 2</strong>, but that is no longer the experience in <strong>Vue 3</strong>.</p>
<p>The use of <code>ref()</code> surrounding the data property is something I introduced in the last post, and it’s important here. For reactivity to work in Vue, the data being tracked needs to be wrapped in an object, which is why in <strong>Vue 2</strong>, the <code>data</code> method in the options API returned an object with those reactive data properties.</p>
<p>Now, <strong>Vue 3</strong> uses <code>ref</code> to wrap primitive data in an object and <code>reactive</code> to make a copy of non-primitive data (I’ve only introduced <code>ref</code> so far in this series). This is important to methods because it helps me understand why I see <code>numEmployees.value</code> inside the function rather than just <code>numEmployees</code>. I have to use <code>.value</code> to reach the property inside the object created by <code>ref</code> and then perform the action on that value property. (I don’t have to use the <code>.value</code> property in the template, however. Just writing <code>numEmployees</code> grabs the value).</p>
<p>Writing all the methods inside the setup function may seem like it would get messy when there is more complexity going on in the component, but in practice, <strong>related logic could all be grouped together to run within its own function</strong>. This is where <strong>Vue 3</strong> starts to show its strengths. I could group all the logic for updating headcount into a function called <code>updateHeadcount</code>, then create a separate JS file where that logic lives. I’ll actually name it <code>useUpdateHeadcount.js</code>, which is <strong>Vue 3</strong> best-practice for naming this type of file (the convention of starting composables with <em>use</em> is discussed in the Composition API RFC in <a href="https://github.com/vuejs/composition-api-rfc/blob/master/index.md#logical-concerns-vs-option-types">this section</a>). Here’s the <code>useUpdateHeadcount.js</code> file:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useUpdateHeadcount</span><span style="color: #FFA657">() </span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> numEmployees </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">addToEmployees</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    numEmployees.value</span><span style="color: #FF7B72">++</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">subtractFromEmployees</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    numEmployees.value</span><span style="color: #FF7B72">--</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { numEmployees, addToEmployees, subtractFromEmployees }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>Now, in my component, I just have to write this in the setup function:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">import useUpdateHeadcount from &quot;../composables/useUpdateHeadcount&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    const { numEmployees, addToEmployees, subtractFromEmployees } </span><span style="color: #FF7B72">=</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">useUpdateHeadcount</span><span style="color: #C9D1D9">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    return { numEmployees, addToEmployees, subtractFromEmployees };</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"></span></code></pre>
<h3 id="composables">Composables</h3>
<p>Notice that I imported the <code>useUpdateHeadcount</code> file from a folder called <em>composables</em>. That’s because these <em>functions to separate out logic by shared concerns</em> are known as <strong>composables</strong> in the <strong>Vue 3</strong> world. I’m not going to go over all the details of how I wrote the composable and brought it back into the component file because I’ll be doing a later blog post in the series about composables. In fact, I don’t even have to use a composable; I can just write all my logic in the setup function since it’s a very simple component. But I wanted to also make it clear that as the component gets more complicated, there is a strategy for organizing the logic, and it’s one of <strong>Vue 3</strong>’s most exciting features.</p>
<h2 id="watch">Watch</h2>
<p><code>watch</code> is basically the same in <strong>Vue 3</strong>, so I am happy to know that I can use it as I have before. In my example, I want to track the value of <code>numEmployees</code> to make sure it doesn’t go below zero, since it’s not possible to have negative human beings as employees.</p>
<p>Here’s my rendered component. It looks the same, but I added a disclaimer that the headcount cannot go below zero.</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1643663535/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watch-headcount.png" alt="Component for adding or subtracting employees but restricted to not go below zero"></p>
<p>This restriction - not going below zero - will be managed by the logic in <code>watch</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(numEmployees, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (numEmployees.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    numEmployees.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>I specify which data property to track (<code>numEmployees</code>) as the first argument, and a <em>callback</em> as the second argument. Inside the callback, I have my logic that causes the side effect. If <code>numEmployees</code> reaches below zero, that side effect happens, setting the value to zero. The callback makes sure the side effect happens on the next tick following the value reaching below zero.</p>
<p><code>watch</code> will not be triggered until that specific reactive property is changed, so if I want it to run immediately when the component is created, I can add an object with <code>immediate: true</code> like this:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(</span></span>
<span class="line"><span style="color: #C9D1D9">  employees,</span></span>
<span class="line"><span style="color: #C9D1D9">  (</span><span style="color: #FFA657">newVal</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">oldVal</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (employees.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">      employees.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">  { immediate: </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9"> }</span></span>
<span class="line"><span style="color: #C9D1D9">)</span></span></code></pre>
<p>The callback argument can also take two arguments for the <strong>new value</strong> and the <strong>old value</strong>, which makes <code>watch</code> useful for doing logic based on the previous state of the reactive property or just checking if a property has been changed (i.e. it’s a great debugging tool):</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(employees, (</span><span style="color: #FFA657">newVal</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">oldVal</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(oldVal, newVal)</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>As for comparing <code>watch</code> in <strong>Vue 2</strong> versus <strong>Vue 3</strong>, the only difference is that in Vue 3 I can now place <code>watch</code> inside the setup function. Like methods, it no longer has to be separated out into its own section as an option property on the component instance.</p>
<p>However, <strong>Vue 3</strong> also has added a similar feature that gives some different capabilities from <code>watch</code>: it’s called <code>watchEffect</code>.</p>
<h3 id="watcheffect">watchEffect</h3>
<p>Vue 3 keeps <code>watch</code> the same, but it adds <code>watchEffect</code> as another way to cause side effects based on what happens to the reactive properties. Both <code>watch</code> and <code>watchEffect</code> are useful in different situations; one isn’t better than the other.</p>
<p>In this example, I will add another reactive property to the component - managers (<code>numManagers</code>). I want to track both managers and employees, and I want to restrict their values going below zero. Here is the component now:</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1643663591/blog/2022/02/diving-into-vue-3-methods-watch-and-computed/watchEffect-headcount.png" alt="Component for adding or subtracting employees and manager but restricted to not go below zero"></p>
<p>The reason I added a second reactive property is because <code>watchEffect</code> makes it easier to track multiple reactive properties. I no longer have to specify each property I want to track as the first argument of watch. Notice that I don’t have a first argument to name the properties I’m tracking:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">watchEffect</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (numEmployees.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    numEmployees.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (numManagers.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    numManagers.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>Unlike <code>watch</code>, <code>watchEffect</code> is not lazy loaded, so it will trigger automatically when the component is created. No need to add the object with <code>immediate: true</code>.</p>
<p><code>watchEffect</code> is useful when I want to track changes to whatever property I want, and when I want the tracking to happen immediately.</p>
<p><code>watch</code> is useful when I want to be more specific about tracking just one property, or if I want to have access to the new value and/or old value to use them in my logic.</p>
<p>It’s great having both features!</p>
<h2 id="computed">Computed</h2>
<p>One of the nice things about the Vue <code>template</code> is that I can write logic within double curly-braces, and that logic will be calculated based on whatever the values are represented by each variable:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">h2</span><span style="color: #C9D1D9">&gt;Headcount: {{ numEmployees + numManagers }}&lt;/</span><span style="color: #7EE787">h2</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>This will show a number which has been calculated, or <em>computed</em>, based on what <code>numEmployees</code> and <code>numManagers</code> are at the current point of time. And it will change if either of those data for <code>numEmployees</code> or <code>numManagers</code> change.</p>
<p>Sometimes, the logic can get complicated or long. That’s when I write a <code>computed</code> property in the <code>script</code> section, and refer to it in the template. Here is how I would do that in Vue 2:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"></span>
<span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9"> export default </span><span style="color: #FF7B72">{</span></span>
<span class="line"><span style="color: #C9D1D9">  computed: {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">headcount</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.employees.value </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">.managers.value;</span></span>
<span class="line"><span style="color: #C9D1D9">    },</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #FF7B72">}</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"></span></code></pre>
<p>The computed property is another option that is part of the options API, and in <strong>Vue 2</strong>, it sits at the same level as <code>methods</code>, <code>data</code>, <code>watch</code>, and lifecycle methods like <code>mounted</code>.</p>
<p>In <strong>Vue 3</strong>, computed can now be used in the <code>setup</code> function (I bet you didn’t see that one coming). I have to import <code>computed</code> from Vue like this:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { computed } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span></code></pre>
<p>To compute the number of employees and the number of managers, giving me the total headcount, I could write a computed like this:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">headcount</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">computed</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> numEmployees.value </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> numManagers.value</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>The only difference is that now I pass into the computed method an anonymous function, and I set it to the constant for headcount. I also have to return headcount from the setup function, along with everything else I want to be able to access from the template.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  numEmployees,</span></span>
<span class="line"><span style="color: #C9D1D9">  numManagers,</span></span>
<span class="line"><span style="color: #C9D1D9">  addToEmployees,</span></span>
<span class="line"><span style="color: #C9D1D9">  subtractFromEmployees,</span></span>
<span class="line"><span style="color: #C9D1D9">  addToManagers,</span></span>
<span class="line"><span style="color: #C9D1D9">  subtractFromManagers,</span></span>
<span class="line"><span style="color: #C9D1D9">  headcount, </span><span style="color: #8B949E">//&lt;----</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<h2 id="putting-it-all-together">Putting It All Together</h2>
<p>At this point, I have logic that does the following:</p>
<ul>
<li>Adds or subtracts to the number of employees (numEmployees) or to the number of managers (numManagers)</li>
<li>Makes sure employees and managers do not go below zero</li>
<li>Computes the total headcount based on any changes</li>
</ul>
<div>${renderComponent($$result, "CodeEmbed", CodeEmbed, { "height": "670", "src": "https://codepen.io/sandrarodgers/embed/ZEaQRLR" })}</div>
<h2 id="conclusion">Conclusion</h2>
<p>And that wraps up this post in the series. Stay tuned for upcoming posts that cover topics like <code>ref</code> and <code>reactive</code>, <code>composables</code>, and the new <code>v-model</code>. And as always, feel free to reach out on <a href="https://twitter.com/sandra_rodgers_">Twitter</a>!</p>`;
}, "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/diving-into-vue-3-methods-watch-and-computed/index.md");

export { compiledContent, $$Index as default, frontmatter, metadata, rawContent };
