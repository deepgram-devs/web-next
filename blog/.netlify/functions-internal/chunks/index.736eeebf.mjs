import { c as createAstro, a as createComponent, r as renderTemplate, b as renderHead, d as renderComponent } from '../entry.mjs';
import Slugger from 'github-slugger';
import '@astrojs/netlify/netlify-functions.js';
import 'preact';
import 'preact-render-to-string';
import 'vue';
import 'vue/server-renderer';
import 'html-escaper';
import 'node-html-parser';
import 'axios';
/* empty css                           *//* empty css                           *//* empty css                           *//* empty css                           *//* empty css                          */import 'clone-deep';
import 'slugify';
import 'shiki';
/* empty css                           */import '@astrojs/rss';
/* empty css                           */import 'mime';
import 'cookie';
import 'kleur/colors';
import 'string-width';
import 'path-browserify';
import 'path-to-regexp';

const metadata = { "headings": [{ "depth": 2, "slug": "introduction", "text": "Introduction" }, { "depth": 2, "slug": "what-ill-build-today", "text": "What I\u2019ll Build Today" }, { "depth": 2, "slug": "setting-up-the-vue-project", "text": "Setting up the Vue Project" }, { "depth": 2, "slug": "the-folders-structure", "text": "The Folders Structure" }, { "depth": 3, "slug": "src-folder", "text": "SRC Folder" }, { "depth": 3, "slug": "mainjs", "text": "main.js" }, { "depth": 3, "slug": "appvue", "text": "App.vue" }, { "depth": 3, "slug": "views", "text": "views" }, { "depth": 3, "slug": "store", "text": "store" }, { "depth": 3, "slug": "router", "text": "router" }, { "depth": 3, "slug": "composables", "text": "composables" }, { "depth": 3, "slug": "components", "text": "components" }, { "depth": 2, "slug": "set-up-vue-router-and-the-views", "text": "Set up Vue Router and the Views" }, { "depth": 3, "slug": "vue-router-navigation-guards", "text": "Vue Router Navigation Guards" }, { "depth": 2, "slug": "set-up-vuex-to-manage-state", "text": "Set up Vuex to Manage State" }, { "depth": 3, "slug": "security", "text": "Security" }, { "depth": 2, "slug": "create-the-server-with-express", "text": "Create the Server with Express" }, { "depth": 3, "slug": "dependencies", "text": "Dependencies" }, { "depth": 4, "slug": "express", "text": "express" }, { "depth": 4, "slug": "body-parser", "text": "body-parser" }, { "depth": 4, "slug": "cors", "text": "cors" }, { "depth": 4, "slug": "dotenv", "text": "dotenv" }, { "depth": 3, "slug": "run-the-server", "text": "Run the server" }, { "depth": 3, "slug": "add-the-secret-code-value-to-env", "text": "Add the secret code value to .env" }, { "depth": 3, "slug": "create-the-secret-code-endpoint", "text": "Create the secret-code endpoint" }, { "depth": 3, "slug": "fetch-post-request", "text": "Fetch POST request" }, { "depth": 2, "slug": "conclusion", "text": "Conclusion" }], "source": '\n## Introduction\n\n<Panel type="info" title="Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)">\n<ol> \n<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>\n<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>\n<li><a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li>\n\n<li><a href="https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li>\n</ol>\n</Panel>\n\nIn my last post, I introduced how to build a vanilla Javascript and HTML live streaming web application with text captions. It included a barebones frontend that was just one page - the video player and captions.\n\nToday I\'m going to start building a full-stack application using the same technology, except instead of vanilla Javascript, I will use Vue 3.\n\nThe full-stack application will be expanded from the barebones version to include features that are often necessary for real-world applications, such as:\n\n*   a landing page that asks for a code to enter the site\n*   a router (**Vue Router**) to implement routes and a navigation guard so users can\'t access beyond the entry page unless they enter the correct code\n*   a state management library (**Vuex**) which will update state to allow access to the stream page if the correct code is entered\n*   a backend server (**node.js** and **express**) with two endpoints, one for getting a **Deepgram** temporary key so I can keep my Deepgram API key secure, and one for verifying the secret code the user must input to enter the site\n\nI recommend reading [the first post](https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/#setting-up-amazon-ivs) to go through how to set up the video streaming technologies, **Open Broadcaster Software**, and **Amazon IVS**. And for an introduction to Vue 3, it might be worth checking out my series [Diving Into Vue 3](https://blog.deepgram.com/diving-into-vue-3-getting-started/).\n\n## What I\'ll Build Today\n\nIn this post, I\'ll set up the router (Vue Router) and Vuex so that I can put a navigation guard on the entry page. I will also set up the backend server so I can keep my entry code secure.\n\nHere is the diagram to show the data flow and structure for what I will build today. The focus will be on building the protected entry with a navigation guard. If it seems complicated in the diagram, it won\'t by the end of the post because I plan to walk-through building this feature step-by-step.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/ProtectedEntrytoSite.png" alt="Protected entry diagram" style="width: 75%; margin:auto;">\n\n## Setting up the Vue Project\n\nAfter [installing the Vue CLI](https://cli.vuejs.org/guide/installation.html), I can create a new Vue project with this command:\n\n```bash\nvue create NAME-OF-PROJECT\n```\n\nI\'ll be sure to choose \'Manually select features\' so I can add some dependencies during the creation of the project:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets.png" alt="Presents including router and vuex" style="width: 75%; margin:auto;">\n\nThese are the presets I selected. I definitely recommend selecting Router and Vuex since those are required for this project, but the others are just my personal preference :\n\n![Presets for linting and router](https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets2.png)\n\nI\'ll select Vue 3, and then I\'ll `cd` into the folder.\n\nI can install all the rest of the dependencies now, or I can install them one by one as I need them. Here is a list of the dependencies I\'ll be using in this project:\n\n*   vue-router@4 (already installed when I manually selected presets)\n*   vuex@next (already installed when I manually selected presets)\n*   express\n*   dotenv\n*   cors\n*   body-parser\n*   @deepgram/sdk\n\nI can install them all at once with this command:\n\n```bash\nnpm install vue-router@4 vuex@next express dotenv cors body-parser @deepgram/sdk\n```\n\n## The Folders Structure\n\nA Vue application that is created using the Vue CLI starts out with this structure:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Vue-Folder-Structure.png" alt="Vue folder structure after creating new project" style="width: 50%; margin:auto;">\n\nThe `src` contains the folders that will make up the frontend, and I will add two files to the root of the project which will be required for the backend. Those two files will be a `server.js` file and a `.env` file. The final structure can be seen [here](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram) at the root level of the project in its GitHub repo.\n\n### SRC Folder\n\nI\'ll go over the SRC folder in more detail because the way I organize this folder reflects my thinking about how I\'ll make the application work when considering how the pieces should fit together.\n\nHere is the file structure of the SRC for the final project (these folders can be set up now or as I progress through building the project):\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/SRC-Folder-Structure.png" alt="Folder structure of SRC folder" style="width: 50%; margin:auto;">\n\nI\'ll go over the pieces starting from the bottom.\n\n### main.js\n\nThis is the file where Vue will be initialized, and also where Vue Router and Vuex (the store) will be brought into the project as plugins by way of `app.use()`.\n\n### App.vue\n\nThis is the top-most parent component, i.e., the **root component**. It holds all the Vue code (coming in as code in this file or code in child components) that will be injected into the `index.html` file, inside the `div` that has `id="app"`.\n\n### views\n\nThese are the pages that will be the main routes of the project. There will be a page that the user first lands on where they must enter a code. I will name it `EnterCode.vue`. And there will be a page that shows the live stream, with the video player and audio captions. I\'ll name that page `StreamChannel.vue`.\n\nHere is a screenshot of what the views will look like by the end of this post. A demo of the finished project can be found in the first post, which shows the styled version with the video live stream page.\n\n![Image of two page views](https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Two-Page-Views.png)\n\n### store\n\nThis is the folder that contains the Vuex store, a state management file. Some state properties need to be widely available throughout the application, not just in one component or one parent-child component. Vuex makes those state properties that I have put in the store available in any Vue files throughout the project.\n\n### router\n\nThis is the folder that contains the routes and creates the router, so that each view (page) can be navigated to when a user clicks on the link to that page. Using Vue Router means that a user can switch between page views without the page being reloaded every time the route changes.\n\n### composables\n\nThis folder contains composition functions that run the logic to make stuff happen, such as getting the user\'s microphone or bringing in the Amazon IVS player. Composition functions, or \'composables\', are a Vue 3 way of encapsulating logic that can then be run inside the setup function inside a component. Read more about composables [here](https://blog.deepgram.com/diving-into-vue-3-reusability-with-composables/#reusability-in-the-composition-api).\n\n### components\n\nThe components folder contains two components that will make up the StreamChannel page - the **VideoPlayer** component and the **AudioCaptions** component. I\'ll build these components in the next post in this series.\n\n## Set up Vue Router and the Views\n\nThe first thing I will do is create the two main pages I intend to make as part of this application - the landing page and the live stream page.\n\nI will create a views folder and put those two main page files in the folder:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Views.png" alt="Views folder with files" style="width: 50%; margin:auto;">\n\nFor each file, I\'ll be sure to put in some HTML that will display on the page, so I can see that my router is working:\n\n```html\n<template>\n  <div>\n    <h1>Enter Code</h1>\n  </div>\n</template>\n```\n\nWhen I created my project with the Vue CLI, I opted to add the Vue Router dependency, which means I have a router already created for me - the `index.js` file in the `router` folder. The index.js already has two routes set up - home and about.\n\nIf I start up the development server, I see that the links at the top of the page will take me between the two routes.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-About-Links.png" alt="Home and About links" style="width: 30%; margin:auto;">\n\nSince my project is only going to have two pages, I am just going to change the **home** and **about** views of the bootstrapped project to be the **EnterCode** view and the **StreamChannel** View.\n\nIn the router file, the three things each route object needs to have are:\n\n*   the path - the URL path for the route\n*   the name - the name I want to give this route (optional, but in my case, I do need it)\n*   the component - the component (view file) that will be loaded for this route\n\nHere is the code to set that up in the router:\n\n```js\nimport { createRouter, createWebHistory } from \'vue-router\'\nimport EnterCode from \'../views/EnterCode.vue\'\n\nconst routes = [\n  {\n    path: \'/\',\n    name: \'EnterCode\',\n    component: EnterCode,\n  },\n  {\n    path: \'/stream-channel\',\n    name: \'StreamChannel\',\n    component: () =>\n      import(/* webpackChunkName: "about" */ \'../views/StreamChannel.vue\'),\n  },\n]\n\nconst router = createRouter({\n  history: createWebHistory(process.env.BASE_URL),\n  routes,\n})\n\nexport default router\n```\n\nI need to go back to App.vue and change the router-links to match my new routes. Even though I\'ve named the landing page `EnterCode.vue`, I\'ll refer to it has **Home** for the user. Notice that the `to=""` attribute contains the path:\n\n```html\n<template>\n  <nav>\n    <router-link to="/">Home</router-link> |\n    <router-link to="/stream-channel">Channel</router-link>\n  </nav>\n  <router-view />\n</template>\n```\n\nNow I see that my two main pages can be accessed (without reloading the page!) when I click the link to switch to each route:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-Channel-Links.png" alt="Home (enter-code) and Channel Links" style="width: 30%; margin:auto;">\n\n### Vue Router Navigation Guards\n\nI want the landing page to have a form input where the user has to enter a code, and if the code is correct, they can move on to the channel page. See the code for this input [here](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/views/EnterCode.vue#L4).\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Input.png" alt="Input on enter code page" style="width: 50%; margin:auto;">\n\nBut if the code they enter is incorrect, I want to keep them from being able to navigate to that page. Right now, the channel page is completely open, and I can access it just by clicking the **Channel** link.\n\nI can set up a **navigation guard** to perform some logic when the router-link is clicked ([Read the docs](https://router.vuejs.org/guide/advanced/navigation-guards.html) for more information about navigation guards).\n\nThe logic will check to see if the correct code has been entered. If it has, the router will navigate to the channel page. If not, it will send them back to the home (`EnterCode.vue`) page.\n\nTo add a navigation guard, I use the `beforeEnter` guard:\n\n```js\n{\n path: "/stream-channel",\n name: "StreamChannel",\n component: () => import("../views/StreamChannel.vue"),\n beforeEnter(to, from, next) {\n   // ADD LOGIC HERE to check state of allowed access\n   next();\n },\n},\n```\n\nThe `next()` function will move the navigation forward to the route. I can use an **if statement** to keep that from happening unless certain circumstances are met.\n\nIf I include a name of a route in the next() function, the navigation will move to the route I have identified by name. In this example, it would cause navigation to stay on the **EnterCode** page since I have identified that `next` should move me to that route.\n\n```js\nbeforeEnter(to, from, next) {\n  // ADD LOGIC HERE to check state of allowed access\n  next({ name: "EnterCode" });\n},\n```\n\nI need to have some way of keeping track of the state of whether the correct code was entered or not. I will use the state management system, Vuex, which means I can now put this code in my router since the very next thing I will do is set up the store so there is a state property for `allowAccess`:\n\n```js\n{\n path: "/channel",\n name: "StreamChannel",\n component: () => import("../views/StreamChannel.vue"),\n beforeEnter(to, from, next) {\n   if (store.state.allowAccess === true) {\n     next();\n   } else {\n     next({ name: "EnterCode" });\n     alert("Please enter the secret code");\n   }\n },\n}\n```\n\nI\'ll probably see this error in the browser now since I\'ve referenced `store.state.allowAccess`, but the router file doesn\'t know what the `store` instance is.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/error-store.png" alt="Error: \'store\' is not defined" style="width: 50%; margin:auto;">\n\nTo make it go away, I need to import the store into the router by adding the following import statement to the router folder\'s `index.js` file.\n\n```js\nimport store from \'../store\'\n```\n\nThe [GitHub repo](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/router/index.js) has the code in its entirety for this stage of the project.\n\n## Set up Vuex to Manage State\n\nEven though this is a small application, I am choosing to include a Vuex store because it is common to use Vuex for the purpose of keeping track of whether a user is authenticated/logged-in or not.\n\nIn this project, I will use the Vuex store to keep track of whether a correct entry code has been entered or not by the user. The state property will be called `allowAccess`, and its default state will be false. It will change to true when a user enters the correct code.\n\nHere is the store with the state property I have created:\n\n```js\nimport { createStore } from \'vuex\'\n\nconst store = createStore({\n  state() {\n    return {\n      allowAccess: false,\n    }\n  },\n})\nexport default store\n```\n\nI need to connect the input on the landing (EntryCode) page with this property in state. When the user types a correct code into that input, the submit button triggers a function that checks if the code is correct, and then if it is, dispatches an action to the store, which will cause `allowAccess` to update to `true`.\n\nThe way Vuex causes state to change is through this pattern:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979626/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/vuex.png" alt="Vuex pattern" style="width: 80%; margin:auto;">\n\nVue Component dispatch action -> Store action commit mutation -> Store mutation change state\n\nHere is that flow in the actual code in my project.\n\n1.  The Vue component *EnterCode* form submit button triggers `submitCode()`:\n\n```html\n<form @submit.prevent="submitCode">\n  <label for="code"> Code: </label>\n  <input v-model="code" type="password" name="code" value />\n  <button type="submit" name="button" class="dg-btn">Submit</button>\n</form>\n```\n\n2.  The `submitCode()` method dispatches the `verifyCode` action (which is [passed as a string](https://vuex.vuejs.org/guide/actions.html#dispatching-actions) `\'verifyCode\'`) with a *payload* of `true` or `false`:\n\n```js\nfunction submitCode() {\n  if (code.value === \'pb\') {\n    store.dispatch(\'verifyCode\', true)\n  } else {\n    store.dispatch(\'verifyCode\', false)\n  }\n  code.value = \'\'\n}\n```\n\n3.  The `verifyCode` action in the store commits the `verifyCode` mutation, sending the `true` or `false` payload, referred to hear as `status`:\n\n```js\nactions: {\n verifyCode({ commit }, status) {\n   commit("verifyCode", status);\n },\n},\n```\n\n4.  The `verifyCode` mutation changes state so `allowAccess` equals the `status` payload of `true` or `false`\n\n```js\nmutations: {\n verifyCode(state, status) {\n   state.allowAccess = status;\n },\n},\n```\n\nThe last thing to do is navigate with the router to the *StreamChannel* page if a correct code has been entered (i.e., state for `allowAccess` in the store has changed to true) or alert the user if they have entered the wrong code.\n\n```js\n//StreamChannel.vue\n\nfunction submitCode() {\n  if (code.value === \'PB\') {\n    store.dispatch(\'verifyCode\', true)\n  } else {\n    store.dispatch(\'verifyCode\', false)\n  }\n  // Navigate if correct code, alert if not correct\n  if (store.state.allowAccess) {\n    router.push({ name: \'StreamChannel\' })\n  } else {\n    alert(\'Incorrect code\')\n  }\n  code.value = \'\'\n}\n```\n\nThis version of the project, with the setup I just did for Vue Router and Vuex, can be seen in its entirety in the repo branch titled [vuex-no-server-yet](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/vuex-no-server-yet).\n\n### Security\n\nThe example so far is not very secure because I check for the correct code on the frontend, and that entry code is right there in plain Vue (no pun intended) in the client:\n\n```js\nif (code.value === "pb")\n```\n\nThe more secure way to handle this would be to create a backend server file with an endpoint to check if the code is correct and store that code securely in the server, or even better (so it does not get exposed in GitHub) in a `.env` file.\n\nIn the next section, I\'ll introduce that more secure method of checking the code. I\'ll still use everything I just set up for Vuex, but instead of checking the code in the `EnterCode.vue` file, I\'ll use a fetch request to send that code to the backend for verification.\n\n## Create the Server with Express\n\nNow I\'ll set up my server file, which I\'ll use today for making the entry code more secure, and which I\'ll use in the next post for setting up the Deepgram token endpoint.\n\nAt the root of the project, I\'ll create a `server.js` file and a `.env` file.\n\nI\'ll add this code to create my basic server.\n\n```js\n// bring in node modules\nrequire(\'dotenv\').config()\nconst express = require(\'express\')\nconst app = express()\nvar bodyParser = require(\'body-parser\')\nconst cors = require(\'cors\')\n\n// identify port number\nconst port = 8080\n\n// express use() function to add third-party middleware\napp.use(cors())\napp.use(bodyParser.json())\n\n// ENDPOINT WILL GO HERE\n\n// Connect host to port\napp.listen(port, () => {\n  console.log(`Example app listening at http://localhost:${port}`)\n})\n```\n\n### Dependencies\n\nHere is a brief explanation of each dependency I\'m using in this server file.\n\n#### express\n\n[Express](https://expressjs.com/) is a *node.js* framework that gives me utility methods and middleware to help with setting up routing endpoints (the endpoints deal with requests that come in from the frontend).\n\n#### body-parser\n\nBody-parser is middleware that can take an incoming request body and parse the data. I\'ll be using the JSON parser because the secret entry code will be sent from the frontend as JSON.\n\n#### cors\n\nThis is another middleware package that will help to handle requests from the frontend, specifically cross-origin requests.\n\nSince the client and server have a different origin from each other (such as localhost:8080 vs. localhost:8081), I would need to add a CORS response header `access-control-allow-origins` with information about permitted origins. The CORS middleware will add that header automatically for every request that is sent to the server.\n\n#### dotenv\n\nThis is a very important node module. It allows me to use environment variables in my server file, pulling the values for those variables from the `.env` file. The `.env` file will never be tracked by git, so I can put anything super-secret in the `.env` file and not worry that it will end up on Github for the world to see.\n\n### Run the server\n\nNow I can start up the server to check that everything is working so far.\n\nI will add a script command to the `package.json` file to make it easier to start up the server. In my `package.json`, in the "scripts" object, I\'ll add one for "start":\n\n```js\n"scripts": {\n  "serve": "vue-cli-service serve",\n  ...\n  "start": "node server.js"\n},\n```\n\nNow, in the terminal, when I\'m in the project folder, I can type `npm run start` to start the backend server, and if I open another terminal, I can type `npm run serve` to start the frontend development server.\n\n### Add the secret code value to `.env`\n\nBefore I set up the endpoint, I want to put the expected code value in the `.env` file so that I can access it in the server using `process.env.SECRET_CODE`.\n\nIn the `.env` file, I will add the secret code that I want users to type into the input on the frontend to be able to enter the site. I can add any value I want. In this case, I\'ll just make the value \'code\' (in the earlier section, I used \'pb\' as the code, but I\'m using \'code\' here to make it more obvious that this is the code):\n\n```bash\nSECRET_CODE="code"\n```\n\n### Create the secret-code endpoint\n\nNow I\'ll start on the backend creating the endpoint. The endpoint will expect a value to come in from the frontend (the code entered by the user). Since a value is being sent back, this will be a POST request endpoint.\n\n```js\napp.post(\'/secret-code\', async (req, res) => {})\n```\n\nThe app.post() method is available because of express, and it requires the route path as a slash and whatever I want to name the path, in this case `"/secret-code"`.\n\nWhen the code is sent from the frontend to the backend, it comes in as part of the request body (which is an object), so I will get the code value from `req.body`. Because I plan to send it back in a JSON object as `{ code: "code" }`, the value will come back as `req.body.code`.\n\n```js\nif (req.body.code._value === process.env.SECRET_CODE)\n```\n\nHowever, the value that is sent back is put into another object, which I see when I examine the shape of the req.body.code by using `console.log`. I see this:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/reqbodycode.png" alt="req.body.code object shape" style="width: 50%; margin:auto;">\n\nThe `_value` property actually contains the value that I want to match to my code value I have put in the `.env` file. So I need to access it with `req.body.code._value`. This is how I can check that there is a match:\n\n```js\napp.post(\'/secret-code\', async (req, res) => {\n  if (req.body.code._value === process.env.SECRET_CODE) {\n    res.status(200).json(\'Correct code\')\n  } else {\n    res.status(200).json(\'Incorrect code\')\n  }\n})\n```\n\nThe `res.status()` method will send back the result status code, and the .json() method will make sure it returns to the frontend as JSON data.\n\nNow I can go back to the frontend and write a fetch request that will send the secret code that I need for this verification.\n\n### Fetch POST request\n\nTo write a fetch POST request, I will use [the fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).\n\nTo write a fetch request, I use the `fetch()` method with a first argument of the endpoint path (including the port number) and the second argument an options object:\n\n```js\nfetch(\'http://localhost:8080/secret-code\', requestOptions)\n```\n\nThe options object will give information about the type of request (POST), the headers (to tell that the content will be of the type JSON) and the request body (I will send a JSON object that contains the code):\n\n```js\nconst requestOptions = {\n  method: \'POST\',\n  headers: { \'Content-Type\': \'application/json\' },\n  body: JSON.stringify({ code: code }),\n}\n```\n\nThe fetch request will send the code to the backend server, and since that will take a little bit of time, I will use a promise to wait for the response, doing the following action once that response has been returned. To use a promise, I will attach a `.then()` to the request, which means that anything inside the `.then()` will happen after the response is returned from the fetch request.\n\nOnce the response returns, I will turn it back into JSON and then take that response data to verify if it is correct or not. Depending on if it is correct, I update the state in the store.\n\nRemember, for a verified response of true, I am expecting the backend server to return a response with a JSON string of `"Correct code"`:\n\n```js\nfetch(\'http://localhost:8080/secret-code\', requestOptions)\n  .then((response) => response.json())\n  .then((data) => {\n    if (data === \'Correct code\') {\n      //dispatch payload to store\n    }\n  })\n  .then(() => {\n    if (store.state.allowAccess) {\n      // navigate to channel or alert that code is wrong\n    }\n  })\n```\n\nI\'ve created a branch in the repo called [vuex-with-server ](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-with-server/src/views/EnterCode.vue)where the code from this step can be viewed in its entirety.\n\n## Conclusion\n\nIn this post, I set up a Vue project and added some of the common features used in a full-stack application: routes, a state management library, and a backend server with endpoints.\n\nNow I am ready to build the **Channel** page, which will contain the video player for my live stream and the audio captions that display the transcript.\n\nPreviously, I went over how to build a live stream web application with **Amazon IVS**, using only vanilla javascript and HTML. But now, I want to use the Vue framework to help me build this in a way that is more reusable, and that incorporates common practices for using Vue.js.\n\nIn my next post, I will introduce how to build the **Amazon IVS** player using **Vue 3 composables**, which will give me a chance to discuss more specifically some of the new features of Vue 3.\n\nI will also introduce how to use Vue 3 composables to create the **Deepgram captions**, and I\'ll include a more secure way of connecting to Deepgram by requesting a Deepgram token from the backend.\n\nI hope you\'ll join me for my next post. As always, feel free to reach out on [Twitter](https://twitter.com/sandra_rodgers_).\n\n        ', "html": `<h2 id="introduction">Introduction</h2>
<Panel type="info" title="Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)"><ol><li><a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>
<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>
<li><a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li><li><a href="https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li></ol></Panel>
<p>In my last post, I introduced how to build a vanilla Javascript and HTML live streaming web application with text captions. It included a barebones frontend that was just one page - the video player and captions.</p>
<p>Today I\u2019m going to start building a full-stack application using the same technology, except instead of vanilla Javascript, I will use Vue 3.</p>
<p>The full-stack application will be expanded from the barebones version to include features that are often necessary for real-world applications, such as:</p>
<ul>
<li>a landing page that asks for a code to enter the site</li>
<li>a router (<strong>Vue Router</strong>) to implement routes and a navigation guard so users can\u2019t access beyond the entry page unless they enter the correct code</li>
<li>a state management library (<strong>Vuex</strong>) which will update state to allow access to the stream page if the correct code is entered</li>
<li>a backend server (<strong>node.js</strong> and <strong>express</strong>) with two endpoints, one for getting a <strong>Deepgram</strong> temporary key so I can keep my Deepgram API key secure, and one for verifying the secret code the user must input to enter the site</li>
</ul>
<p>I recommend reading <a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/#setting-up-amazon-ivs">the first post</a> to go through how to set up the video streaming technologies, <strong>Open Broadcaster Software</strong>, and <strong>Amazon IVS</strong>. And for an introduction to Vue 3, it might be worth checking out my series <a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3</a>.</p>
<h2 id="what-ill-build-today">What I\u2019ll Build Today</h2>
<p>In this post, I\u2019ll set up the router (Vue Router) and Vuex so that I can put a navigation guard on the entry page. I will also set up the backend server so I can keep my entry code secure.</p>
<p>Here is the diagram to show the data flow and structure for what I will build today. The focus will be on building the protected entry with a navigation guard. If it seems complicated in the diagram, it won\u2019t by the end of the post because I plan to walk-through building this feature step-by-step.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/ProtectedEntrytoSite.png" alt="Protected entry diagram" style="width: 75%; margin:auto;" />
<h2 id="setting-up-the-vue-project">Setting up the Vue Project</h2>
<p>After <a href="https://cli.vuejs.org/guide/installation.html">installing the Vue CLI</a>, I can create a new Vue project with this command:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">vue create NAME-OF-PROJECT</span></span></code></pre>
<p>I\u2019ll be sure to choose \u2018Manually select features\u2019 so I can add some dependencies during the creation of the project:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets.png" alt="Presents including router and vuex" style="width: 75%; margin:auto;" />
<p>These are the presets I selected. I definitely recommend selecting Router and Vuex since those are required for this project, but the others are just my personal preference :</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets2.png" alt="Presets for linting and router"></p>
<p>I\u2019ll select Vue 3, and then I\u2019ll <code is:raw>cd</code> into the folder.</p>
<p>I can install all the rest of the dependencies now, or I can install them one by one as I need them. Here is a list of the dependencies I\u2019ll be using in this project:</p>
<ul>
<li>vue-router@4 (already installed when I manually selected presets)</li>
<li>vuex@next (already installed when I manually selected presets)</li>
<li>express</li>
<li>dotenv</li>
<li>cors</li>
<li>body-parser</li>
<li>@deepgram/sdk</li>
</ul>
<p>I can install them all at once with this command:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">npm install vue-router@4 vuex@next express dotenv cors body-parser @deepgram/sdk</span></span></code></pre>
<h2 id="the-folders-structure">The Folders Structure</h2>
<p>A Vue application that is created using the Vue CLI starts out with this structure:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Vue-Folder-Structure.png" alt="Vue folder structure after creating new project" style="width: 50%; margin:auto;" />
<p>The <code is:raw>src</code> contains the folders that will make up the frontend, and I will add two files to the root of the project which will be required for the backend. Those two files will be a <code is:raw>server.js</code> file and a <code is:raw>.env</code> file. The final structure can be seen <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram">here</a> at the root level of the project in its GitHub repo.</p>
<h3 id="src-folder">SRC Folder</h3>
<p>I\u2019ll go over the SRC folder in more detail because the way I organize this folder reflects my thinking about how I\u2019ll make the application work when considering how the pieces should fit together.</p>
<p>Here is the file structure of the SRC for the final project (these folders can be set up now or as I progress through building the project):</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/SRC-Folder-Structure.png" alt="Folder structure of SRC folder" style="width: 50%; margin:auto;" />
<p>I\u2019ll go over the pieces starting from the bottom.</p>
<h3 id="mainjs">main.js</h3>
<p>This is the file where Vue will be initialized, and also where Vue Router and Vuex (the store) will be brought into the project as plugins by way of <code is:raw>app.use()</code>.</p>
<h3 id="appvue">App.vue</h3>
<p>This is the top-most parent component, i.e., the <strong>root component</strong>. It holds all the Vue code (coming in as code in this file or code in child components) that will be injected into the <code is:raw>index.html</code> file, inside the <code is:raw>div</code> that has <code is:raw>id="app"</code>.</p>
<h3 id="views">views</h3>
<p>These are the pages that will be the main routes of the project. There will be a page that the user first lands on where they must enter a code. I will name it <code is:raw>EnterCode.vue</code>. And there will be a page that shows the live stream, with the video player and audio captions. I\u2019ll name that page <code is:raw>StreamChannel.vue</code>.</p>
<p>Here is a screenshot of what the views will look like by the end of this post. A demo of the finished project can be found in the first post, which shows the styled version with the video live stream page.</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Two-Page-Views.png" alt="Image of two page views"></p>
<h3 id="store">store</h3>
<p>This is the folder that contains the Vuex store, a state management file. Some state properties need to be widely available throughout the application, not just in one component or one parent-child component. Vuex makes those state properties that I have put in the store available in any Vue files throughout the project.</p>
<h3 id="router">router</h3>
<p>This is the folder that contains the routes and creates the router, so that each view (page) can be navigated to when a user clicks on the link to that page. Using Vue Router means that a user can switch between page views without the page being reloaded every time the route changes.</p>
<h3 id="composables">composables</h3>
<p>This folder contains composition functions that run the logic to make stuff happen, such as getting the user\u2019s microphone or bringing in the Amazon IVS player. Composition functions, or \u2018composables\u2019, are a Vue 3 way of encapsulating logic that can then be run inside the setup function inside a component. Read more about composables <a href="https://blog.deepgram.com/diving-into-vue-3-reusability-with-composables/#reusability-in-the-composition-api">here</a>.</p>
<h3 id="components">components</h3>
<p>The components folder contains two components that will make up the StreamChannel page - the <strong>VideoPlayer</strong> component and the <strong>AudioCaptions</strong> component. I\u2019ll build these components in the next post in this series.</p>
<h2 id="set-up-vue-router-and-the-views">Set up Vue Router and the Views</h2>
<p>The first thing I will do is create the two main pages I intend to make as part of this application - the landing page and the live stream page.</p>
<p>I will create a views folder and put those two main page files in the folder:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Views.png" alt="Views folder with files" style="width: 50%; margin:auto;" />
<p>For each file, I\u2019ll be sure to put in some HTML that will display on the page, so I can see that my router is working:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;Enter Code&lt;/</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>When I created my project with the Vue CLI, I opted to add the Vue Router dependency, which means I have a router already created for me - the <code is:raw>index.js</code> file in the <code is:raw>router</code> folder. The index.js already has two routes set up - home and about.</p>
<p>If I start up the development server, I see that the links at the top of the page will take me between the two routes.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-About-Links.png" alt="Home and About links" style="width: 30%; margin:auto;" />
<p>Since my project is only going to have two pages, I am just going to change the <strong>home</strong> and <strong>about</strong> views of the bootstrapped project to be the <strong>EnterCode</strong> view and the <strong>StreamChannel</strong> View.</p>
<p>In the router file, the three things each route object needs to have are:</p>
<ul>
<li>the path - the URL path for the route</li>
<li>the name - the name I want to give this route (optional, but in my case, I do need it)</li>
<li>the component - the component (view file) that will be loaded for this route</li>
</ul>
<p>Here is the code to set that up in the router:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { createRouter, createWebHistory } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue-router&#39;</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> EnterCode </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../views/EnterCode.vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">routes</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> [</span></span>
<span class="line"><span style="color: #C9D1D9">  {</span></span>
<span class="line"><span style="color: #C9D1D9">    path: </span><span style="color: #A5D6FF">&#39;/&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    name: </span><span style="color: #A5D6FF">&#39;EnterCode&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    component: EnterCode,</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">  {</span></span>
<span class="line"><span style="color: #C9D1D9">    path: </span><span style="color: #A5D6FF">&#39;/stream-channel&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    name: </span><span style="color: #A5D6FF">&#39;StreamChannel&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">component</span><span style="color: #C9D1D9">: () </span><span style="color: #FF7B72">=&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">import</span><span style="color: #C9D1D9">(</span><span style="color: #8B949E">/* webpackChunkName: &quot;about&quot; */</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../views/StreamChannel.vue&#39;</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">router</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">createRouter</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">  history: </span><span style="color: #D2A8FF">createWebHistory</span><span style="color: #C9D1D9">(process.env.</span><span style="color: #79C0FF">BASE_URL</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9">  routes,</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #C9D1D9">router</span></span></code></pre>
<p>I need to go back to App.vue and change the router-links to match my new routes. Even though I\u2019ve named the landing page <code is:raw>EnterCode.vue</code>, I\u2019ll refer to it has <strong>Home</strong> for the user. Notice that the <code is:raw>to=""</code> attribute contains the path:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">nav</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">to</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;/&quot;</span><span style="color: #C9D1D9">&gt;Home&lt;/</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9">&gt; |</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">to</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;/stream-channel&quot;</span><span style="color: #C9D1D9">&gt;Channel&lt;/</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">nav</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">router-view</span><span style="color: #C9D1D9"> /&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>Now I see that my two main pages can be accessed (without reloading the page!) when I click the link to switch to each route:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-Channel-Links.png" alt="Home (enter-code) and Channel Links" style="width: 30%; margin:auto;" />
<h3 id="vue-router-navigation-guards">Vue Router Navigation Guards</h3>
<p>I want the landing page to have a form input where the user has to enter a code, and if the code is correct, they can move on to the channel page. See the code for this input <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/views/EnterCode.vue#L4">here</a>.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Input.png" alt="Input on enter code page" style="width: 50%; margin:auto;" />
<p>But if the code they enter is incorrect, I want to keep them from being able to navigate to that page. Right now, the channel page is completely open, and I can access it just by clicking the <strong>Channel</strong> link.</p>
<p>I can set up a <strong>navigation guard</strong> to perform some logic when the router-link is clicked (<a href="https://router.vuejs.org/guide/advanced/navigation-guards.html">Read the docs</a> for more information about navigation guards).</p>
<p>The logic will check to see if the correct code has been entered. If it has, the router will navigate to the channel page. If not, it will send them back to the home (<code is:raw>EnterCode.vue</code>) page.</p>
<p>To add a navigation guard, I use the <code is:raw>beforeEnter</code> guard:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">path</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;/stream-channel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">name</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;StreamChannel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">component</span><span style="color: #C9D1D9">: () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;../views/StreamChannel.vue&quot;</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">beforeEnter</span><span style="color: #C9D1D9">(to, from, next) {</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E">// ADD LOGIC HERE to check state of allowed access</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>The <code is:raw>next()</code> function will move the navigation forward to the route. I can use an <strong>if statement</strong> to keep that from happening unless certain circumstances are met.</p>
<p>If I include a name of a route in the next() function, the navigation will move to the route I have identified by name. In this example, it would cause navigation to stay on the <strong>EnterCode</strong> page since I have identified that <code is:raw>next</code> should move me to that route.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">beforeEnter</span><span style="color: #C9D1D9">(to, from, next) {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// ADD LOGIC HERE to check state of allowed access</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">({ name: </span><span style="color: #A5D6FF">&quot;EnterCode&quot;</span><span style="color: #C9D1D9"> });</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>I need to have some way of keeping track of the state of whether the correct code was entered or not. I will use the state management system, Vuex, which means I can now put this code in my router since the very next thing I will do is set up the store so there is a state property for <code is:raw>allowAccess</code>:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">path</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;/channel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">name</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;StreamChannel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">component</span><span style="color: #C9D1D9">: () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;../views/StreamChannel.vue&quot;</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">beforeEnter</span><span style="color: #C9D1D9">(to, from, next) {</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (store.state.allowAccess </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9">   } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">({ name: </span><span style="color: #A5D6FF">&quot;EnterCode&quot;</span><span style="color: #C9D1D9"> });</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #D2A8FF">alert</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Please enter the secret code&quot;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">   }</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>I\u2019ll probably see this error in the browser now since I\u2019ve referenced <code is:raw>store.state.allowAccess</code>, but the router file doesn\u2019t know what the <code is:raw>store</code> instance is.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/error-store.png" alt="Error: 'store' is not defined" style="width: 50%; margin:auto;" />
<p>To make it go away, I need to import the store into the router by adding the following import statement to the router folder\u2019s <code is:raw>index.js</code> file.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> store </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../store&#39;</span></span></code></pre>
<p>The <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/router/index.js">GitHub repo</a> has the code in its entirety for this stage of the project.</p>
<h2 id="set-up-vuex-to-manage-state">Set up Vuex to Manage State</h2>
<p>Even though this is a small application, I am choosing to include a Vuex store because it is common to use Vuex for the purpose of keeping track of whether a user is authenticated/logged-in or not.</p>
<p>In this project, I will use the Vuex store to keep track of whether a correct entry code has been entered or not by the user. The state property will be called <code is:raw>allowAccess</code>, and its default state will be false. It will change to true when a user enters the correct code.</p>
<p>Here is the store with the state property I have created:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { createStore } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vuex&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">store</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">createStore</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">state</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      allowAccess: </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #C9D1D9">store</span></span></code></pre>
<p>I need to connect the input on the landing (EntryCode) page with this property in state. When the user types a correct code into that input, the submit button triggers a function that checks if the code is correct, and then if it is, dispatches an action to the store, which will cause <code is:raw>allowAccess</code> to update to <code is:raw>true</code>.</p>
<p>The way Vuex causes state to change is through this pattern:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979626/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/vuex.png" alt="Vuex pattern" style="width: 80%; margin:auto;" />
<p>Vue Component dispatch action -> Store action commit mutation -> Store mutation change state</p>
<p>Here is that flow in the actual code in my project.</p>
<ol>
<li>The Vue component <em>EnterCode</em> form submit button triggers <code is:raw>submitCode()</code>:</li>
</ol>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">form</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">@submit.prevent</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;submitCode&quot;</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">label</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">for</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;code&quot;</span><span style="color: #C9D1D9">&gt; Code: &lt;/</span><span style="color: #7EE787">label</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">input</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">v-model</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;code&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">type</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;password&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">name</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;code&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">value</span><span style="color: #C9D1D9"> /&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">type</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;submit&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">name</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;button&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;dg-btn&quot;</span><span style="color: #C9D1D9">&gt;Submit&lt;/</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">form</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<ol start="2">
<li>The <code is:raw>submitCode()</code> method dispatches the <code is:raw>verifyCode</code> action (which is <a href="https://vuex.vuejs.org/guide/actions.html#dispatching-actions">passed as a string</a> <code is:raw>'verifyCode'</code>) with a <em>payload</em> of <code is:raw>true</code> or <code is:raw>false</code>:</li>
</ol>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">submitCode</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (code.value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;pb&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  code.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<ol start="3">
<li>The <code is:raw>verifyCode</code> action in the store commits the <code is:raw>verifyCode</code> mutation, sending the <code is:raw>true</code> or <code is:raw>false</code> payload, referred to hear as <code is:raw>status</code>:</li>
</ol>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FFA657">actions</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">verifyCode</span><span style="color: #C9D1D9">({ commit }, status) {</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #D2A8FF">commit</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;verifyCode&quot;</span><span style="color: #C9D1D9">, status);</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<ol start="4">
<li>The <code is:raw>verifyCode</code> mutation changes state so <code is:raw>allowAccess</code> equals the <code is:raw>status</code> payload of <code is:raw>true</code> or <code is:raw>false</code></li>
</ol>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FFA657">mutations</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">verifyCode</span><span style="color: #C9D1D9">(state, status) {</span></span>
<span class="line"><span style="color: #C9D1D9">   state.allowAccess </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> status;</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>The last thing to do is navigate with the router to the <em>StreamChannel</em> page if a correct code has been entered (i.e., state for <code is:raw>allowAccess</code> in the store has changed to true) or alert the user if they have entered the wrong code.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//StreamChannel.vue</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">submitCode</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (code.value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;PB&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// Navigate if correct code, alert if not correct</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (store.state.allowAccess) {</span></span>
<span class="line"><span style="color: #C9D1D9">    router.</span><span style="color: #D2A8FF">push</span><span style="color: #C9D1D9">({ name: </span><span style="color: #A5D6FF">&#39;StreamChannel&#39;</span><span style="color: #C9D1D9"> })</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">alert</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Incorrect code&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  code.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>This version of the project, with the setup I just did for Vue Router and Vuex, can be seen in its entirety in the repo branch titled <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/vuex-no-server-yet">vuex-no-server-yet</a>.</p>
<h3 id="security">Security</h3>
<p>The example so far is not very secure because I check for the correct code on the frontend, and that entry code is right there in plain Vue (no pun intended) in the client:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (code.value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;pb&quot;</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>The more secure way to handle this would be to create a backend server file with an endpoint to check if the code is correct and store that code securely in the server, or even better (so it does not get exposed in GitHub) in a <code is:raw>.env</code> file.</p>
<p>In the next section, I\u2019ll introduce that more secure method of checking the code. I\u2019ll still use everything I just set up for Vuex, but instead of checking the code in the <code is:raw>EnterCode.vue</code> file, I\u2019ll use a fetch request to send that code to the backend for verification.</p>
<h2 id="create-the-server-with-express">Create the Server with Express</h2>
<p>Now I\u2019ll set up my server file, which I\u2019ll use today for making the entry code more secure, and which I\u2019ll use in the next post for setting up the Deepgram token endpoint.</p>
<p>At the root of the project, I\u2019ll create a <code is:raw>server.js</code> file and a <code is:raw>.env</code> file.</p>
<p>I\u2019ll add this code to create my basic server.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// bring in node modules</span></span>
<span class="line"><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;dotenv&#39;</span><span style="color: #C9D1D9">).</span><span style="color: #D2A8FF">config</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">express</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;express&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">app</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">express</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #FF7B72">var</span><span style="color: #C9D1D9"> bodyParser </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;body-parser&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">cors</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;cors&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// identify port number</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">port</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8080</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// express use() function to add third-party middleware</span></span>
<span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">use</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">cors</span><span style="color: #C9D1D9">())</span></span>
<span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">use</span><span style="color: #C9D1D9">(bodyParser.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">())</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// ENDPOINT WILL GO HERE</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// Connect host to port</span></span>
<span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">listen</span><span style="color: #C9D1D9">(port, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">\`Example app listening at http://localhost:\${</span><span style="color: #C9D1D9">port</span><span style="color: #A5D6FF">}\`</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<h3 id="dependencies">Dependencies</h3>
<p>Here is a brief explanation of each dependency I\u2019m using in this server file.</p>
<h4 id="express">express</h4>
<p><a href="https://expressjs.com/">Express</a> is a <em>node.js</em> framework that gives me utility methods and middleware to help with setting up routing endpoints (the endpoints deal with requests that come in from the frontend).</p>
<h4 id="body-parser">body-parser</h4>
<p>Body-parser is middleware that can take an incoming request body and parse the data. I\u2019ll be using the JSON parser because the secret entry code will be sent from the frontend as JSON.</p>
<h4 id="cors">cors</h4>
<p>This is another middleware package that will help to handle requests from the frontend, specifically cross-origin requests.</p>
<p>Since the client and server have a different origin from each other (such as localhost:8080 vs. localhost:8081), I would need to add a CORS response header <code is:raw>access-control-allow-origins</code> with information about permitted origins. The CORS middleware will add that header automatically for every request that is sent to the server.</p>
<h4 id="dotenv">dotenv</h4>
<p>This is a very important node module. It allows me to use environment variables in my server file, pulling the values for those variables from the <code is:raw>.env</code> file. The <code is:raw>.env</code> file will never be tracked by git, so I can put anything super-secret in the <code is:raw>.env</code> file and not worry that it will end up on Github for the world to see.</p>
<h3 id="run-the-server">Run the server</h3>
<p>Now I can start up the server to check that everything is working so far.</p>
<p>I will add a script command to the <code is:raw>package.json</code> file to make it easier to start up the server. In my <code is:raw>package.json</code>, in the \u201Cscripts\u201D object, I\u2019ll add one for \u201Cstart\u201D:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #A5D6FF">&quot;scripts&quot;</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #A5D6FF">&quot;serve&quot;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;vue-cli-service serve&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">...</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #A5D6FF">&quot;start&quot;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;node server.js&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>Now, in the terminal, when I\u2019m in the project folder, I can type <code is:raw>npm run start</code> to start the backend server, and if I open another terminal, I can type <code is:raw>npm run serve</code> to start the frontend development server.</p>
<h3 id="add-the-secret-code-value-to-env">Add the secret code value to <code is:raw>.env</code></h3>
<p>Before I set up the endpoint, I want to put the expected code value in the <code is:raw>.env</code> file so that I can access it in the server using <code is:raw>process.env.SECRET_CODE</code>.</p>
<p>In the <code is:raw>.env</code> file, I will add the secret code that I want users to type into the input on the frontend to be able to enter the site. I can add any value I want. In this case, I\u2019ll just make the value \u2018code\u2019 (in the earlier section, I used \u2018pb\u2019 as the code, but I\u2019m using \u2018code\u2019 here to make it more obvious that this is the code):</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">SECRET_CODE=</span><span style="color: #A5D6FF">&quot;code&quot;</span></span></code></pre>
<h3 id="create-the-secret-code-endpoint">Create the secret-code endpoint</h3>
<p>Now I\u2019ll start on the backend creating the endpoint. The endpoint will expect a value to come in from the frontend (the code entered by the user). Since a value is being sent back, this will be a POST request endpoint.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">post</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;/secret-code&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">req</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {})</span></span></code></pre>
<p>The app.post() method is available because of express, and it requires the route path as a slash and whatever I want to name the path, in this case <code is:raw>"/secret-code"</code>.</p>
<p>When the code is sent from the frontend to the backend, it comes in as part of the request body (which is an object), so I will get the code value from <code is:raw>req.body</code>. Because I plan to send it back in a JSON object as <code is:raw>{ code: "code" }</code>, the value will come back as <code is:raw>req.body.code</code>.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (req.body.code._value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> process.env.</span><span style="color: #79C0FF">SECRET_CODE</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>However, the value that is sent back is put into another object, which I see when I examine the shape of the req.body.code by using <code is:raw>console.log</code>. I see this:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/reqbodycode.png" alt="req.body.code object shape" style="width: 50%; margin:auto;" />
<p>The <code is:raw>_value</code> property actually contains the value that I want to match to my code value I have put in the <code is:raw>.env</code> file. So I need to access it with <code is:raw>req.body.code._value</code>. This is how I can check that there is a match:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">post</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;/secret-code&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">req</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (req.body.code._value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> process.env.</span><span style="color: #79C0FF">SECRET_CODE</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    res.</span><span style="color: #D2A8FF">status</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">).</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Correct code&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    res.</span><span style="color: #D2A8FF">status</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">).</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Incorrect code&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>The <code is:raw>res.status()</code> method will send back the result status code, and the .json() method will make sure it returns to the frontend as JSON data.</p>
<p>Now I can go back to the frontend and write a fetch request that will send the secret code that I need for this verification.</p>
<h3 id="fetch-post-request">Fetch POST request</h3>
<p>To write a fetch POST request, I will use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">the fetch API</a>.</p>
<p>To write a fetch request, I use the <code is:raw>fetch()</code> method with a first argument of the endpoint path (including the port number) and the second argument an options object:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/secret-code&#39;</span><span style="color: #C9D1D9">, requestOptions)</span></span></code></pre>
<p>The options object will give information about the type of request (POST), the headers (to tell that the content will be of the type JSON) and the request body (I will send a JSON object that contains the code):</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">requestOptions</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  method: </span><span style="color: #A5D6FF">&#39;POST&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">  headers: { </span><span style="color: #A5D6FF">&#39;Content-Type&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;application/json&#39;</span><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">  body: </span><span style="color: #79C0FF">JSON</span><span style="color: #C9D1D9">.</span><span style="color: #D2A8FF">stringify</span><span style="color: #C9D1D9">({ code: code }),</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>The fetch request will send the code to the backend server, and since that will take a little bit of time, I will use a promise to wait for the response, doing the following action once that response has been returned. To use a promise, I will attach a <code is:raw>.then()</code> to the request, which means that anything inside the <code is:raw>.then()</code> will happen after the response is returned from the fetch request.</p>
<p>Once the response returns, I will turn it back into JSON and then take that response data to verify if it is correct or not. Depending on if it is correct, I update the state in the store.</p>
<p>Remember, for a verified response of true, I am expecting the backend server to return a response with a JSON string of <code is:raw>"Correct code"</code>:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/secret-code&#39;</span><span style="color: #C9D1D9">, requestOptions)</span></span>
<span class="line"><span style="color: #C9D1D9">  .</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">response</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> response.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">())</span></span>
<span class="line"><span style="color: #C9D1D9">  .</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">data</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (data </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Correct code&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">//dispatch payload to store</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span>
<span class="line"><span style="color: #C9D1D9">  .</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (store.state.allowAccess) {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// navigate to channel or alert that code is wrong</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span></code></pre>
<p>I\u2019ve created a branch in the repo called <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-with-server/src/views/EnterCode.vue">vuex-with-server </a>where the code from this step can be viewed in its entirety.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post, I set up a Vue project and added some of the common features used in a full-stack application: routes, a state management library, and a backend server with endpoints.</p>
<p>Now I am ready to build the <strong>Channel</strong> page, which will contain the video player for my live stream and the audio captions that display the transcript.</p>
<p>Previously, I went over how to build a live stream web application with <strong>Amazon IVS</strong>, using only vanilla javascript and HTML. But now, I want to use the Vue framework to help me build this in a way that is more reusable, and that incorporates common practices for using Vue.js.</p>
<p>In my next post, I will introduce how to build the <strong>Amazon IVS</strong> player using <strong>Vue 3 composables</strong>, which will give me a chance to discuss more specifically some of the new features of Vue 3.</p>
<p>I will also introduce how to use Vue 3 composables to create the <strong>Deepgram captions</strong>, and I\u2019ll include a more secure way of connecting to Deepgram by requesting a Deepgram token from the backend.</p>
<p>I hope you\u2019ll join me for my next post. As always, feel free to reach out on <a href="https://twitter.com/sandra_rodgers_">Twitter</a>.</p>` };
const frontmatter = { "title": "Build a Live Streaming Web Application: Vue and Express Setup", "description": "In this series, learn how to build a live streaming web application using Deepgram's speech-to-text API and Amazon Interactive Video Service.", "date": "2022-03-18T00:00:00.000Z", "cover": "https://res.cloudinary.com/deepgram/image/upload/v1647979609/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Building-Livestreaming-w-AmazonIVS.jpg", "authors": ["sandra-rodgers"], "category": "tutorial", "tags": ["aws", "javascript", "serverless"], "seo": { "title": "Build a Live Streaming Web Application: Vue and Express Setup", "description": "In this series, learn how to build a live streaming web application using Deepgram's speech-to-text API and Amazon Interactive Video Service." }, "shorturls": { "share": "https://dpgr.am/c1a13f1", "twitter": "https://dpgr.am/e7a043f", "linkedin": "https://dpgr.am/ec098b9", "reddit": "https://dpgr.am/952b793", "facebook": "https://dpgr.am/3d3cf68" }, "og": { "image": "https://res.cloudinary.com/deepgram/image/upload/v1661454011/blog/build-a-livestream-web-application-vue-and-express-setup/ograph.png" }, "astro": { "headings": [{ "depth": 2, "slug": "introduction", "text": "Introduction" }, { "depth": 2, "slug": "what-ill-build-today", "text": "What I\u2019ll Build Today" }, { "depth": 2, "slug": "setting-up-the-vue-project", "text": "Setting up the Vue Project" }, { "depth": 2, "slug": "the-folders-structure", "text": "The Folders Structure" }, { "depth": 3, "slug": "src-folder", "text": "SRC Folder" }, { "depth": 3, "slug": "mainjs", "text": "main.js" }, { "depth": 3, "slug": "appvue", "text": "App.vue" }, { "depth": 3, "slug": "views", "text": "views" }, { "depth": 3, "slug": "store", "text": "store" }, { "depth": 3, "slug": "router", "text": "router" }, { "depth": 3, "slug": "composables", "text": "composables" }, { "depth": 3, "slug": "components", "text": "components" }, { "depth": 2, "slug": "set-up-vue-router-and-the-views", "text": "Set up Vue Router and the Views" }, { "depth": 3, "slug": "vue-router-navigation-guards", "text": "Vue Router Navigation Guards" }, { "depth": 2, "slug": "set-up-vuex-to-manage-state", "text": "Set up Vuex to Manage State" }, { "depth": 3, "slug": "security", "text": "Security" }, { "depth": 2, "slug": "create-the-server-with-express", "text": "Create the Server with Express" }, { "depth": 3, "slug": "dependencies", "text": "Dependencies" }, { "depth": 4, "slug": "express", "text": "express" }, { "depth": 4, "slug": "body-parser", "text": "body-parser" }, { "depth": 4, "slug": "cors", "text": "cors" }, { "depth": 4, "slug": "dotenv", "text": "dotenv" }, { "depth": 3, "slug": "run-the-server", "text": "Run the server" }, { "depth": 3, "slug": "add-the-secret-code-value-to-env", "text": "Add the secret code value to .env" }, { "depth": 3, "slug": "create-the-secret-code-endpoint", "text": "Create the secret-code endpoint" }, { "depth": 3, "slug": "fetch-post-request", "text": "Fetch POST request" }, { "depth": 2, "slug": "conclusion", "text": "Conclusion" }], "source": '\n## Introduction\n\n<Panel type="info" title="Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)">\n<ol> \n<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>\n<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>\n<li><a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li>\n\n<li><a href="https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li>\n</ol>\n</Panel>\n\nIn my last post, I introduced how to build a vanilla Javascript and HTML live streaming web application with text captions. It included a barebones frontend that was just one page - the video player and captions.\n\nToday I\'m going to start building a full-stack application using the same technology, except instead of vanilla Javascript, I will use Vue 3.\n\nThe full-stack application will be expanded from the barebones version to include features that are often necessary for real-world applications, such as:\n\n*   a landing page that asks for a code to enter the site\n*   a router (**Vue Router**) to implement routes and a navigation guard so users can\'t access beyond the entry page unless they enter the correct code\n*   a state management library (**Vuex**) which will update state to allow access to the stream page if the correct code is entered\n*   a backend server (**node.js** and **express**) with two endpoints, one for getting a **Deepgram** temporary key so I can keep my Deepgram API key secure, and one for verifying the secret code the user must input to enter the site\n\nI recommend reading [the first post](https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/#setting-up-amazon-ivs) to go through how to set up the video streaming technologies, **Open Broadcaster Software**, and **Amazon IVS**. And for an introduction to Vue 3, it might be worth checking out my series [Diving Into Vue 3](https://blog.deepgram.com/diving-into-vue-3-getting-started/).\n\n## What I\'ll Build Today\n\nIn this post, I\'ll set up the router (Vue Router) and Vuex so that I can put a navigation guard on the entry page. I will also set up the backend server so I can keep my entry code secure.\n\nHere is the diagram to show the data flow and structure for what I will build today. The focus will be on building the protected entry with a navigation guard. If it seems complicated in the diagram, it won\'t by the end of the post because I plan to walk-through building this feature step-by-step.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/ProtectedEntrytoSite.png" alt="Protected entry diagram" style="width: 75%; margin:auto;">\n\n## Setting up the Vue Project\n\nAfter [installing the Vue CLI](https://cli.vuejs.org/guide/installation.html), I can create a new Vue project with this command:\n\n```bash\nvue create NAME-OF-PROJECT\n```\n\nI\'ll be sure to choose \'Manually select features\' so I can add some dependencies during the creation of the project:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets.png" alt="Presents including router and vuex" style="width: 75%; margin:auto;">\n\nThese are the presets I selected. I definitely recommend selecting Router and Vuex since those are required for this project, but the others are just my personal preference :\n\n![Presets for linting and router](https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets2.png)\n\nI\'ll select Vue 3, and then I\'ll `cd` into the folder.\n\nI can install all the rest of the dependencies now, or I can install them one by one as I need them. Here is a list of the dependencies I\'ll be using in this project:\n\n*   vue-router@4 (already installed when I manually selected presets)\n*   vuex@next (already installed when I manually selected presets)\n*   express\n*   dotenv\n*   cors\n*   body-parser\n*   @deepgram/sdk\n\nI can install them all at once with this command:\n\n```bash\nnpm install vue-router@4 vuex@next express dotenv cors body-parser @deepgram/sdk\n```\n\n## The Folders Structure\n\nA Vue application that is created using the Vue CLI starts out with this structure:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Vue-Folder-Structure.png" alt="Vue folder structure after creating new project" style="width: 50%; margin:auto;">\n\nThe `src` contains the folders that will make up the frontend, and I will add two files to the root of the project which will be required for the backend. Those two files will be a `server.js` file and a `.env` file. The final structure can be seen [here](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram) at the root level of the project in its GitHub repo.\n\n### SRC Folder\n\nI\'ll go over the SRC folder in more detail because the way I organize this folder reflects my thinking about how I\'ll make the application work when considering how the pieces should fit together.\n\nHere is the file structure of the SRC for the final project (these folders can be set up now or as I progress through building the project):\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/SRC-Folder-Structure.png" alt="Folder structure of SRC folder" style="width: 50%; margin:auto;">\n\nI\'ll go over the pieces starting from the bottom.\n\n### main.js\n\nThis is the file where Vue will be initialized, and also where Vue Router and Vuex (the store) will be brought into the project as plugins by way of `app.use()`.\n\n### App.vue\n\nThis is the top-most parent component, i.e., the **root component**. It holds all the Vue code (coming in as code in this file or code in child components) that will be injected into the `index.html` file, inside the `div` that has `id="app"`.\n\n### views\n\nThese are the pages that will be the main routes of the project. There will be a page that the user first lands on where they must enter a code. I will name it `EnterCode.vue`. And there will be a page that shows the live stream, with the video player and audio captions. I\'ll name that page `StreamChannel.vue`.\n\nHere is a screenshot of what the views will look like by the end of this post. A demo of the finished project can be found in the first post, which shows the styled version with the video live stream page.\n\n![Image of two page views](https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Two-Page-Views.png)\n\n### store\n\nThis is the folder that contains the Vuex store, a state management file. Some state properties need to be widely available throughout the application, not just in one component or one parent-child component. Vuex makes those state properties that I have put in the store available in any Vue files throughout the project.\n\n### router\n\nThis is the folder that contains the routes and creates the router, so that each view (page) can be navigated to when a user clicks on the link to that page. Using Vue Router means that a user can switch between page views without the page being reloaded every time the route changes.\n\n### composables\n\nThis folder contains composition functions that run the logic to make stuff happen, such as getting the user\'s microphone or bringing in the Amazon IVS player. Composition functions, or \'composables\', are a Vue 3 way of encapsulating logic that can then be run inside the setup function inside a component. Read more about composables [here](https://blog.deepgram.com/diving-into-vue-3-reusability-with-composables/#reusability-in-the-composition-api).\n\n### components\n\nThe components folder contains two components that will make up the StreamChannel page - the **VideoPlayer** component and the **AudioCaptions** component. I\'ll build these components in the next post in this series.\n\n## Set up Vue Router and the Views\n\nThe first thing I will do is create the two main pages I intend to make as part of this application - the landing page and the live stream page.\n\nI will create a views folder and put those two main page files in the folder:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Views.png" alt="Views folder with files" style="width: 50%; margin:auto;">\n\nFor each file, I\'ll be sure to put in some HTML that will display on the page, so I can see that my router is working:\n\n```html\n<template>\n  <div>\n    <h1>Enter Code</h1>\n  </div>\n</template>\n```\n\nWhen I created my project with the Vue CLI, I opted to add the Vue Router dependency, which means I have a router already created for me - the `index.js` file in the `router` folder. The index.js already has two routes set up - home and about.\n\nIf I start up the development server, I see that the links at the top of the page will take me between the two routes.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-About-Links.png" alt="Home and About links" style="width: 30%; margin:auto;">\n\nSince my project is only going to have two pages, I am just going to change the **home** and **about** views of the bootstrapped project to be the **EnterCode** view and the **StreamChannel** View.\n\nIn the router file, the three things each route object needs to have are:\n\n*   the path - the URL path for the route\n*   the name - the name I want to give this route (optional, but in my case, I do need it)\n*   the component - the component (view file) that will be loaded for this route\n\nHere is the code to set that up in the router:\n\n```js\nimport { createRouter, createWebHistory } from \'vue-router\'\nimport EnterCode from \'../views/EnterCode.vue\'\n\nconst routes = [\n  {\n    path: \'/\',\n    name: \'EnterCode\',\n    component: EnterCode,\n  },\n  {\n    path: \'/stream-channel\',\n    name: \'StreamChannel\',\n    component: () =>\n      import(/* webpackChunkName: "about" */ \'../views/StreamChannel.vue\'),\n  },\n]\n\nconst router = createRouter({\n  history: createWebHistory(process.env.BASE_URL),\n  routes,\n})\n\nexport default router\n```\n\nI need to go back to App.vue and change the router-links to match my new routes. Even though I\'ve named the landing page `EnterCode.vue`, I\'ll refer to it has **Home** for the user. Notice that the `to=""` attribute contains the path:\n\n```html\n<template>\n  <nav>\n    <router-link to="/">Home</router-link> |\n    <router-link to="/stream-channel">Channel</router-link>\n  </nav>\n  <router-view />\n</template>\n```\n\nNow I see that my two main pages can be accessed (without reloading the page!) when I click the link to switch to each route:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-Channel-Links.png" alt="Home (enter-code) and Channel Links" style="width: 30%; margin:auto;">\n\n### Vue Router Navigation Guards\n\nI want the landing page to have a form input where the user has to enter a code, and if the code is correct, they can move on to the channel page. See the code for this input [here](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/views/EnterCode.vue#L4).\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Input.png" alt="Input on enter code page" style="width: 50%; margin:auto;">\n\nBut if the code they enter is incorrect, I want to keep them from being able to navigate to that page. Right now, the channel page is completely open, and I can access it just by clicking the **Channel** link.\n\nI can set up a **navigation guard** to perform some logic when the router-link is clicked ([Read the docs](https://router.vuejs.org/guide/advanced/navigation-guards.html) for more information about navigation guards).\n\nThe logic will check to see if the correct code has been entered. If it has, the router will navigate to the channel page. If not, it will send them back to the home (`EnterCode.vue`) page.\n\nTo add a navigation guard, I use the `beforeEnter` guard:\n\n```js\n{\n path: "/stream-channel",\n name: "StreamChannel",\n component: () => import("../views/StreamChannel.vue"),\n beforeEnter(to, from, next) {\n   // ADD LOGIC HERE to check state of allowed access\n   next();\n },\n},\n```\n\nThe `next()` function will move the navigation forward to the route. I can use an **if statement** to keep that from happening unless certain circumstances are met.\n\nIf I include a name of a route in the next() function, the navigation will move to the route I have identified by name. In this example, it would cause navigation to stay on the **EnterCode** page since I have identified that `next` should move me to that route.\n\n```js\nbeforeEnter(to, from, next) {\n  // ADD LOGIC HERE to check state of allowed access\n  next({ name: "EnterCode" });\n},\n```\n\nI need to have some way of keeping track of the state of whether the correct code was entered or not. I will use the state management system, Vuex, which means I can now put this code in my router since the very next thing I will do is set up the store so there is a state property for `allowAccess`:\n\n```js\n{\n path: "/channel",\n name: "StreamChannel",\n component: () => import("../views/StreamChannel.vue"),\n beforeEnter(to, from, next) {\n   if (store.state.allowAccess === true) {\n     next();\n   } else {\n     next({ name: "EnterCode" });\n     alert("Please enter the secret code");\n   }\n },\n}\n```\n\nI\'ll probably see this error in the browser now since I\'ve referenced `store.state.allowAccess`, but the router file doesn\'t know what the `store` instance is.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/error-store.png" alt="Error: \'store\' is not defined" style="width: 50%; margin:auto;">\n\nTo make it go away, I need to import the store into the router by adding the following import statement to the router folder\'s `index.js` file.\n\n```js\nimport store from \'../store\'\n```\n\nThe [GitHub repo](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/router/index.js) has the code in its entirety for this stage of the project.\n\n## Set up Vuex to Manage State\n\nEven though this is a small application, I am choosing to include a Vuex store because it is common to use Vuex for the purpose of keeping track of whether a user is authenticated/logged-in or not.\n\nIn this project, I will use the Vuex store to keep track of whether a correct entry code has been entered or not by the user. The state property will be called `allowAccess`, and its default state will be false. It will change to true when a user enters the correct code.\n\nHere is the store with the state property I have created:\n\n```js\nimport { createStore } from \'vuex\'\n\nconst store = createStore({\n  state() {\n    return {\n      allowAccess: false,\n    }\n  },\n})\nexport default store\n```\n\nI need to connect the input on the landing (EntryCode) page with this property in state. When the user types a correct code into that input, the submit button triggers a function that checks if the code is correct, and then if it is, dispatches an action to the store, which will cause `allowAccess` to update to `true`.\n\nThe way Vuex causes state to change is through this pattern:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979626/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/vuex.png" alt="Vuex pattern" style="width: 80%; margin:auto;">\n\nVue Component dispatch action -> Store action commit mutation -> Store mutation change state\n\nHere is that flow in the actual code in my project.\n\n1.  The Vue component *EnterCode* form submit button triggers `submitCode()`:\n\n```html\n<form @submit.prevent="submitCode">\n  <label for="code"> Code: </label>\n  <input v-model="code" type="password" name="code" value />\n  <button type="submit" name="button" class="dg-btn">Submit</button>\n</form>\n```\n\n2.  The `submitCode()` method dispatches the `verifyCode` action (which is [passed as a string](https://vuex.vuejs.org/guide/actions.html#dispatching-actions) `\'verifyCode\'`) with a *payload* of `true` or `false`:\n\n```js\nfunction submitCode() {\n  if (code.value === \'pb\') {\n    store.dispatch(\'verifyCode\', true)\n  } else {\n    store.dispatch(\'verifyCode\', false)\n  }\n  code.value = \'\'\n}\n```\n\n3.  The `verifyCode` action in the store commits the `verifyCode` mutation, sending the `true` or `false` payload, referred to hear as `status`:\n\n```js\nactions: {\n verifyCode({ commit }, status) {\n   commit("verifyCode", status);\n },\n},\n```\n\n4.  The `verifyCode` mutation changes state so `allowAccess` equals the `status` payload of `true` or `false`\n\n```js\nmutations: {\n verifyCode(state, status) {\n   state.allowAccess = status;\n },\n},\n```\n\nThe last thing to do is navigate with the router to the *StreamChannel* page if a correct code has been entered (i.e., state for `allowAccess` in the store has changed to true) or alert the user if they have entered the wrong code.\n\n```js\n//StreamChannel.vue\n\nfunction submitCode() {\n  if (code.value === \'PB\') {\n    store.dispatch(\'verifyCode\', true)\n  } else {\n    store.dispatch(\'verifyCode\', false)\n  }\n  // Navigate if correct code, alert if not correct\n  if (store.state.allowAccess) {\n    router.push({ name: \'StreamChannel\' })\n  } else {\n    alert(\'Incorrect code\')\n  }\n  code.value = \'\'\n}\n```\n\nThis version of the project, with the setup I just did for Vue Router and Vuex, can be seen in its entirety in the repo branch titled [vuex-no-server-yet](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/vuex-no-server-yet).\n\n### Security\n\nThe example so far is not very secure because I check for the correct code on the frontend, and that entry code is right there in plain Vue (no pun intended) in the client:\n\n```js\nif (code.value === "pb")\n```\n\nThe more secure way to handle this would be to create a backend server file with an endpoint to check if the code is correct and store that code securely in the server, or even better (so it does not get exposed in GitHub) in a `.env` file.\n\nIn the next section, I\'ll introduce that more secure method of checking the code. I\'ll still use everything I just set up for Vuex, but instead of checking the code in the `EnterCode.vue` file, I\'ll use a fetch request to send that code to the backend for verification.\n\n## Create the Server with Express\n\nNow I\'ll set up my server file, which I\'ll use today for making the entry code more secure, and which I\'ll use in the next post for setting up the Deepgram token endpoint.\n\nAt the root of the project, I\'ll create a `server.js` file and a `.env` file.\n\nI\'ll add this code to create my basic server.\n\n```js\n// bring in node modules\nrequire(\'dotenv\').config()\nconst express = require(\'express\')\nconst app = express()\nvar bodyParser = require(\'body-parser\')\nconst cors = require(\'cors\')\n\n// identify port number\nconst port = 8080\n\n// express use() function to add third-party middleware\napp.use(cors())\napp.use(bodyParser.json())\n\n// ENDPOINT WILL GO HERE\n\n// Connect host to port\napp.listen(port, () => {\n  console.log(`Example app listening at http://localhost:${port}`)\n})\n```\n\n### Dependencies\n\nHere is a brief explanation of each dependency I\'m using in this server file.\n\n#### express\n\n[Express](https://expressjs.com/) is a *node.js* framework that gives me utility methods and middleware to help with setting up routing endpoints (the endpoints deal with requests that come in from the frontend).\n\n#### body-parser\n\nBody-parser is middleware that can take an incoming request body and parse the data. I\'ll be using the JSON parser because the secret entry code will be sent from the frontend as JSON.\n\n#### cors\n\nThis is another middleware package that will help to handle requests from the frontend, specifically cross-origin requests.\n\nSince the client and server have a different origin from each other (such as localhost:8080 vs. localhost:8081), I would need to add a CORS response header `access-control-allow-origins` with information about permitted origins. The CORS middleware will add that header automatically for every request that is sent to the server.\n\n#### dotenv\n\nThis is a very important node module. It allows me to use environment variables in my server file, pulling the values for those variables from the `.env` file. The `.env` file will never be tracked by git, so I can put anything super-secret in the `.env` file and not worry that it will end up on Github for the world to see.\n\n### Run the server\n\nNow I can start up the server to check that everything is working so far.\n\nI will add a script command to the `package.json` file to make it easier to start up the server. In my `package.json`, in the "scripts" object, I\'ll add one for "start":\n\n```js\n"scripts": {\n  "serve": "vue-cli-service serve",\n  ...\n  "start": "node server.js"\n},\n```\n\nNow, in the terminal, when I\'m in the project folder, I can type `npm run start` to start the backend server, and if I open another terminal, I can type `npm run serve` to start the frontend development server.\n\n### Add the secret code value to `.env`\n\nBefore I set up the endpoint, I want to put the expected code value in the `.env` file so that I can access it in the server using `process.env.SECRET_CODE`.\n\nIn the `.env` file, I will add the secret code that I want users to type into the input on the frontend to be able to enter the site. I can add any value I want. In this case, I\'ll just make the value \'code\' (in the earlier section, I used \'pb\' as the code, but I\'m using \'code\' here to make it more obvious that this is the code):\n\n```bash\nSECRET_CODE="code"\n```\n\n### Create the secret-code endpoint\n\nNow I\'ll start on the backend creating the endpoint. The endpoint will expect a value to come in from the frontend (the code entered by the user). Since a value is being sent back, this will be a POST request endpoint.\n\n```js\napp.post(\'/secret-code\', async (req, res) => {})\n```\n\nThe app.post() method is available because of express, and it requires the route path as a slash and whatever I want to name the path, in this case `"/secret-code"`.\n\nWhen the code is sent from the frontend to the backend, it comes in as part of the request body (which is an object), so I will get the code value from `req.body`. Because I plan to send it back in a JSON object as `{ code: "code" }`, the value will come back as `req.body.code`.\n\n```js\nif (req.body.code._value === process.env.SECRET_CODE)\n```\n\nHowever, the value that is sent back is put into another object, which I see when I examine the shape of the req.body.code by using `console.log`. I see this:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/reqbodycode.png" alt="req.body.code object shape" style="width: 50%; margin:auto;">\n\nThe `_value` property actually contains the value that I want to match to my code value I have put in the `.env` file. So I need to access it with `req.body.code._value`. This is how I can check that there is a match:\n\n```js\napp.post(\'/secret-code\', async (req, res) => {\n  if (req.body.code._value === process.env.SECRET_CODE) {\n    res.status(200).json(\'Correct code\')\n  } else {\n    res.status(200).json(\'Incorrect code\')\n  }\n})\n```\n\nThe `res.status()` method will send back the result status code, and the .json() method will make sure it returns to the frontend as JSON data.\n\nNow I can go back to the frontend and write a fetch request that will send the secret code that I need for this verification.\n\n### Fetch POST request\n\nTo write a fetch POST request, I will use [the fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).\n\nTo write a fetch request, I use the `fetch()` method with a first argument of the endpoint path (including the port number) and the second argument an options object:\n\n```js\nfetch(\'http://localhost:8080/secret-code\', requestOptions)\n```\n\nThe options object will give information about the type of request (POST), the headers (to tell that the content will be of the type JSON) and the request body (I will send a JSON object that contains the code):\n\n```js\nconst requestOptions = {\n  method: \'POST\',\n  headers: { \'Content-Type\': \'application/json\' },\n  body: JSON.stringify({ code: code }),\n}\n```\n\nThe fetch request will send the code to the backend server, and since that will take a little bit of time, I will use a promise to wait for the response, doing the following action once that response has been returned. To use a promise, I will attach a `.then()` to the request, which means that anything inside the `.then()` will happen after the response is returned from the fetch request.\n\nOnce the response returns, I will turn it back into JSON and then take that response data to verify if it is correct or not. Depending on if it is correct, I update the state in the store.\n\nRemember, for a verified response of true, I am expecting the backend server to return a response with a JSON string of `"Correct code"`:\n\n```js\nfetch(\'http://localhost:8080/secret-code\', requestOptions)\n  .then((response) => response.json())\n  .then((data) => {\n    if (data === \'Correct code\') {\n      //dispatch payload to store\n    }\n  })\n  .then(() => {\n    if (store.state.allowAccess) {\n      // navigate to channel or alert that code is wrong\n    }\n  })\n```\n\nI\'ve created a branch in the repo called [vuex-with-server ](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-with-server/src/views/EnterCode.vue)where the code from this step can be viewed in its entirety.\n\n## Conclusion\n\nIn this post, I set up a Vue project and added some of the common features used in a full-stack application: routes, a state management library, and a backend server with endpoints.\n\nNow I am ready to build the **Channel** page, which will contain the video player for my live stream and the audio captions that display the transcript.\n\nPreviously, I went over how to build a live stream web application with **Amazon IVS**, using only vanilla javascript and HTML. But now, I want to use the Vue framework to help me build this in a way that is more reusable, and that incorporates common practices for using Vue.js.\n\nIn my next post, I will introduce how to build the **Amazon IVS** player using **Vue 3 composables**, which will give me a chance to discuss more specifically some of the new features of Vue 3.\n\nI will also introduce how to use Vue 3 composables to create the **Deepgram captions**, and I\'ll include a more secure way of connecting to Deepgram by requesting a Deepgram token from the backend.\n\nI hope you\'ll join me for my next post. As always, feel free to reach out on [Twitter](https://twitter.com/sandra_rodgers_).\n\n        ', "html": `<h2 id="introduction">Introduction</h2>
<Panel type="info" title="Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)"><ol><li><a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>
<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>
<li><a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li><li><a href="https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li></ol></Panel>
<p>In my last post, I introduced how to build a vanilla Javascript and HTML live streaming web application with text captions. It included a barebones frontend that was just one page - the video player and captions.</p>
<p>Today I\u2019m going to start building a full-stack application using the same technology, except instead of vanilla Javascript, I will use Vue 3.</p>
<p>The full-stack application will be expanded from the barebones version to include features that are often necessary for real-world applications, such as:</p>
<ul>
<li>a landing page that asks for a code to enter the site</li>
<li>a router (<strong>Vue Router</strong>) to implement routes and a navigation guard so users can\u2019t access beyond the entry page unless they enter the correct code</li>
<li>a state management library (<strong>Vuex</strong>) which will update state to allow access to the stream page if the correct code is entered</li>
<li>a backend server (<strong>node.js</strong> and <strong>express</strong>) with two endpoints, one for getting a <strong>Deepgram</strong> temporary key so I can keep my Deepgram API key secure, and one for verifying the secret code the user must input to enter the site</li>
</ul>
<p>I recommend reading <a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/#setting-up-amazon-ivs">the first post</a> to go through how to set up the video streaming technologies, <strong>Open Broadcaster Software</strong>, and <strong>Amazon IVS</strong>. And for an introduction to Vue 3, it might be worth checking out my series <a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3</a>.</p>
<h2 id="what-ill-build-today">What I\u2019ll Build Today</h2>
<p>In this post, I\u2019ll set up the router (Vue Router) and Vuex so that I can put a navigation guard on the entry page. I will also set up the backend server so I can keep my entry code secure.</p>
<p>Here is the diagram to show the data flow and structure for what I will build today. The focus will be on building the protected entry with a navigation guard. If it seems complicated in the diagram, it won\u2019t by the end of the post because I plan to walk-through building this feature step-by-step.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/ProtectedEntrytoSite.png" alt="Protected entry diagram" style="width: 75%; margin:auto;" />
<h2 id="setting-up-the-vue-project">Setting up the Vue Project</h2>
<p>After <a href="https://cli.vuejs.org/guide/installation.html">installing the Vue CLI</a>, I can create a new Vue project with this command:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">vue create NAME-OF-PROJECT</span></span></code></pre>
<p>I\u2019ll be sure to choose \u2018Manually select features\u2019 so I can add some dependencies during the creation of the project:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets.png" alt="Presents including router and vuex" style="width: 75%; margin:auto;" />
<p>These are the presets I selected. I definitely recommend selecting Router and Vuex since those are required for this project, but the others are just my personal preference :</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets2.png" alt="Presets for linting and router"></p>
<p>I\u2019ll select Vue 3, and then I\u2019ll <code is:raw>cd</code> into the folder.</p>
<p>I can install all the rest of the dependencies now, or I can install them one by one as I need them. Here is a list of the dependencies I\u2019ll be using in this project:</p>
<ul>
<li>vue-router@4 (already installed when I manually selected presets)</li>
<li>vuex@next (already installed when I manually selected presets)</li>
<li>express</li>
<li>dotenv</li>
<li>cors</li>
<li>body-parser</li>
<li>@deepgram/sdk</li>
</ul>
<p>I can install them all at once with this command:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">npm install vue-router@4 vuex@next express dotenv cors body-parser @deepgram/sdk</span></span></code></pre>
<h2 id="the-folders-structure">The Folders Structure</h2>
<p>A Vue application that is created using the Vue CLI starts out with this structure:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Vue-Folder-Structure.png" alt="Vue folder structure after creating new project" style="width: 50%; margin:auto;" />
<p>The <code is:raw>src</code> contains the folders that will make up the frontend, and I will add two files to the root of the project which will be required for the backend. Those two files will be a <code is:raw>server.js</code> file and a <code is:raw>.env</code> file. The final structure can be seen <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram">here</a> at the root level of the project in its GitHub repo.</p>
<h3 id="src-folder">SRC Folder</h3>
<p>I\u2019ll go over the SRC folder in more detail because the way I organize this folder reflects my thinking about how I\u2019ll make the application work when considering how the pieces should fit together.</p>
<p>Here is the file structure of the SRC for the final project (these folders can be set up now or as I progress through building the project):</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/SRC-Folder-Structure.png" alt="Folder structure of SRC folder" style="width: 50%; margin:auto;" />
<p>I\u2019ll go over the pieces starting from the bottom.</p>
<h3 id="mainjs">main.js</h3>
<p>This is the file where Vue will be initialized, and also where Vue Router and Vuex (the store) will be brought into the project as plugins by way of <code is:raw>app.use()</code>.</p>
<h3 id="appvue">App.vue</h3>
<p>This is the top-most parent component, i.e., the <strong>root component</strong>. It holds all the Vue code (coming in as code in this file or code in child components) that will be injected into the <code is:raw>index.html</code> file, inside the <code is:raw>div</code> that has <code is:raw>id="app"</code>.</p>
<h3 id="views">views</h3>
<p>These are the pages that will be the main routes of the project. There will be a page that the user first lands on where they must enter a code. I will name it <code is:raw>EnterCode.vue</code>. And there will be a page that shows the live stream, with the video player and audio captions. I\u2019ll name that page <code is:raw>StreamChannel.vue</code>.</p>
<p>Here is a screenshot of what the views will look like by the end of this post. A demo of the finished project can be found in the first post, which shows the styled version with the video live stream page.</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Two-Page-Views.png" alt="Image of two page views"></p>
<h3 id="store">store</h3>
<p>This is the folder that contains the Vuex store, a state management file. Some state properties need to be widely available throughout the application, not just in one component or one parent-child component. Vuex makes those state properties that I have put in the store available in any Vue files throughout the project.</p>
<h3 id="router">router</h3>
<p>This is the folder that contains the routes and creates the router, so that each view (page) can be navigated to when a user clicks on the link to that page. Using Vue Router means that a user can switch between page views without the page being reloaded every time the route changes.</p>
<h3 id="composables">composables</h3>
<p>This folder contains composition functions that run the logic to make stuff happen, such as getting the user\u2019s microphone or bringing in the Amazon IVS player. Composition functions, or \u2018composables\u2019, are a Vue 3 way of encapsulating logic that can then be run inside the setup function inside a component. Read more about composables <a href="https://blog.deepgram.com/diving-into-vue-3-reusability-with-composables/#reusability-in-the-composition-api">here</a>.</p>
<h3 id="components">components</h3>
<p>The components folder contains two components that will make up the StreamChannel page - the <strong>VideoPlayer</strong> component and the <strong>AudioCaptions</strong> component. I\u2019ll build these components in the next post in this series.</p>
<h2 id="set-up-vue-router-and-the-views">Set up Vue Router and the Views</h2>
<p>The first thing I will do is create the two main pages I intend to make as part of this application - the landing page and the live stream page.</p>
<p>I will create a views folder and put those two main page files in the folder:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Views.png" alt="Views folder with files" style="width: 50%; margin:auto;" />
<p>For each file, I\u2019ll be sure to put in some HTML that will display on the page, so I can see that my router is working:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;Enter Code&lt;/</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>When I created my project with the Vue CLI, I opted to add the Vue Router dependency, which means I have a router already created for me - the <code is:raw>index.js</code> file in the <code is:raw>router</code> folder. The index.js already has two routes set up - home and about.</p>
<p>If I start up the development server, I see that the links at the top of the page will take me between the two routes.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-About-Links.png" alt="Home and About links" style="width: 30%; margin:auto;" />
<p>Since my project is only going to have two pages, I am just going to change the <strong>home</strong> and <strong>about</strong> views of the bootstrapped project to be the <strong>EnterCode</strong> view and the <strong>StreamChannel</strong> View.</p>
<p>In the router file, the three things each route object needs to have are:</p>
<ul>
<li>the path - the URL path for the route</li>
<li>the name - the name I want to give this route (optional, but in my case, I do need it)</li>
<li>the component - the component (view file) that will be loaded for this route</li>
</ul>
<p>Here is the code to set that up in the router:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { createRouter, createWebHistory } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue-router&#39;</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> EnterCode </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../views/EnterCode.vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">routes</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> [</span></span>
<span class="line"><span style="color: #C9D1D9">  {</span></span>
<span class="line"><span style="color: #C9D1D9">    path: </span><span style="color: #A5D6FF">&#39;/&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    name: </span><span style="color: #A5D6FF">&#39;EnterCode&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    component: EnterCode,</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">  {</span></span>
<span class="line"><span style="color: #C9D1D9">    path: </span><span style="color: #A5D6FF">&#39;/stream-channel&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    name: </span><span style="color: #A5D6FF">&#39;StreamChannel&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">component</span><span style="color: #C9D1D9">: () </span><span style="color: #FF7B72">=&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">import</span><span style="color: #C9D1D9">(</span><span style="color: #8B949E">/* webpackChunkName: &quot;about&quot; */</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../views/StreamChannel.vue&#39;</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">router</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">createRouter</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">  history: </span><span style="color: #D2A8FF">createWebHistory</span><span style="color: #C9D1D9">(process.env.</span><span style="color: #79C0FF">BASE_URL</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9">  routes,</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #C9D1D9">router</span></span></code></pre>
<p>I need to go back to App.vue and change the router-links to match my new routes. Even though I\u2019ve named the landing page <code is:raw>EnterCode.vue</code>, I\u2019ll refer to it has <strong>Home</strong> for the user. Notice that the <code is:raw>to=""</code> attribute contains the path:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">nav</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">to</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;/&quot;</span><span style="color: #C9D1D9">&gt;Home&lt;/</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9">&gt; |</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">to</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;/stream-channel&quot;</span><span style="color: #C9D1D9">&gt;Channel&lt;/</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">nav</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">router-view</span><span style="color: #C9D1D9"> /&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>Now I see that my two main pages can be accessed (without reloading the page!) when I click the link to switch to each route:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-Channel-Links.png" alt="Home (enter-code) and Channel Links" style="width: 30%; margin:auto;" />
<h3 id="vue-router-navigation-guards">Vue Router Navigation Guards</h3>
<p>I want the landing page to have a form input where the user has to enter a code, and if the code is correct, they can move on to the channel page. See the code for this input <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/views/EnterCode.vue#L4">here</a>.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Input.png" alt="Input on enter code page" style="width: 50%; margin:auto;" />
<p>But if the code they enter is incorrect, I want to keep them from being able to navigate to that page. Right now, the channel page is completely open, and I can access it just by clicking the <strong>Channel</strong> link.</p>
<p>I can set up a <strong>navigation guard</strong> to perform some logic when the router-link is clicked (<a href="https://router.vuejs.org/guide/advanced/navigation-guards.html">Read the docs</a> for more information about navigation guards).</p>
<p>The logic will check to see if the correct code has been entered. If it has, the router will navigate to the channel page. If not, it will send them back to the home (<code is:raw>EnterCode.vue</code>) page.</p>
<p>To add a navigation guard, I use the <code is:raw>beforeEnter</code> guard:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">path</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;/stream-channel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">name</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;StreamChannel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">component</span><span style="color: #C9D1D9">: () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;../views/StreamChannel.vue&quot;</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">beforeEnter</span><span style="color: #C9D1D9">(to, from, next) {</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E">// ADD LOGIC HERE to check state of allowed access</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>The <code is:raw>next()</code> function will move the navigation forward to the route. I can use an <strong>if statement</strong> to keep that from happening unless certain circumstances are met.</p>
<p>If I include a name of a route in the next() function, the navigation will move to the route I have identified by name. In this example, it would cause navigation to stay on the <strong>EnterCode</strong> page since I have identified that <code is:raw>next</code> should move me to that route.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">beforeEnter</span><span style="color: #C9D1D9">(to, from, next) {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// ADD LOGIC HERE to check state of allowed access</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">({ name: </span><span style="color: #A5D6FF">&quot;EnterCode&quot;</span><span style="color: #C9D1D9"> });</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>I need to have some way of keeping track of the state of whether the correct code was entered or not. I will use the state management system, Vuex, which means I can now put this code in my router since the very next thing I will do is set up the store so there is a state property for <code is:raw>allowAccess</code>:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">path</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;/channel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">name</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;StreamChannel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">component</span><span style="color: #C9D1D9">: () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;../views/StreamChannel.vue&quot;</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">beforeEnter</span><span style="color: #C9D1D9">(to, from, next) {</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (store.state.allowAccess </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9">   } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">({ name: </span><span style="color: #A5D6FF">&quot;EnterCode&quot;</span><span style="color: #C9D1D9"> });</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #D2A8FF">alert</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Please enter the secret code&quot;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">   }</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>I\u2019ll probably see this error in the browser now since I\u2019ve referenced <code is:raw>store.state.allowAccess</code>, but the router file doesn\u2019t know what the <code is:raw>store</code> instance is.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/error-store.png" alt="Error: 'store' is not defined" style="width: 50%; margin:auto;" />
<p>To make it go away, I need to import the store into the router by adding the following import statement to the router folder\u2019s <code is:raw>index.js</code> file.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> store </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../store&#39;</span></span></code></pre>
<p>The <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/router/index.js">GitHub repo</a> has the code in its entirety for this stage of the project.</p>
<h2 id="set-up-vuex-to-manage-state">Set up Vuex to Manage State</h2>
<p>Even though this is a small application, I am choosing to include a Vuex store because it is common to use Vuex for the purpose of keeping track of whether a user is authenticated/logged-in or not.</p>
<p>In this project, I will use the Vuex store to keep track of whether a correct entry code has been entered or not by the user. The state property will be called <code is:raw>allowAccess</code>, and its default state will be false. It will change to true when a user enters the correct code.</p>
<p>Here is the store with the state property I have created:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { createStore } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vuex&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">store</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">createStore</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">state</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      allowAccess: </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #C9D1D9">store</span></span></code></pre>
<p>I need to connect the input on the landing (EntryCode) page with this property in state. When the user types a correct code into that input, the submit button triggers a function that checks if the code is correct, and then if it is, dispatches an action to the store, which will cause <code is:raw>allowAccess</code> to update to <code is:raw>true</code>.</p>
<p>The way Vuex causes state to change is through this pattern:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979626/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/vuex.png" alt="Vuex pattern" style="width: 80%; margin:auto;" />
<p>Vue Component dispatch action -> Store action commit mutation -> Store mutation change state</p>
<p>Here is that flow in the actual code in my project.</p>
<ol>
<li>The Vue component <em>EnterCode</em> form submit button triggers <code is:raw>submitCode()</code>:</li>
</ol>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">form</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">@submit.prevent</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;submitCode&quot;</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">label</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">for</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;code&quot;</span><span style="color: #C9D1D9">&gt; Code: &lt;/</span><span style="color: #7EE787">label</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">input</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">v-model</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;code&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">type</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;password&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">name</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;code&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">value</span><span style="color: #C9D1D9"> /&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">type</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;submit&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">name</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;button&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;dg-btn&quot;</span><span style="color: #C9D1D9">&gt;Submit&lt;/</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">form</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<ol start="2">
<li>The <code is:raw>submitCode()</code> method dispatches the <code is:raw>verifyCode</code> action (which is <a href="https://vuex.vuejs.org/guide/actions.html#dispatching-actions">passed as a string</a> <code is:raw>'verifyCode'</code>) with a <em>payload</em> of <code is:raw>true</code> or <code is:raw>false</code>:</li>
</ol>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">submitCode</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (code.value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;pb&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  code.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<ol start="3">
<li>The <code is:raw>verifyCode</code> action in the store commits the <code is:raw>verifyCode</code> mutation, sending the <code is:raw>true</code> or <code is:raw>false</code> payload, referred to hear as <code is:raw>status</code>:</li>
</ol>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FFA657">actions</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">verifyCode</span><span style="color: #C9D1D9">({ commit }, status) {</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #D2A8FF">commit</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;verifyCode&quot;</span><span style="color: #C9D1D9">, status);</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<ol start="4">
<li>The <code is:raw>verifyCode</code> mutation changes state so <code is:raw>allowAccess</code> equals the <code is:raw>status</code> payload of <code is:raw>true</code> or <code is:raw>false</code></li>
</ol>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FFA657">mutations</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">verifyCode</span><span style="color: #C9D1D9">(state, status) {</span></span>
<span class="line"><span style="color: #C9D1D9">   state.allowAccess </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> status;</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>The last thing to do is navigate with the router to the <em>StreamChannel</em> page if a correct code has been entered (i.e., state for <code is:raw>allowAccess</code> in the store has changed to true) or alert the user if they have entered the wrong code.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//StreamChannel.vue</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">submitCode</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (code.value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;PB&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// Navigate if correct code, alert if not correct</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (store.state.allowAccess) {</span></span>
<span class="line"><span style="color: #C9D1D9">    router.</span><span style="color: #D2A8FF">push</span><span style="color: #C9D1D9">({ name: </span><span style="color: #A5D6FF">&#39;StreamChannel&#39;</span><span style="color: #C9D1D9"> })</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">alert</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Incorrect code&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  code.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>This version of the project, with the setup I just did for Vue Router and Vuex, can be seen in its entirety in the repo branch titled <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/vuex-no-server-yet">vuex-no-server-yet</a>.</p>
<h3 id="security">Security</h3>
<p>The example so far is not very secure because I check for the correct code on the frontend, and that entry code is right there in plain Vue (no pun intended) in the client:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (code.value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;pb&quot;</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>The more secure way to handle this would be to create a backend server file with an endpoint to check if the code is correct and store that code securely in the server, or even better (so it does not get exposed in GitHub) in a <code is:raw>.env</code> file.</p>
<p>In the next section, I\u2019ll introduce that more secure method of checking the code. I\u2019ll still use everything I just set up for Vuex, but instead of checking the code in the <code is:raw>EnterCode.vue</code> file, I\u2019ll use a fetch request to send that code to the backend for verification.</p>
<h2 id="create-the-server-with-express">Create the Server with Express</h2>
<p>Now I\u2019ll set up my server file, which I\u2019ll use today for making the entry code more secure, and which I\u2019ll use in the next post for setting up the Deepgram token endpoint.</p>
<p>At the root of the project, I\u2019ll create a <code is:raw>server.js</code> file and a <code is:raw>.env</code> file.</p>
<p>I\u2019ll add this code to create my basic server.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// bring in node modules</span></span>
<span class="line"><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;dotenv&#39;</span><span style="color: #C9D1D9">).</span><span style="color: #D2A8FF">config</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">express</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;express&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">app</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">express</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #FF7B72">var</span><span style="color: #C9D1D9"> bodyParser </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;body-parser&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">cors</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;cors&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// identify port number</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">port</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8080</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// express use() function to add third-party middleware</span></span>
<span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">use</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">cors</span><span style="color: #C9D1D9">())</span></span>
<span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">use</span><span style="color: #C9D1D9">(bodyParser.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">())</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// ENDPOINT WILL GO HERE</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// Connect host to port</span></span>
<span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">listen</span><span style="color: #C9D1D9">(port, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">\`Example app listening at http://localhost:\${</span><span style="color: #C9D1D9">port</span><span style="color: #A5D6FF">}\`</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<h3 id="dependencies">Dependencies</h3>
<p>Here is a brief explanation of each dependency I\u2019m using in this server file.</p>
<h4 id="express">express</h4>
<p><a href="https://expressjs.com/">Express</a> is a <em>node.js</em> framework that gives me utility methods and middleware to help with setting up routing endpoints (the endpoints deal with requests that come in from the frontend).</p>
<h4 id="body-parser">body-parser</h4>
<p>Body-parser is middleware that can take an incoming request body and parse the data. I\u2019ll be using the JSON parser because the secret entry code will be sent from the frontend as JSON.</p>
<h4 id="cors">cors</h4>
<p>This is another middleware package that will help to handle requests from the frontend, specifically cross-origin requests.</p>
<p>Since the client and server have a different origin from each other (such as localhost:8080 vs. localhost:8081), I would need to add a CORS response header <code is:raw>access-control-allow-origins</code> with information about permitted origins. The CORS middleware will add that header automatically for every request that is sent to the server.</p>
<h4 id="dotenv">dotenv</h4>
<p>This is a very important node module. It allows me to use environment variables in my server file, pulling the values for those variables from the <code is:raw>.env</code> file. The <code is:raw>.env</code> file will never be tracked by git, so I can put anything super-secret in the <code is:raw>.env</code> file and not worry that it will end up on Github for the world to see.</p>
<h3 id="run-the-server">Run the server</h3>
<p>Now I can start up the server to check that everything is working so far.</p>
<p>I will add a script command to the <code is:raw>package.json</code> file to make it easier to start up the server. In my <code is:raw>package.json</code>, in the \u201Cscripts\u201D object, I\u2019ll add one for \u201Cstart\u201D:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #A5D6FF">&quot;scripts&quot;</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #A5D6FF">&quot;serve&quot;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;vue-cli-service serve&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">...</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #A5D6FF">&quot;start&quot;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;node server.js&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>Now, in the terminal, when I\u2019m in the project folder, I can type <code is:raw>npm run start</code> to start the backend server, and if I open another terminal, I can type <code is:raw>npm run serve</code> to start the frontend development server.</p>
<h3 id="add-the-secret-code-value-to-env">Add the secret code value to <code is:raw>.env</code></h3>
<p>Before I set up the endpoint, I want to put the expected code value in the <code is:raw>.env</code> file so that I can access it in the server using <code is:raw>process.env.SECRET_CODE</code>.</p>
<p>In the <code is:raw>.env</code> file, I will add the secret code that I want users to type into the input on the frontend to be able to enter the site. I can add any value I want. In this case, I\u2019ll just make the value \u2018code\u2019 (in the earlier section, I used \u2018pb\u2019 as the code, but I\u2019m using \u2018code\u2019 here to make it more obvious that this is the code):</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">SECRET_CODE=</span><span style="color: #A5D6FF">&quot;code&quot;</span></span></code></pre>
<h3 id="create-the-secret-code-endpoint">Create the secret-code endpoint</h3>
<p>Now I\u2019ll start on the backend creating the endpoint. The endpoint will expect a value to come in from the frontend (the code entered by the user). Since a value is being sent back, this will be a POST request endpoint.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">post</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;/secret-code&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">req</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {})</span></span></code></pre>
<p>The app.post() method is available because of express, and it requires the route path as a slash and whatever I want to name the path, in this case <code is:raw>"/secret-code"</code>.</p>
<p>When the code is sent from the frontend to the backend, it comes in as part of the request body (which is an object), so I will get the code value from <code is:raw>req.body</code>. Because I plan to send it back in a JSON object as <code is:raw>{ code: "code" }</code>, the value will come back as <code is:raw>req.body.code</code>.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (req.body.code._value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> process.env.</span><span style="color: #79C0FF">SECRET_CODE</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>However, the value that is sent back is put into another object, which I see when I examine the shape of the req.body.code by using <code is:raw>console.log</code>. I see this:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/reqbodycode.png" alt="req.body.code object shape" style="width: 50%; margin:auto;" />
<p>The <code is:raw>_value</code> property actually contains the value that I want to match to my code value I have put in the <code is:raw>.env</code> file. So I need to access it with <code is:raw>req.body.code._value</code>. This is how I can check that there is a match:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">post</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;/secret-code&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">req</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (req.body.code._value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> process.env.</span><span style="color: #79C0FF">SECRET_CODE</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    res.</span><span style="color: #D2A8FF">status</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">).</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Correct code&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    res.</span><span style="color: #D2A8FF">status</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">).</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Incorrect code&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>The <code is:raw>res.status()</code> method will send back the result status code, and the .json() method will make sure it returns to the frontend as JSON data.</p>
<p>Now I can go back to the frontend and write a fetch request that will send the secret code that I need for this verification.</p>
<h3 id="fetch-post-request">Fetch POST request</h3>
<p>To write a fetch POST request, I will use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">the fetch API</a>.</p>
<p>To write a fetch request, I use the <code is:raw>fetch()</code> method with a first argument of the endpoint path (including the port number) and the second argument an options object:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/secret-code&#39;</span><span style="color: #C9D1D9">, requestOptions)</span></span></code></pre>
<p>The options object will give information about the type of request (POST), the headers (to tell that the content will be of the type JSON) and the request body (I will send a JSON object that contains the code):</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">requestOptions</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  method: </span><span style="color: #A5D6FF">&#39;POST&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">  headers: { </span><span style="color: #A5D6FF">&#39;Content-Type&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;application/json&#39;</span><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">  body: </span><span style="color: #79C0FF">JSON</span><span style="color: #C9D1D9">.</span><span style="color: #D2A8FF">stringify</span><span style="color: #C9D1D9">({ code: code }),</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>The fetch request will send the code to the backend server, and since that will take a little bit of time, I will use a promise to wait for the response, doing the following action once that response has been returned. To use a promise, I will attach a <code is:raw>.then()</code> to the request, which means that anything inside the <code is:raw>.then()</code> will happen after the response is returned from the fetch request.</p>
<p>Once the response returns, I will turn it back into JSON and then take that response data to verify if it is correct or not. Depending on if it is correct, I update the state in the store.</p>
<p>Remember, for a verified response of true, I am expecting the backend server to return a response with a JSON string of <code is:raw>"Correct code"</code>:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/secret-code&#39;</span><span style="color: #C9D1D9">, requestOptions)</span></span>
<span class="line"><span style="color: #C9D1D9">  .</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">response</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> response.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">())</span></span>
<span class="line"><span style="color: #C9D1D9">  .</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">data</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (data </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Correct code&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">//dispatch payload to store</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span>
<span class="line"><span style="color: #C9D1D9">  .</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (store.state.allowAccess) {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// navigate to channel or alert that code is wrong</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span></code></pre>
<p>I\u2019ve created a branch in the repo called <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-with-server/src/views/EnterCode.vue">vuex-with-server </a>where the code from this step can be viewed in its entirety.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post, I set up a Vue project and added some of the common features used in a full-stack application: routes, a state management library, and a backend server with endpoints.</p>
<p>Now I am ready to build the <strong>Channel</strong> page, which will contain the video player for my live stream and the audio captions that display the transcript.</p>
<p>Previously, I went over how to build a live stream web application with <strong>Amazon IVS</strong>, using only vanilla javascript and HTML. But now, I want to use the Vue framework to help me build this in a way that is more reusable, and that incorporates common practices for using Vue.js.</p>
<p>In my next post, I will introduce how to build the <strong>Amazon IVS</strong> player using <strong>Vue 3 composables</strong>, which will give me a chance to discuss more specifically some of the new features of Vue 3.</p>
<p>I will also introduce how to use Vue 3 composables to create the <strong>Deepgram captions</strong>, and I\u2019ll include a more secure way of connecting to Deepgram by requesting a Deepgram token from the backend.</p>
<p>I hope you\u2019ll join me for my next post. As always, feel free to reach out on <a href="https://twitter.com/sandra_rodgers_">Twitter</a>.</p>` }, "file": "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/build-a-livestream-web-application-vue-and-express-setup/index.md" };
function rawContent() {
  return '\n## Introduction\n\n<Panel type="info" title="Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)">\n<ol> \n<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>\n<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>\n<li><a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li>\n\n<li><a href="https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li>\n</ol>\n</Panel>\n\nIn my last post, I introduced how to build a vanilla Javascript and HTML live streaming web application with text captions. It included a barebones frontend that was just one page - the video player and captions.\n\nToday I\'m going to start building a full-stack application using the same technology, except instead of vanilla Javascript, I will use Vue 3.\n\nThe full-stack application will be expanded from the barebones version to include features that are often necessary for real-world applications, such as:\n\n*   a landing page that asks for a code to enter the site\n*   a router (**Vue Router**) to implement routes and a navigation guard so users can\'t access beyond the entry page unless they enter the correct code\n*   a state management library (**Vuex**) which will update state to allow access to the stream page if the correct code is entered\n*   a backend server (**node.js** and **express**) with two endpoints, one for getting a **Deepgram** temporary key so I can keep my Deepgram API key secure, and one for verifying the secret code the user must input to enter the site\n\nI recommend reading [the first post](https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/#setting-up-amazon-ivs) to go through how to set up the video streaming technologies, **Open Broadcaster Software**, and **Amazon IVS**. And for an introduction to Vue 3, it might be worth checking out my series [Diving Into Vue 3](https://blog.deepgram.com/diving-into-vue-3-getting-started/).\n\n## What I\'ll Build Today\n\nIn this post, I\'ll set up the router (Vue Router) and Vuex so that I can put a navigation guard on the entry page. I will also set up the backend server so I can keep my entry code secure.\n\nHere is the diagram to show the data flow and structure for what I will build today. The focus will be on building the protected entry with a navigation guard. If it seems complicated in the diagram, it won\'t by the end of the post because I plan to walk-through building this feature step-by-step.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/ProtectedEntrytoSite.png" alt="Protected entry diagram" style="width: 75%; margin:auto;">\n\n## Setting up the Vue Project\n\nAfter [installing the Vue CLI](https://cli.vuejs.org/guide/installation.html), I can create a new Vue project with this command:\n\n```bash\nvue create NAME-OF-PROJECT\n```\n\nI\'ll be sure to choose \'Manually select features\' so I can add some dependencies during the creation of the project:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets.png" alt="Presents including router and vuex" style="width: 75%; margin:auto;">\n\nThese are the presets I selected. I definitely recommend selecting Router and Vuex since those are required for this project, but the others are just my personal preference :\n\n![Presets for linting and router](https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets2.png)\n\nI\'ll select Vue 3, and then I\'ll `cd` into the folder.\n\nI can install all the rest of the dependencies now, or I can install them one by one as I need them. Here is a list of the dependencies I\'ll be using in this project:\n\n*   vue-router@4 (already installed when I manually selected presets)\n*   vuex@next (already installed when I manually selected presets)\n*   express\n*   dotenv\n*   cors\n*   body-parser\n*   @deepgram/sdk\n\nI can install them all at once with this command:\n\n```bash\nnpm install vue-router@4 vuex@next express dotenv cors body-parser @deepgram/sdk\n```\n\n## The Folders Structure\n\nA Vue application that is created using the Vue CLI starts out with this structure:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Vue-Folder-Structure.png" alt="Vue folder structure after creating new project" style="width: 50%; margin:auto;">\n\nThe `src` contains the folders that will make up the frontend, and I will add two files to the root of the project which will be required for the backend. Those two files will be a `server.js` file and a `.env` file. The final structure can be seen [here](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram) at the root level of the project in its GitHub repo.\n\n### SRC Folder\n\nI\'ll go over the SRC folder in more detail because the way I organize this folder reflects my thinking about how I\'ll make the application work when considering how the pieces should fit together.\n\nHere is the file structure of the SRC for the final project (these folders can be set up now or as I progress through building the project):\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/SRC-Folder-Structure.png" alt="Folder structure of SRC folder" style="width: 50%; margin:auto;">\n\nI\'ll go over the pieces starting from the bottom.\n\n### main.js\n\nThis is the file where Vue will be initialized, and also where Vue Router and Vuex (the store) will be brought into the project as plugins by way of `app.use()`.\n\n### App.vue\n\nThis is the top-most parent component, i.e., the **root component**. It holds all the Vue code (coming in as code in this file or code in child components) that will be injected into the `index.html` file, inside the `div` that has `id="app"`.\n\n### views\n\nThese are the pages that will be the main routes of the project. There will be a page that the user first lands on where they must enter a code. I will name it `EnterCode.vue`. And there will be a page that shows the live stream, with the video player and audio captions. I\'ll name that page `StreamChannel.vue`.\n\nHere is a screenshot of what the views will look like by the end of this post. A demo of the finished project can be found in the first post, which shows the styled version with the video live stream page.\n\n![Image of two page views](https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Two-Page-Views.png)\n\n### store\n\nThis is the folder that contains the Vuex store, a state management file. Some state properties need to be widely available throughout the application, not just in one component or one parent-child component. Vuex makes those state properties that I have put in the store available in any Vue files throughout the project.\n\n### router\n\nThis is the folder that contains the routes and creates the router, so that each view (page) can be navigated to when a user clicks on the link to that page. Using Vue Router means that a user can switch between page views without the page being reloaded every time the route changes.\n\n### composables\n\nThis folder contains composition functions that run the logic to make stuff happen, such as getting the user\'s microphone or bringing in the Amazon IVS player. Composition functions, or \'composables\', are a Vue 3 way of encapsulating logic that can then be run inside the setup function inside a component. Read more about composables [here](https://blog.deepgram.com/diving-into-vue-3-reusability-with-composables/#reusability-in-the-composition-api).\n\n### components\n\nThe components folder contains two components that will make up the StreamChannel page - the **VideoPlayer** component and the **AudioCaptions** component. I\'ll build these components in the next post in this series.\n\n## Set up Vue Router and the Views\n\nThe first thing I will do is create the two main pages I intend to make as part of this application - the landing page and the live stream page.\n\nI will create a views folder and put those two main page files in the folder:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Views.png" alt="Views folder with files" style="width: 50%; margin:auto;">\n\nFor each file, I\'ll be sure to put in some HTML that will display on the page, so I can see that my router is working:\n\n```html\n<template>\n  <div>\n    <h1>Enter Code</h1>\n  </div>\n</template>\n```\n\nWhen I created my project with the Vue CLI, I opted to add the Vue Router dependency, which means I have a router already created for me - the `index.js` file in the `router` folder. The index.js already has two routes set up - home and about.\n\nIf I start up the development server, I see that the links at the top of the page will take me between the two routes.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-About-Links.png" alt="Home and About links" style="width: 30%; margin:auto;">\n\nSince my project is only going to have two pages, I am just going to change the **home** and **about** views of the bootstrapped project to be the **EnterCode** view and the **StreamChannel** View.\n\nIn the router file, the three things each route object needs to have are:\n\n*   the path - the URL path for the route\n*   the name - the name I want to give this route (optional, but in my case, I do need it)\n*   the component - the component (view file) that will be loaded for this route\n\nHere is the code to set that up in the router:\n\n```js\nimport { createRouter, createWebHistory } from \'vue-router\'\nimport EnterCode from \'../views/EnterCode.vue\'\n\nconst routes = [\n  {\n    path: \'/\',\n    name: \'EnterCode\',\n    component: EnterCode,\n  },\n  {\n    path: \'/stream-channel\',\n    name: \'StreamChannel\',\n    component: () =>\n      import(/* webpackChunkName: "about" */ \'../views/StreamChannel.vue\'),\n  },\n]\n\nconst router = createRouter({\n  history: createWebHistory(process.env.BASE_URL),\n  routes,\n})\n\nexport default router\n```\n\nI need to go back to App.vue and change the router-links to match my new routes. Even though I\'ve named the landing page `EnterCode.vue`, I\'ll refer to it has **Home** for the user. Notice that the `to=""` attribute contains the path:\n\n```html\n<template>\n  <nav>\n    <router-link to="/">Home</router-link> |\n    <router-link to="/stream-channel">Channel</router-link>\n  </nav>\n  <router-view />\n</template>\n```\n\nNow I see that my two main pages can be accessed (without reloading the page!) when I click the link to switch to each route:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-Channel-Links.png" alt="Home (enter-code) and Channel Links" style="width: 30%; margin:auto;">\n\n### Vue Router Navigation Guards\n\nI want the landing page to have a form input where the user has to enter a code, and if the code is correct, they can move on to the channel page. See the code for this input [here](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/views/EnterCode.vue#L4).\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Input.png" alt="Input on enter code page" style="width: 50%; margin:auto;">\n\nBut if the code they enter is incorrect, I want to keep them from being able to navigate to that page. Right now, the channel page is completely open, and I can access it just by clicking the **Channel** link.\n\nI can set up a **navigation guard** to perform some logic when the router-link is clicked ([Read the docs](https://router.vuejs.org/guide/advanced/navigation-guards.html) for more information about navigation guards).\n\nThe logic will check to see if the correct code has been entered. If it has, the router will navigate to the channel page. If not, it will send them back to the home (`EnterCode.vue`) page.\n\nTo add a navigation guard, I use the `beforeEnter` guard:\n\n```js\n{\n path: "/stream-channel",\n name: "StreamChannel",\n component: () => import("../views/StreamChannel.vue"),\n beforeEnter(to, from, next) {\n   // ADD LOGIC HERE to check state of allowed access\n   next();\n },\n},\n```\n\nThe `next()` function will move the navigation forward to the route. I can use an **if statement** to keep that from happening unless certain circumstances are met.\n\nIf I include a name of a route in the next() function, the navigation will move to the route I have identified by name. In this example, it would cause navigation to stay on the **EnterCode** page since I have identified that `next` should move me to that route.\n\n```js\nbeforeEnter(to, from, next) {\n  // ADD LOGIC HERE to check state of allowed access\n  next({ name: "EnterCode" });\n},\n```\n\nI need to have some way of keeping track of the state of whether the correct code was entered or not. I will use the state management system, Vuex, which means I can now put this code in my router since the very next thing I will do is set up the store so there is a state property for `allowAccess`:\n\n```js\n{\n path: "/channel",\n name: "StreamChannel",\n component: () => import("../views/StreamChannel.vue"),\n beforeEnter(to, from, next) {\n   if (store.state.allowAccess === true) {\n     next();\n   } else {\n     next({ name: "EnterCode" });\n     alert("Please enter the secret code");\n   }\n },\n}\n```\n\nI\'ll probably see this error in the browser now since I\'ve referenced `store.state.allowAccess`, but the router file doesn\'t know what the `store` instance is.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/error-store.png" alt="Error: \'store\' is not defined" style="width: 50%; margin:auto;">\n\nTo make it go away, I need to import the store into the router by adding the following import statement to the router folder\'s `index.js` file.\n\n```js\nimport store from \'../store\'\n```\n\nThe [GitHub repo](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/router/index.js) has the code in its entirety for this stage of the project.\n\n## Set up Vuex to Manage State\n\nEven though this is a small application, I am choosing to include a Vuex store because it is common to use Vuex for the purpose of keeping track of whether a user is authenticated/logged-in or not.\n\nIn this project, I will use the Vuex store to keep track of whether a correct entry code has been entered or not by the user. The state property will be called `allowAccess`, and its default state will be false. It will change to true when a user enters the correct code.\n\nHere is the store with the state property I have created:\n\n```js\nimport { createStore } from \'vuex\'\n\nconst store = createStore({\n  state() {\n    return {\n      allowAccess: false,\n    }\n  },\n})\nexport default store\n```\n\nI need to connect the input on the landing (EntryCode) page with this property in state. When the user types a correct code into that input, the submit button triggers a function that checks if the code is correct, and then if it is, dispatches an action to the store, which will cause `allowAccess` to update to `true`.\n\nThe way Vuex causes state to change is through this pattern:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979626/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/vuex.png" alt="Vuex pattern" style="width: 80%; margin:auto;">\n\nVue Component dispatch action -> Store action commit mutation -> Store mutation change state\n\nHere is that flow in the actual code in my project.\n\n1.  The Vue component *EnterCode* form submit button triggers `submitCode()`:\n\n```html\n<form @submit.prevent="submitCode">\n  <label for="code"> Code: </label>\n  <input v-model="code" type="password" name="code" value />\n  <button type="submit" name="button" class="dg-btn">Submit</button>\n</form>\n```\n\n2.  The `submitCode()` method dispatches the `verifyCode` action (which is [passed as a string](https://vuex.vuejs.org/guide/actions.html#dispatching-actions) `\'verifyCode\'`) with a *payload* of `true` or `false`:\n\n```js\nfunction submitCode() {\n  if (code.value === \'pb\') {\n    store.dispatch(\'verifyCode\', true)\n  } else {\n    store.dispatch(\'verifyCode\', false)\n  }\n  code.value = \'\'\n}\n```\n\n3.  The `verifyCode` action in the store commits the `verifyCode` mutation, sending the `true` or `false` payload, referred to hear as `status`:\n\n```js\nactions: {\n verifyCode({ commit }, status) {\n   commit("verifyCode", status);\n },\n},\n```\n\n4.  The `verifyCode` mutation changes state so `allowAccess` equals the `status` payload of `true` or `false`\n\n```js\nmutations: {\n verifyCode(state, status) {\n   state.allowAccess = status;\n },\n},\n```\n\nThe last thing to do is navigate with the router to the *StreamChannel* page if a correct code has been entered (i.e., state for `allowAccess` in the store has changed to true) or alert the user if they have entered the wrong code.\n\n```js\n//StreamChannel.vue\n\nfunction submitCode() {\n  if (code.value === \'PB\') {\n    store.dispatch(\'verifyCode\', true)\n  } else {\n    store.dispatch(\'verifyCode\', false)\n  }\n  // Navigate if correct code, alert if not correct\n  if (store.state.allowAccess) {\n    router.push({ name: \'StreamChannel\' })\n  } else {\n    alert(\'Incorrect code\')\n  }\n  code.value = \'\'\n}\n```\n\nThis version of the project, with the setup I just did for Vue Router and Vuex, can be seen in its entirety in the repo branch titled [vuex-no-server-yet](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/vuex-no-server-yet).\n\n### Security\n\nThe example so far is not very secure because I check for the correct code on the frontend, and that entry code is right there in plain Vue (no pun intended) in the client:\n\n```js\nif (code.value === "pb")\n```\n\nThe more secure way to handle this would be to create a backend server file with an endpoint to check if the code is correct and store that code securely in the server, or even better (so it does not get exposed in GitHub) in a `.env` file.\n\nIn the next section, I\'ll introduce that more secure method of checking the code. I\'ll still use everything I just set up for Vuex, but instead of checking the code in the `EnterCode.vue` file, I\'ll use a fetch request to send that code to the backend for verification.\n\n## Create the Server with Express\n\nNow I\'ll set up my server file, which I\'ll use today for making the entry code more secure, and which I\'ll use in the next post for setting up the Deepgram token endpoint.\n\nAt the root of the project, I\'ll create a `server.js` file and a `.env` file.\n\nI\'ll add this code to create my basic server.\n\n```js\n// bring in node modules\nrequire(\'dotenv\').config()\nconst express = require(\'express\')\nconst app = express()\nvar bodyParser = require(\'body-parser\')\nconst cors = require(\'cors\')\n\n// identify port number\nconst port = 8080\n\n// express use() function to add third-party middleware\napp.use(cors())\napp.use(bodyParser.json())\n\n// ENDPOINT WILL GO HERE\n\n// Connect host to port\napp.listen(port, () => {\n  console.log(`Example app listening at http://localhost:${port}`)\n})\n```\n\n### Dependencies\n\nHere is a brief explanation of each dependency I\'m using in this server file.\n\n#### express\n\n[Express](https://expressjs.com/) is a *node.js* framework that gives me utility methods and middleware to help with setting up routing endpoints (the endpoints deal with requests that come in from the frontend).\n\n#### body-parser\n\nBody-parser is middleware that can take an incoming request body and parse the data. I\'ll be using the JSON parser because the secret entry code will be sent from the frontend as JSON.\n\n#### cors\n\nThis is another middleware package that will help to handle requests from the frontend, specifically cross-origin requests.\n\nSince the client and server have a different origin from each other (such as localhost:8080 vs. localhost:8081), I would need to add a CORS response header `access-control-allow-origins` with information about permitted origins. The CORS middleware will add that header automatically for every request that is sent to the server.\n\n#### dotenv\n\nThis is a very important node module. It allows me to use environment variables in my server file, pulling the values for those variables from the `.env` file. The `.env` file will never be tracked by git, so I can put anything super-secret in the `.env` file and not worry that it will end up on Github for the world to see.\n\n### Run the server\n\nNow I can start up the server to check that everything is working so far.\n\nI will add a script command to the `package.json` file to make it easier to start up the server. In my `package.json`, in the "scripts" object, I\'ll add one for "start":\n\n```js\n"scripts": {\n  "serve": "vue-cli-service serve",\n  ...\n  "start": "node server.js"\n},\n```\n\nNow, in the terminal, when I\'m in the project folder, I can type `npm run start` to start the backend server, and if I open another terminal, I can type `npm run serve` to start the frontend development server.\n\n### Add the secret code value to `.env`\n\nBefore I set up the endpoint, I want to put the expected code value in the `.env` file so that I can access it in the server using `process.env.SECRET_CODE`.\n\nIn the `.env` file, I will add the secret code that I want users to type into the input on the frontend to be able to enter the site. I can add any value I want. In this case, I\'ll just make the value \'code\' (in the earlier section, I used \'pb\' as the code, but I\'m using \'code\' here to make it more obvious that this is the code):\n\n```bash\nSECRET_CODE="code"\n```\n\n### Create the secret-code endpoint\n\nNow I\'ll start on the backend creating the endpoint. The endpoint will expect a value to come in from the frontend (the code entered by the user). Since a value is being sent back, this will be a POST request endpoint.\n\n```js\napp.post(\'/secret-code\', async (req, res) => {})\n```\n\nThe app.post() method is available because of express, and it requires the route path as a slash and whatever I want to name the path, in this case `"/secret-code"`.\n\nWhen the code is sent from the frontend to the backend, it comes in as part of the request body (which is an object), so I will get the code value from `req.body`. Because I plan to send it back in a JSON object as `{ code: "code" }`, the value will come back as `req.body.code`.\n\n```js\nif (req.body.code._value === process.env.SECRET_CODE)\n```\n\nHowever, the value that is sent back is put into another object, which I see when I examine the shape of the req.body.code by using `console.log`. I see this:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/reqbodycode.png" alt="req.body.code object shape" style="width: 50%; margin:auto;">\n\nThe `_value` property actually contains the value that I want to match to my code value I have put in the `.env` file. So I need to access it with `req.body.code._value`. This is how I can check that there is a match:\n\n```js\napp.post(\'/secret-code\', async (req, res) => {\n  if (req.body.code._value === process.env.SECRET_CODE) {\n    res.status(200).json(\'Correct code\')\n  } else {\n    res.status(200).json(\'Incorrect code\')\n  }\n})\n```\n\nThe `res.status()` method will send back the result status code, and the .json() method will make sure it returns to the frontend as JSON data.\n\nNow I can go back to the frontend and write a fetch request that will send the secret code that I need for this verification.\n\n### Fetch POST request\n\nTo write a fetch POST request, I will use [the fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).\n\nTo write a fetch request, I use the `fetch()` method with a first argument of the endpoint path (including the port number) and the second argument an options object:\n\n```js\nfetch(\'http://localhost:8080/secret-code\', requestOptions)\n```\n\nThe options object will give information about the type of request (POST), the headers (to tell that the content will be of the type JSON) and the request body (I will send a JSON object that contains the code):\n\n```js\nconst requestOptions = {\n  method: \'POST\',\n  headers: { \'Content-Type\': \'application/json\' },\n  body: JSON.stringify({ code: code }),\n}\n```\n\nThe fetch request will send the code to the backend server, and since that will take a little bit of time, I will use a promise to wait for the response, doing the following action once that response has been returned. To use a promise, I will attach a `.then()` to the request, which means that anything inside the `.then()` will happen after the response is returned from the fetch request.\n\nOnce the response returns, I will turn it back into JSON and then take that response data to verify if it is correct or not. Depending on if it is correct, I update the state in the store.\n\nRemember, for a verified response of true, I am expecting the backend server to return a response with a JSON string of `"Correct code"`:\n\n```js\nfetch(\'http://localhost:8080/secret-code\', requestOptions)\n  .then((response) => response.json())\n  .then((data) => {\n    if (data === \'Correct code\') {\n      //dispatch payload to store\n    }\n  })\n  .then(() => {\n    if (store.state.allowAccess) {\n      // navigate to channel or alert that code is wrong\n    }\n  })\n```\n\nI\'ve created a branch in the repo called [vuex-with-server ](https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-with-server/src/views/EnterCode.vue)where the code from this step can be viewed in its entirety.\n\n## Conclusion\n\nIn this post, I set up a Vue project and added some of the common features used in a full-stack application: routes, a state management library, and a backend server with endpoints.\n\nNow I am ready to build the **Channel** page, which will contain the video player for my live stream and the audio captions that display the transcript.\n\nPreviously, I went over how to build a live stream web application with **Amazon IVS**, using only vanilla javascript and HTML. But now, I want to use the Vue framework to help me build this in a way that is more reusable, and that incorporates common practices for using Vue.js.\n\nIn my next post, I will introduce how to build the **Amazon IVS** player using **Vue 3 composables**, which will give me a chance to discuss more specifically some of the new features of Vue 3.\n\nI will also introduce how to use Vue 3 composables to create the **Deepgram captions**, and I\'ll include a more secure way of connecting to Deepgram by requesting a Deepgram token from the backend.\n\nI hope you\'ll join me for my next post. As always, feel free to reach out on [Twitter](https://twitter.com/sandra_rodgers_).\n\n        ';
}
function compiledContent() {
  return `<h2 id="introduction">Introduction</h2>
<Panel type="info" title="Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)"><ol><li><a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>
<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>
<li><a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li><li><a href="https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li></ol></Panel>
<p>In my last post, I introduced how to build a vanilla Javascript and HTML live streaming web application with text captions. It included a barebones frontend that was just one page - the video player and captions.</p>
<p>Today I\u2019m going to start building a full-stack application using the same technology, except instead of vanilla Javascript, I will use Vue 3.</p>
<p>The full-stack application will be expanded from the barebones version to include features that are often necessary for real-world applications, such as:</p>
<ul>
<li>a landing page that asks for a code to enter the site</li>
<li>a router (<strong>Vue Router</strong>) to implement routes and a navigation guard so users can\u2019t access beyond the entry page unless they enter the correct code</li>
<li>a state management library (<strong>Vuex</strong>) which will update state to allow access to the stream page if the correct code is entered</li>
<li>a backend server (<strong>node.js</strong> and <strong>express</strong>) with two endpoints, one for getting a <strong>Deepgram</strong> temporary key so I can keep my Deepgram API key secure, and one for verifying the secret code the user must input to enter the site</li>
</ul>
<p>I recommend reading <a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/#setting-up-amazon-ivs">the first post</a> to go through how to set up the video streaming technologies, <strong>Open Broadcaster Software</strong>, and <strong>Amazon IVS</strong>. And for an introduction to Vue 3, it might be worth checking out my series <a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3</a>.</p>
<h2 id="what-ill-build-today">What I\u2019ll Build Today</h2>
<p>In this post, I\u2019ll set up the router (Vue Router) and Vuex so that I can put a navigation guard on the entry page. I will also set up the backend server so I can keep my entry code secure.</p>
<p>Here is the diagram to show the data flow and structure for what I will build today. The focus will be on building the protected entry with a navigation guard. If it seems complicated in the diagram, it won\u2019t by the end of the post because I plan to walk-through building this feature step-by-step.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/ProtectedEntrytoSite.png" alt="Protected entry diagram" style="width: 75%; margin:auto;" />
<h2 id="setting-up-the-vue-project">Setting up the Vue Project</h2>
<p>After <a href="https://cli.vuejs.org/guide/installation.html">installing the Vue CLI</a>, I can create a new Vue project with this command:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">vue create NAME-OF-PROJECT</span></span></code></pre>
<p>I\u2019ll be sure to choose \u2018Manually select features\u2019 so I can add some dependencies during the creation of the project:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets.png" alt="Presents including router and vuex" style="width: 75%; margin:auto;" />
<p>These are the presets I selected. I definitely recommend selecting Router and Vuex since those are required for this project, but the others are just my personal preference :</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets2.png" alt="Presets for linting and router"></p>
<p>I\u2019ll select Vue 3, and then I\u2019ll <code is:raw>cd</code> into the folder.</p>
<p>I can install all the rest of the dependencies now, or I can install them one by one as I need them. Here is a list of the dependencies I\u2019ll be using in this project:</p>
<ul>
<li>vue-router@4 (already installed when I manually selected presets)</li>
<li>vuex@next (already installed when I manually selected presets)</li>
<li>express</li>
<li>dotenv</li>
<li>cors</li>
<li>body-parser</li>
<li>@deepgram/sdk</li>
</ul>
<p>I can install them all at once with this command:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">npm install vue-router@4 vuex@next express dotenv cors body-parser @deepgram/sdk</span></span></code></pre>
<h2 id="the-folders-structure">The Folders Structure</h2>
<p>A Vue application that is created using the Vue CLI starts out with this structure:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Vue-Folder-Structure.png" alt="Vue folder structure after creating new project" style="width: 50%; margin:auto;" />
<p>The <code is:raw>src</code> contains the folders that will make up the frontend, and I will add two files to the root of the project which will be required for the backend. Those two files will be a <code is:raw>server.js</code> file and a <code is:raw>.env</code> file. The final structure can be seen <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram">here</a> at the root level of the project in its GitHub repo.</p>
<h3 id="src-folder">SRC Folder</h3>
<p>I\u2019ll go over the SRC folder in more detail because the way I organize this folder reflects my thinking about how I\u2019ll make the application work when considering how the pieces should fit together.</p>
<p>Here is the file structure of the SRC for the final project (these folders can be set up now or as I progress through building the project):</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/SRC-Folder-Structure.png" alt="Folder structure of SRC folder" style="width: 50%; margin:auto;" />
<p>I\u2019ll go over the pieces starting from the bottom.</p>
<h3 id="mainjs">main.js</h3>
<p>This is the file where Vue will be initialized, and also where Vue Router and Vuex (the store) will be brought into the project as plugins by way of <code is:raw>app.use()</code>.</p>
<h3 id="appvue">App.vue</h3>
<p>This is the top-most parent component, i.e., the <strong>root component</strong>. It holds all the Vue code (coming in as code in this file or code in child components) that will be injected into the <code is:raw>index.html</code> file, inside the <code is:raw>div</code> that has <code is:raw>id="app"</code>.</p>
<h3 id="views">views</h3>
<p>These are the pages that will be the main routes of the project. There will be a page that the user first lands on where they must enter a code. I will name it <code is:raw>EnterCode.vue</code>. And there will be a page that shows the live stream, with the video player and audio captions. I\u2019ll name that page <code is:raw>StreamChannel.vue</code>.</p>
<p>Here is a screenshot of what the views will look like by the end of this post. A demo of the finished project can be found in the first post, which shows the styled version with the video live stream page.</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Two-Page-Views.png" alt="Image of two page views"></p>
<h3 id="store">store</h3>
<p>This is the folder that contains the Vuex store, a state management file. Some state properties need to be widely available throughout the application, not just in one component or one parent-child component. Vuex makes those state properties that I have put in the store available in any Vue files throughout the project.</p>
<h3 id="router">router</h3>
<p>This is the folder that contains the routes and creates the router, so that each view (page) can be navigated to when a user clicks on the link to that page. Using Vue Router means that a user can switch between page views without the page being reloaded every time the route changes.</p>
<h3 id="composables">composables</h3>
<p>This folder contains composition functions that run the logic to make stuff happen, such as getting the user\u2019s microphone or bringing in the Amazon IVS player. Composition functions, or \u2018composables\u2019, are a Vue 3 way of encapsulating logic that can then be run inside the setup function inside a component. Read more about composables <a href="https://blog.deepgram.com/diving-into-vue-3-reusability-with-composables/#reusability-in-the-composition-api">here</a>.</p>
<h3 id="components">components</h3>
<p>The components folder contains two components that will make up the StreamChannel page - the <strong>VideoPlayer</strong> component and the <strong>AudioCaptions</strong> component. I\u2019ll build these components in the next post in this series.</p>
<h2 id="set-up-vue-router-and-the-views">Set up Vue Router and the Views</h2>
<p>The first thing I will do is create the two main pages I intend to make as part of this application - the landing page and the live stream page.</p>
<p>I will create a views folder and put those two main page files in the folder:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Views.png" alt="Views folder with files" style="width: 50%; margin:auto;" />
<p>For each file, I\u2019ll be sure to put in some HTML that will display on the page, so I can see that my router is working:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;Enter Code&lt;/</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>When I created my project with the Vue CLI, I opted to add the Vue Router dependency, which means I have a router already created for me - the <code is:raw>index.js</code> file in the <code is:raw>router</code> folder. The index.js already has two routes set up - home and about.</p>
<p>If I start up the development server, I see that the links at the top of the page will take me between the two routes.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-About-Links.png" alt="Home and About links" style="width: 30%; margin:auto;" />
<p>Since my project is only going to have two pages, I am just going to change the <strong>home</strong> and <strong>about</strong> views of the bootstrapped project to be the <strong>EnterCode</strong> view and the <strong>StreamChannel</strong> View.</p>
<p>In the router file, the three things each route object needs to have are:</p>
<ul>
<li>the path - the URL path for the route</li>
<li>the name - the name I want to give this route (optional, but in my case, I do need it)</li>
<li>the component - the component (view file) that will be loaded for this route</li>
</ul>
<p>Here is the code to set that up in the router:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { createRouter, createWebHistory } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue-router&#39;</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> EnterCode </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../views/EnterCode.vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">routes</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> [</span></span>
<span class="line"><span style="color: #C9D1D9">  {</span></span>
<span class="line"><span style="color: #C9D1D9">    path: </span><span style="color: #A5D6FF">&#39;/&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    name: </span><span style="color: #A5D6FF">&#39;EnterCode&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    component: EnterCode,</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">  {</span></span>
<span class="line"><span style="color: #C9D1D9">    path: </span><span style="color: #A5D6FF">&#39;/stream-channel&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    name: </span><span style="color: #A5D6FF">&#39;StreamChannel&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">component</span><span style="color: #C9D1D9">: () </span><span style="color: #FF7B72">=&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">import</span><span style="color: #C9D1D9">(</span><span style="color: #8B949E">/* webpackChunkName: &quot;about&quot; */</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../views/StreamChannel.vue&#39;</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">router</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">createRouter</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">  history: </span><span style="color: #D2A8FF">createWebHistory</span><span style="color: #C9D1D9">(process.env.</span><span style="color: #79C0FF">BASE_URL</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9">  routes,</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #C9D1D9">router</span></span></code></pre>
<p>I need to go back to App.vue and change the router-links to match my new routes. Even though I\u2019ve named the landing page <code is:raw>EnterCode.vue</code>, I\u2019ll refer to it has <strong>Home</strong> for the user. Notice that the <code is:raw>to=""</code> attribute contains the path:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">nav</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">to</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;/&quot;</span><span style="color: #C9D1D9">&gt;Home&lt;/</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9">&gt; |</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">to</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;/stream-channel&quot;</span><span style="color: #C9D1D9">&gt;Channel&lt;/</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">nav</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">router-view</span><span style="color: #C9D1D9"> /&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>Now I see that my two main pages can be accessed (without reloading the page!) when I click the link to switch to each route:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-Channel-Links.png" alt="Home (enter-code) and Channel Links" style="width: 30%; margin:auto;" />
<h3 id="vue-router-navigation-guards">Vue Router Navigation Guards</h3>
<p>I want the landing page to have a form input where the user has to enter a code, and if the code is correct, they can move on to the channel page. See the code for this input <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/views/EnterCode.vue#L4">here</a>.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Input.png" alt="Input on enter code page" style="width: 50%; margin:auto;" />
<p>But if the code they enter is incorrect, I want to keep them from being able to navigate to that page. Right now, the channel page is completely open, and I can access it just by clicking the <strong>Channel</strong> link.</p>
<p>I can set up a <strong>navigation guard</strong> to perform some logic when the router-link is clicked (<a href="https://router.vuejs.org/guide/advanced/navigation-guards.html">Read the docs</a> for more information about navigation guards).</p>
<p>The logic will check to see if the correct code has been entered. If it has, the router will navigate to the channel page. If not, it will send them back to the home (<code is:raw>EnterCode.vue</code>) page.</p>
<p>To add a navigation guard, I use the <code is:raw>beforeEnter</code> guard:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">path</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;/stream-channel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">name</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;StreamChannel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">component</span><span style="color: #C9D1D9">: () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;../views/StreamChannel.vue&quot;</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">beforeEnter</span><span style="color: #C9D1D9">(to, from, next) {</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E">// ADD LOGIC HERE to check state of allowed access</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>The <code is:raw>next()</code> function will move the navigation forward to the route. I can use an <strong>if statement</strong> to keep that from happening unless certain circumstances are met.</p>
<p>If I include a name of a route in the next() function, the navigation will move to the route I have identified by name. In this example, it would cause navigation to stay on the <strong>EnterCode</strong> page since I have identified that <code is:raw>next</code> should move me to that route.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">beforeEnter</span><span style="color: #C9D1D9">(to, from, next) {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// ADD LOGIC HERE to check state of allowed access</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">({ name: </span><span style="color: #A5D6FF">&quot;EnterCode&quot;</span><span style="color: #C9D1D9"> });</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>I need to have some way of keeping track of the state of whether the correct code was entered or not. I will use the state management system, Vuex, which means I can now put this code in my router since the very next thing I will do is set up the store so there is a state property for <code is:raw>allowAccess</code>:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">path</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;/channel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">name</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;StreamChannel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">component</span><span style="color: #C9D1D9">: () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;../views/StreamChannel.vue&quot;</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">beforeEnter</span><span style="color: #C9D1D9">(to, from, next) {</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (store.state.allowAccess </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9">   } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">({ name: </span><span style="color: #A5D6FF">&quot;EnterCode&quot;</span><span style="color: #C9D1D9"> });</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #D2A8FF">alert</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Please enter the secret code&quot;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">   }</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>I\u2019ll probably see this error in the browser now since I\u2019ve referenced <code is:raw>store.state.allowAccess</code>, but the router file doesn\u2019t know what the <code is:raw>store</code> instance is.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/error-store.png" alt="Error: 'store' is not defined" style="width: 50%; margin:auto;" />
<p>To make it go away, I need to import the store into the router by adding the following import statement to the router folder\u2019s <code is:raw>index.js</code> file.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> store </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../store&#39;</span></span></code></pre>
<p>The <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/router/index.js">GitHub repo</a> has the code in its entirety for this stage of the project.</p>
<h2 id="set-up-vuex-to-manage-state">Set up Vuex to Manage State</h2>
<p>Even though this is a small application, I am choosing to include a Vuex store because it is common to use Vuex for the purpose of keeping track of whether a user is authenticated/logged-in or not.</p>
<p>In this project, I will use the Vuex store to keep track of whether a correct entry code has been entered or not by the user. The state property will be called <code is:raw>allowAccess</code>, and its default state will be false. It will change to true when a user enters the correct code.</p>
<p>Here is the store with the state property I have created:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { createStore } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vuex&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">store</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">createStore</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">state</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      allowAccess: </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #C9D1D9">store</span></span></code></pre>
<p>I need to connect the input on the landing (EntryCode) page with this property in state. When the user types a correct code into that input, the submit button triggers a function that checks if the code is correct, and then if it is, dispatches an action to the store, which will cause <code is:raw>allowAccess</code> to update to <code is:raw>true</code>.</p>
<p>The way Vuex causes state to change is through this pattern:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979626/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/vuex.png" alt="Vuex pattern" style="width: 80%; margin:auto;" />
<p>Vue Component dispatch action -> Store action commit mutation -> Store mutation change state</p>
<p>Here is that flow in the actual code in my project.</p>
<ol>
<li>The Vue component <em>EnterCode</em> form submit button triggers <code is:raw>submitCode()</code>:</li>
</ol>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">form</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">@submit.prevent</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;submitCode&quot;</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">label</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">for</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;code&quot;</span><span style="color: #C9D1D9">&gt; Code: &lt;/</span><span style="color: #7EE787">label</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">input</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">v-model</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;code&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">type</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;password&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">name</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;code&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">value</span><span style="color: #C9D1D9"> /&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">type</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;submit&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">name</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;button&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;dg-btn&quot;</span><span style="color: #C9D1D9">&gt;Submit&lt;/</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">form</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<ol start="2">
<li>The <code is:raw>submitCode()</code> method dispatches the <code is:raw>verifyCode</code> action (which is <a href="https://vuex.vuejs.org/guide/actions.html#dispatching-actions">passed as a string</a> <code is:raw>'verifyCode'</code>) with a <em>payload</em> of <code is:raw>true</code> or <code is:raw>false</code>:</li>
</ol>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">submitCode</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (code.value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;pb&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  code.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<ol start="3">
<li>The <code is:raw>verifyCode</code> action in the store commits the <code is:raw>verifyCode</code> mutation, sending the <code is:raw>true</code> or <code is:raw>false</code> payload, referred to hear as <code is:raw>status</code>:</li>
</ol>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FFA657">actions</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">verifyCode</span><span style="color: #C9D1D9">({ commit }, status) {</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #D2A8FF">commit</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;verifyCode&quot;</span><span style="color: #C9D1D9">, status);</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<ol start="4">
<li>The <code is:raw>verifyCode</code> mutation changes state so <code is:raw>allowAccess</code> equals the <code is:raw>status</code> payload of <code is:raw>true</code> or <code is:raw>false</code></li>
</ol>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FFA657">mutations</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">verifyCode</span><span style="color: #C9D1D9">(state, status) {</span></span>
<span class="line"><span style="color: #C9D1D9">   state.allowAccess </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> status;</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>The last thing to do is navigate with the router to the <em>StreamChannel</em> page if a correct code has been entered (i.e., state for <code is:raw>allowAccess</code> in the store has changed to true) or alert the user if they have entered the wrong code.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//StreamChannel.vue</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">submitCode</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (code.value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;PB&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// Navigate if correct code, alert if not correct</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (store.state.allowAccess) {</span></span>
<span class="line"><span style="color: #C9D1D9">    router.</span><span style="color: #D2A8FF">push</span><span style="color: #C9D1D9">({ name: </span><span style="color: #A5D6FF">&#39;StreamChannel&#39;</span><span style="color: #C9D1D9"> })</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">alert</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Incorrect code&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  code.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>This version of the project, with the setup I just did for Vue Router and Vuex, can be seen in its entirety in the repo branch titled <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/vuex-no-server-yet">vuex-no-server-yet</a>.</p>
<h3 id="security">Security</h3>
<p>The example so far is not very secure because I check for the correct code on the frontend, and that entry code is right there in plain Vue (no pun intended) in the client:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (code.value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;pb&quot;</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>The more secure way to handle this would be to create a backend server file with an endpoint to check if the code is correct and store that code securely in the server, or even better (so it does not get exposed in GitHub) in a <code is:raw>.env</code> file.</p>
<p>In the next section, I\u2019ll introduce that more secure method of checking the code. I\u2019ll still use everything I just set up for Vuex, but instead of checking the code in the <code is:raw>EnterCode.vue</code> file, I\u2019ll use a fetch request to send that code to the backend for verification.</p>
<h2 id="create-the-server-with-express">Create the Server with Express</h2>
<p>Now I\u2019ll set up my server file, which I\u2019ll use today for making the entry code more secure, and which I\u2019ll use in the next post for setting up the Deepgram token endpoint.</p>
<p>At the root of the project, I\u2019ll create a <code is:raw>server.js</code> file and a <code is:raw>.env</code> file.</p>
<p>I\u2019ll add this code to create my basic server.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// bring in node modules</span></span>
<span class="line"><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;dotenv&#39;</span><span style="color: #C9D1D9">).</span><span style="color: #D2A8FF">config</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">express</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;express&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">app</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">express</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #FF7B72">var</span><span style="color: #C9D1D9"> bodyParser </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;body-parser&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">cors</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;cors&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// identify port number</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">port</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8080</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// express use() function to add third-party middleware</span></span>
<span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">use</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">cors</span><span style="color: #C9D1D9">())</span></span>
<span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">use</span><span style="color: #C9D1D9">(bodyParser.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">())</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// ENDPOINT WILL GO HERE</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// Connect host to port</span></span>
<span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">listen</span><span style="color: #C9D1D9">(port, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">\`Example app listening at http://localhost:\${</span><span style="color: #C9D1D9">port</span><span style="color: #A5D6FF">}\`</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<h3 id="dependencies">Dependencies</h3>
<p>Here is a brief explanation of each dependency I\u2019m using in this server file.</p>
<h4 id="express">express</h4>
<p><a href="https://expressjs.com/">Express</a> is a <em>node.js</em> framework that gives me utility methods and middleware to help with setting up routing endpoints (the endpoints deal with requests that come in from the frontend).</p>
<h4 id="body-parser">body-parser</h4>
<p>Body-parser is middleware that can take an incoming request body and parse the data. I\u2019ll be using the JSON parser because the secret entry code will be sent from the frontend as JSON.</p>
<h4 id="cors">cors</h4>
<p>This is another middleware package that will help to handle requests from the frontend, specifically cross-origin requests.</p>
<p>Since the client and server have a different origin from each other (such as localhost:8080 vs. localhost:8081), I would need to add a CORS response header <code is:raw>access-control-allow-origins</code> with information about permitted origins. The CORS middleware will add that header automatically for every request that is sent to the server.</p>
<h4 id="dotenv">dotenv</h4>
<p>This is a very important node module. It allows me to use environment variables in my server file, pulling the values for those variables from the <code is:raw>.env</code> file. The <code is:raw>.env</code> file will never be tracked by git, so I can put anything super-secret in the <code is:raw>.env</code> file and not worry that it will end up on Github for the world to see.</p>
<h3 id="run-the-server">Run the server</h3>
<p>Now I can start up the server to check that everything is working so far.</p>
<p>I will add a script command to the <code is:raw>package.json</code> file to make it easier to start up the server. In my <code is:raw>package.json</code>, in the \u201Cscripts\u201D object, I\u2019ll add one for \u201Cstart\u201D:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #A5D6FF">&quot;scripts&quot;</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #A5D6FF">&quot;serve&quot;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;vue-cli-service serve&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">...</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #A5D6FF">&quot;start&quot;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;node server.js&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>Now, in the terminal, when I\u2019m in the project folder, I can type <code is:raw>npm run start</code> to start the backend server, and if I open another terminal, I can type <code is:raw>npm run serve</code> to start the frontend development server.</p>
<h3 id="add-the-secret-code-value-to-env">Add the secret code value to <code is:raw>.env</code></h3>
<p>Before I set up the endpoint, I want to put the expected code value in the <code is:raw>.env</code> file so that I can access it in the server using <code is:raw>process.env.SECRET_CODE</code>.</p>
<p>In the <code is:raw>.env</code> file, I will add the secret code that I want users to type into the input on the frontend to be able to enter the site. I can add any value I want. In this case, I\u2019ll just make the value \u2018code\u2019 (in the earlier section, I used \u2018pb\u2019 as the code, but I\u2019m using \u2018code\u2019 here to make it more obvious that this is the code):</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">SECRET_CODE=</span><span style="color: #A5D6FF">&quot;code&quot;</span></span></code></pre>
<h3 id="create-the-secret-code-endpoint">Create the secret-code endpoint</h3>
<p>Now I\u2019ll start on the backend creating the endpoint. The endpoint will expect a value to come in from the frontend (the code entered by the user). Since a value is being sent back, this will be a POST request endpoint.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">post</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;/secret-code&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">req</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {})</span></span></code></pre>
<p>The app.post() method is available because of express, and it requires the route path as a slash and whatever I want to name the path, in this case <code is:raw>"/secret-code"</code>.</p>
<p>When the code is sent from the frontend to the backend, it comes in as part of the request body (which is an object), so I will get the code value from <code is:raw>req.body</code>. Because I plan to send it back in a JSON object as <code is:raw>{ code: "code" }</code>, the value will come back as <code is:raw>req.body.code</code>.</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (req.body.code._value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> process.env.</span><span style="color: #79C0FF">SECRET_CODE</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>However, the value that is sent back is put into another object, which I see when I examine the shape of the req.body.code by using <code is:raw>console.log</code>. I see this:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/reqbodycode.png" alt="req.body.code object shape" style="width: 50%; margin:auto;" />
<p>The <code is:raw>_value</code> property actually contains the value that I want to match to my code value I have put in the <code is:raw>.env</code> file. So I need to access it with <code is:raw>req.body.code._value</code>. This is how I can check that there is a match:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">post</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;/secret-code&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">req</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (req.body.code._value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> process.env.</span><span style="color: #79C0FF">SECRET_CODE</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    res.</span><span style="color: #D2A8FF">status</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">).</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Correct code&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    res.</span><span style="color: #D2A8FF">status</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">).</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Incorrect code&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>The <code is:raw>res.status()</code> method will send back the result status code, and the .json() method will make sure it returns to the frontend as JSON data.</p>
<p>Now I can go back to the frontend and write a fetch request that will send the secret code that I need for this verification.</p>
<h3 id="fetch-post-request">Fetch POST request</h3>
<p>To write a fetch POST request, I will use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">the fetch API</a>.</p>
<p>To write a fetch request, I use the <code is:raw>fetch()</code> method with a first argument of the endpoint path (including the port number) and the second argument an options object:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/secret-code&#39;</span><span style="color: #C9D1D9">, requestOptions)</span></span></code></pre>
<p>The options object will give information about the type of request (POST), the headers (to tell that the content will be of the type JSON) and the request body (I will send a JSON object that contains the code):</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">requestOptions</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  method: </span><span style="color: #A5D6FF">&#39;POST&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">  headers: { </span><span style="color: #A5D6FF">&#39;Content-Type&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;application/json&#39;</span><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">  body: </span><span style="color: #79C0FF">JSON</span><span style="color: #C9D1D9">.</span><span style="color: #D2A8FF">stringify</span><span style="color: #C9D1D9">({ code: code }),</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>The fetch request will send the code to the backend server, and since that will take a little bit of time, I will use a promise to wait for the response, doing the following action once that response has been returned. To use a promise, I will attach a <code is:raw>.then()</code> to the request, which means that anything inside the <code is:raw>.then()</code> will happen after the response is returned from the fetch request.</p>
<p>Once the response returns, I will turn it back into JSON and then take that response data to verify if it is correct or not. Depending on if it is correct, I update the state in the store.</p>
<p>Remember, for a verified response of true, I am expecting the backend server to return a response with a JSON string of <code is:raw>"Correct code"</code>:</p>
<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/secret-code&#39;</span><span style="color: #C9D1D9">, requestOptions)</span></span>
<span class="line"><span style="color: #C9D1D9">  .</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">response</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> response.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">())</span></span>
<span class="line"><span style="color: #C9D1D9">  .</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">data</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (data </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Correct code&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">//dispatch payload to store</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span>
<span class="line"><span style="color: #C9D1D9">  .</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (store.state.allowAccess) {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// navigate to channel or alert that code is wrong</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span></code></pre>
<p>I\u2019ve created a branch in the repo called <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-with-server/src/views/EnterCode.vue">vuex-with-server </a>where the code from this step can be viewed in its entirety.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post, I set up a Vue project and added some of the common features used in a full-stack application: routes, a state management library, and a backend server with endpoints.</p>
<p>Now I am ready to build the <strong>Channel</strong> page, which will contain the video player for my live stream and the audio captions that display the transcript.</p>
<p>Previously, I went over how to build a live stream web application with <strong>Amazon IVS</strong>, using only vanilla javascript and HTML. But now, I want to use the Vue framework to help me build this in a way that is more reusable, and that incorporates common practices for using Vue.js.</p>
<p>In my next post, I will introduce how to build the <strong>Amazon IVS</strong> player using <strong>Vue 3 composables</strong>, which will give me a chance to discuss more specifically some of the new features of Vue 3.</p>
<p>I will also introduce how to use Vue 3 composables to create the <strong>Deepgram captions</strong>, and I\u2019ll include a more secure way of connecting to Deepgram by requesting a Deepgram token from the backend.</p>
<p>I hope you\u2019ll join me for my next post. As always, feel free to reach out on <a href="https://twitter.com/sandra_rodgers_">Twitter</a>.</p>`;
}
const $$Astro = createAstro("/Users/sandrarodgers/web-next/blog/src/content/blog/posts/build-a-livestream-web-application-vue-and-express-setup/index.md", "", "file:///Users/sandrarodgers/web-next/blog/");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  new Slugger();
  return renderTemplate`<head>${renderHead($$result)}</head><h2 id="introduction">Introduction</h2>
${renderComponent($$result, "Panel", Panel, { "type": "info", "title": "Build a Live Streaming Web Application with Amazon IVS and Deepgram (SERIES)" }, { "default": () => renderTemplate`<ol><li><a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/">How to Build a Live Streaming Web Application with Amazon IVS and Deepgram</a></li>
<li><a href="https://blog.deepgram.com/build-a-livestream-web-application-vue-and-express-setup/"> Build a Live Streaming Web Application: Vue and Express Setup</a></li>
<li><a href="https://blog.deepgram.com/how-to-write-vue-3-composables-for-a-third-party-API-integration/"> How to Write Vue 3 Composables for a Third-Party API Integration</a></li><li><a href="https://blog.deepgram.com/asynchronous-logic-to-write-a-vue-3-and-deepgram-captions-component/"> Asynchronous Logic to Write a Vue 3 and Deepgram Captions Component</a></li></ol>` })}
<p>In my last post, I introduced how to build a vanilla Javascript and HTML live streaming web application with text captions. It included a barebones frontend that was just one page - the video player and captions.</p>
<p>Today I’m going to start building a full-stack application using the same technology, except instead of vanilla Javascript, I will use Vue 3.</p>
<p>The full-stack application will be expanded from the barebones version to include features that are often necessary for real-world applications, such as:</p>
<ul>
<li>a landing page that asks for a code to enter the site</li>
<li>a router (<strong>Vue Router</strong>) to implement routes and a navigation guard so users can’t access beyond the entry page unless they enter the correct code</li>
<li>a state management library (<strong>Vuex</strong>) which will update state to allow access to the stream page if the correct code is entered</li>
<li>a backend server (<strong>node.js</strong> and <strong>express</strong>) with two endpoints, one for getting a <strong>Deepgram</strong> temporary key so I can keep my Deepgram API key secure, and one for verifying the secret code the user must input to enter the site</li>
</ul>
<p>I recommend reading <a href="https://blog.deepgram.com/build-a-livestream-web-application-with-amazon-ivs-and-deepgram/#setting-up-amazon-ivs">the first post</a> to go through how to set up the video streaming technologies, <strong>Open Broadcaster Software</strong>, and <strong>Amazon IVS</strong>. And for an introduction to Vue 3, it might be worth checking out my series <a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3</a>.</p>
<h2 id="what-ill-build-today">What I’ll Build Today</h2>
<p>In this post, I’ll set up the router (Vue Router) and Vuex so that I can put a navigation guard on the entry page. I will also set up the backend server so I can keep my entry code secure.</p>
<p>Here is the diagram to show the data flow and structure for what I will build today. The focus will be on building the protected entry with a navigation guard. If it seems complicated in the diagram, it won’t by the end of the post because I plan to walk-through building this feature step-by-step.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/ProtectedEntrytoSite.png" alt="Protected entry diagram" style="width: 75%; margin:auto;">
<h2 id="setting-up-the-vue-project">Setting up the Vue Project</h2>
<p>After <a href="https://cli.vuejs.org/guide/installation.html">installing the Vue CLI</a>, I can create a new Vue project with this command:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">vue create NAME-OF-PROJECT</span></span></code></pre>
<p>I’ll be sure to choose ‘Manually select features’ so I can add some dependencies during the creation of the project:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets.png" alt="Presents including router and vuex" style="width: 75%; margin:auto;">
<p>These are the presets I selected. I definitely recommend selecting Router and Vuex since those are required for this project, but the others are just my personal preference :</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Presets2.png" alt="Presets for linting and router"></p>
<p>I’ll select Vue 3, and then I’ll <code>cd</code> into the folder.</p>
<p>I can install all the rest of the dependencies now, or I can install them one by one as I need them. Here is a list of the dependencies I’ll be using in this project:</p>
<ul>
<li>vue-router@4 (already installed when I manually selected presets)</li>
<li>vuex@next (already installed when I manually selected presets)</li>
<li>express</li>
<li>dotenv</li>
<li>cors</li>
<li>body-parser</li>
<li>@deepgram/sdk</li>
</ul>
<p>I can install them all at once with this command:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">npm install vue-router@4 vuex@next express dotenv cors body-parser @deepgram/sdk</span></span></code></pre>
<h2 id="the-folders-structure">The Folders Structure</h2>
<p>A Vue application that is created using the Vue CLI starts out with this structure:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Vue-Folder-Structure.png" alt="Vue folder structure after creating new project" style="width: 50%; margin:auto;">
<p>The <code>src</code> contains the folders that will make up the frontend, and I will add two files to the root of the project which will be required for the backend. Those two files will be a <code>server.js</code> file and a <code>.env</code> file. The final structure can be seen <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram">here</a> at the root level of the project in its GitHub repo.</p>
<h3 id="src-folder">SRC Folder</h3>
<p>I’ll go over the SRC folder in more detail because the way I organize this folder reflects my thinking about how I’ll make the application work when considering how the pieces should fit together.</p>
<p>Here is the file structure of the SRC for the final project (these folders can be set up now or as I progress through building the project):</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/SRC-Folder-Structure.png" alt="Folder structure of SRC folder" style="width: 50%; margin:auto;">
<p>I’ll go over the pieces starting from the bottom.</p>
<h3 id="mainjs">main.js</h3>
<p>This is the file where Vue will be initialized, and also where Vue Router and Vuex (the store) will be brought into the project as plugins by way of <code>app.use()</code>.</p>
<h3 id="appvue">App.vue</h3>
<p>This is the top-most parent component, i.e., the <strong>root component</strong>. It holds all the Vue code (coming in as code in this file or code in child components) that will be injected into the <code>index.html</code> file, inside the <code>div</code> that has <code>id="app"</code>.</p>
<h3 id="views">views</h3>
<p>These are the pages that will be the main routes of the project. There will be a page that the user first lands on where they must enter a code. I will name it <code>EnterCode.vue</code>. And there will be a page that shows the live stream, with the video player and audio captions. I’ll name that page <code>StreamChannel.vue</code>.</p>
<p>Here is a screenshot of what the views will look like by the end of this post. A demo of the finished project can be found in the first post, which shows the styled version with the video live stream page.</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Two-Page-Views.png" alt="Image of two page views"></p>
<h3 id="store">store</h3>
<p>This is the folder that contains the Vuex store, a state management file. Some state properties need to be widely available throughout the application, not just in one component or one parent-child component. Vuex makes those state properties that I have put in the store available in any Vue files throughout the project.</p>
<h3 id="router">router</h3>
<p>This is the folder that contains the routes and creates the router, so that each view (page) can be navigated to when a user clicks on the link to that page. Using Vue Router means that a user can switch between page views without the page being reloaded every time the route changes.</p>
<h3 id="composables">composables</h3>
<p>This folder contains composition functions that run the logic to make stuff happen, such as getting the user’s microphone or bringing in the Amazon IVS player. Composition functions, or ‘composables’, are a Vue 3 way of encapsulating logic that can then be run inside the setup function inside a component. Read more about composables <a href="https://blog.deepgram.com/diving-into-vue-3-reusability-with-composables/#reusability-in-the-composition-api">here</a>.</p>
<h3 id="components">components</h3>
<p>The components folder contains two components that will make up the StreamChannel page - the <strong>VideoPlayer</strong> component and the <strong>AudioCaptions</strong> component. I’ll build these components in the next post in this series.</p>
<h2 id="set-up-vue-router-and-the-views">Set up Vue Router and the Views</h2>
<p>The first thing I will do is create the two main pages I intend to make as part of this application - the landing page and the live stream page.</p>
<p>I will create a views folder and put those two main page files in the folder:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Views.png" alt="Views folder with files" style="width: 50%; margin:auto;">
<p>For each file, I’ll be sure to put in some HTML that will display on the page, so I can see that my router is working:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;Enter Code&lt;/</span><span style="color: #7EE787">h1</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>When I created my project with the Vue CLI, I opted to add the Vue Router dependency, which means I have a router already created for me - the <code>index.js</code> file in the <code>router</code> folder. The index.js already has two routes set up - home and about.</p>
<p>If I start up the development server, I see that the links at the top of the page will take me between the two routes.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-About-Links.png" alt="Home and About links" style="width: 30%; margin:auto;">
<p>Since my project is only going to have two pages, I am just going to change the <strong>home</strong> and <strong>about</strong> views of the bootstrapped project to be the <strong>EnterCode</strong> view and the <strong>StreamChannel</strong> View.</p>
<p>In the router file, the three things each route object needs to have are:</p>
<ul>
<li>the path - the URL path for the route</li>
<li>the name - the name I want to give this route (optional, but in my case, I do need it)</li>
<li>the component - the component (view file) that will be loaded for this route</li>
</ul>
<p>Here is the code to set that up in the router:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { createRouter, createWebHistory } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue-router&#39;</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> EnterCode </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../views/EnterCode.vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">routes</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> [</span></span>
<span class="line"><span style="color: #C9D1D9">  {</span></span>
<span class="line"><span style="color: #C9D1D9">    path: </span><span style="color: #A5D6FF">&#39;/&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    name: </span><span style="color: #A5D6FF">&#39;EnterCode&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    component: EnterCode,</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">  {</span></span>
<span class="line"><span style="color: #C9D1D9">    path: </span><span style="color: #A5D6FF">&#39;/stream-channel&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    name: </span><span style="color: #A5D6FF">&#39;StreamChannel&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">component</span><span style="color: #C9D1D9">: () </span><span style="color: #FF7B72">=&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">import</span><span style="color: #C9D1D9">(</span><span style="color: #8B949E">/* webpackChunkName: &quot;about&quot; */</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../views/StreamChannel.vue&#39;</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">router</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">createRouter</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">  history: </span><span style="color: #D2A8FF">createWebHistory</span><span style="color: #C9D1D9">(process.env.</span><span style="color: #79C0FF">BASE_URL</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9">  routes,</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #C9D1D9">router</span></span></code></pre>
<p>I need to go back to App.vue and change the router-links to match my new routes. Even though I’ve named the landing page <code>EnterCode.vue</code>, I’ll refer to it has <strong>Home</strong> for the user. Notice that the <code>to=""</code> attribute contains the path:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">nav</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">to</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;/&quot;</span><span style="color: #C9D1D9">&gt;Home&lt;/</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9">&gt; |</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">to</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;/stream-channel&quot;</span><span style="color: #C9D1D9">&gt;Channel&lt;/</span><span style="color: #7EE787">router-link</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">nav</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">router-view</span><span style="color: #C9D1D9"> /&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>Now I see that my two main pages can be accessed (without reloading the page!) when I click the link to switch to each route:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Home-Channel-Links.png" alt="Home (enter-code) and Channel Links" style="width: 30%; margin:auto;">
<h3 id="vue-router-navigation-guards">Vue Router Navigation Guards</h3>
<p>I want the landing page to have a form input where the user has to enter a code, and if the code is correct, they can move on to the channel page. See the code for this input <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/views/EnterCode.vue#L4">here</a>.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/Input.png" alt="Input on enter code page" style="width: 50%; margin:auto;">
<p>But if the code they enter is incorrect, I want to keep them from being able to navigate to that page. Right now, the channel page is completely open, and I can access it just by clicking the <strong>Channel</strong> link.</p>
<p>I can set up a <strong>navigation guard</strong> to perform some logic when the router-link is clicked (<a href="https://router.vuejs.org/guide/advanced/navigation-guards.html">Read the docs</a> for more information about navigation guards).</p>
<p>The logic will check to see if the correct code has been entered. If it has, the router will navigate to the channel page. If not, it will send them back to the home (<code>EnterCode.vue</code>) page.</p>
<p>To add a navigation guard, I use the <code>beforeEnter</code> guard:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">path</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;/stream-channel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">name</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;StreamChannel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">component</span><span style="color: #C9D1D9">: () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;../views/StreamChannel.vue&quot;</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">beforeEnter</span><span style="color: #C9D1D9">(to, from, next) {</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #8B949E">// ADD LOGIC HERE to check state of allowed access</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>The <code>next()</code> function will move the navigation forward to the route. I can use an <strong>if statement</strong> to keep that from happening unless certain circumstances are met.</p>
<p>If I include a name of a route in the next() function, the navigation will move to the route I have identified by name. In this example, it would cause navigation to stay on the <strong>EnterCode</strong> page since I have identified that <code>next</code> should move me to that route.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">beforeEnter</span><span style="color: #C9D1D9">(to, from, next) {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// ADD LOGIC HERE to check state of allowed access</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">({ name: </span><span style="color: #A5D6FF">&quot;EnterCode&quot;</span><span style="color: #C9D1D9"> });</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>I need to have some way of keeping track of the state of whether the correct code was entered or not. I will use the state management system, Vuex, which means I can now put this code in my router since the very next thing I will do is set up the store so there is a state property for <code>allowAccess</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">path</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;/channel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">name</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;StreamChannel&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #FFA657">component</span><span style="color: #C9D1D9">: () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;../views/StreamChannel.vue&quot;</span><span style="color: #C9D1D9">),</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">beforeEnter</span><span style="color: #C9D1D9">(to, from, next) {</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (store.state.allowAccess </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9">   } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #D2A8FF">next</span><span style="color: #C9D1D9">({ name: </span><span style="color: #A5D6FF">&quot;EnterCode&quot;</span><span style="color: #C9D1D9"> });</span></span>
<span class="line"><span style="color: #C9D1D9">     </span><span style="color: #D2A8FF">alert</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;Please enter the secret code&quot;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">   }</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>I’ll probably see this error in the browser now since I’ve referenced <code>store.state.allowAccess</code>, but the router file doesn’t know what the <code>store</code> instance is.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/error-store.png" alt="Error: 'store' is not defined" style="width: 50%; margin:auto;">
<p>To make it go away, I need to import the store into the router by adding the following import statement to the router folder’s <code>index.js</code> file.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> store </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../store&#39;</span></span></code></pre>
<p>The <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-no-server-yet/src/router/index.js">GitHub repo</a> has the code in its entirety for this stage of the project.</p>
<h2 id="set-up-vuex-to-manage-state">Set up Vuex to Manage State</h2>
<p>Even though this is a small application, I am choosing to include a Vuex store because it is common to use Vuex for the purpose of keeping track of whether a user is authenticated/logged-in or not.</p>
<p>In this project, I will use the Vuex store to keep track of whether a correct entry code has been entered or not by the user. The state property will be called <code>allowAccess</code>, and its default state will be false. It will change to true when a user enters the correct code.</p>
<p>Here is the store with the state property I have created:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { createStore } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vuex&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">store</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">createStore</span><span style="color: #C9D1D9">({</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">state</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">      allowAccess: </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #C9D1D9">store</span></span></code></pre>
<p>I need to connect the input on the landing (EntryCode) page with this property in state. When the user types a correct code into that input, the submit button triggers a function that checks if the code is correct, and then if it is, dispatches an action to the store, which will cause <code>allowAccess</code> to update to <code>true</code>.</p>
<p>The way Vuex causes state to change is through this pattern:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979626/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/vuex.png" alt="Vuex pattern" style="width: 80%; margin:auto;">
<p>Vue Component dispatch action -> Store action commit mutation -> Store mutation change state</p>
<p>Here is that flow in the actual code in my project.</p>
<ol>
<li>The Vue component <em>EnterCode</em> form submit button triggers <code>submitCode()</code>:</li>
</ol>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">form</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">@submit.prevent</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;submitCode&quot;</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">label</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">for</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;code&quot;</span><span style="color: #C9D1D9">&gt; Code: &lt;/</span><span style="color: #7EE787">label</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">input</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">v-model</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;code&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">type</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;password&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">name</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;code&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">value</span><span style="color: #C9D1D9"> /&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">type</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;submit&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">name</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;button&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;dg-btn&quot;</span><span style="color: #C9D1D9">&gt;Submit&lt;/</span><span style="color: #7EE787">button</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">form</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<ol start="2">
<li>The <code>submitCode()</code> method dispatches the <code>verifyCode</code> action (which is <a href="https://vuex.vuejs.org/guide/actions.html#dispatching-actions">passed as a string</a> <code>'verifyCode'</code>) with a <em>payload</em> of <code>true</code> or <code>false</code>:</li>
</ol>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">submitCode</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (code.value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;pb&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  code.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<ol start="3">
<li>The <code>verifyCode</code> action in the store commits the <code>verifyCode</code> mutation, sending the <code>true</code> or <code>false</code> payload, referred to hear as <code>status</code>:</li>
</ol>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FFA657">actions</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">verifyCode</span><span style="color: #C9D1D9">({ commit }, status) {</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #D2A8FF">commit</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;verifyCode&quot;</span><span style="color: #C9D1D9">, status);</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<ol start="4">
<li>The <code>verifyCode</code> mutation changes state so <code>allowAccess</code> equals the <code>status</code> payload of <code>true</code> or <code>false</code></li>
</ol>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FFA657">mutations</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">verifyCode</span><span style="color: #C9D1D9">(state, status) {</span></span>
<span class="line"><span style="color: #C9D1D9">   state.allowAccess </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> status;</span></span>
<span class="line"><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>The last thing to do is navigate with the router to the <em>StreamChannel</em> page if a correct code has been entered (i.e., state for <code>allowAccess</code> in the store has changed to true) or alert the user if they have entered the wrong code.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//StreamChannel.vue</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">submitCode</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (code.value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;PB&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    store.</span><span style="color: #D2A8FF">dispatch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;verifyCode&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">// Navigate if correct code, alert if not correct</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (store.state.allowAccess) {</span></span>
<span class="line"><span style="color: #C9D1D9">    router.</span><span style="color: #D2A8FF">push</span><span style="color: #C9D1D9">({ name: </span><span style="color: #A5D6FF">&#39;StreamChannel&#39;</span><span style="color: #C9D1D9"> })</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">alert</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Incorrect code&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  code.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>This version of the project, with the setup I just did for Vue Router and Vuex, can be seen in its entirety in the repo branch titled <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/tree/vuex-no-server-yet">vuex-no-server-yet</a>.</p>
<h3 id="security">Security</h3>
<p>The example so far is not very secure because I check for the correct code on the frontend, and that entry code is right there in plain Vue (no pun intended) in the client:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (code.value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;pb&quot;</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>The more secure way to handle this would be to create a backend server file with an endpoint to check if the code is correct and store that code securely in the server, or even better (so it does not get exposed in GitHub) in a <code>.env</code> file.</p>
<p>In the next section, I’ll introduce that more secure method of checking the code. I’ll still use everything I just set up for Vuex, but instead of checking the code in the <code>EnterCode.vue</code> file, I’ll use a fetch request to send that code to the backend for verification.</p>
<h2 id="create-the-server-with-express">Create the Server with Express</h2>
<p>Now I’ll set up my server file, which I’ll use today for making the entry code more secure, and which I’ll use in the next post for setting up the Deepgram token endpoint.</p>
<p>At the root of the project, I’ll create a <code>server.js</code> file and a <code>.env</code> file.</p>
<p>I’ll add this code to create my basic server.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// bring in node modules</span></span>
<span class="line"><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;dotenv&#39;</span><span style="color: #C9D1D9">).</span><span style="color: #D2A8FF">config</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">express</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;express&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">app</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">express</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #FF7B72">var</span><span style="color: #C9D1D9"> bodyParser </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;body-parser&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">cors</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">require</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;cors&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// identify port number</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">port</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">8080</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// express use() function to add third-party middleware</span></span>
<span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">use</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">cors</span><span style="color: #C9D1D9">())</span></span>
<span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">use</span><span style="color: #C9D1D9">(bodyParser.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">())</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// ENDPOINT WILL GO HERE</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// Connect host to port</span></span>
<span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">listen</span><span style="color: #C9D1D9">(port, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  console.</span><span style="color: #D2A8FF">log</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">\`Example app listening at http://localhost:\${</span><span style="color: #C9D1D9">port</span><span style="color: #A5D6FF">}\`</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<h3 id="dependencies">Dependencies</h3>
<p>Here is a brief explanation of each dependency I’m using in this server file.</p>
<h4 id="express">express</h4>
<p><a href="https://expressjs.com/">Express</a> is a <em>node.js</em> framework that gives me utility methods and middleware to help with setting up routing endpoints (the endpoints deal with requests that come in from the frontend).</p>
<h4 id="body-parser">body-parser</h4>
<p>Body-parser is middleware that can take an incoming request body and parse the data. I’ll be using the JSON parser because the secret entry code will be sent from the frontend as JSON.</p>
<h4 id="cors">cors</h4>
<p>This is another middleware package that will help to handle requests from the frontend, specifically cross-origin requests.</p>
<p>Since the client and server have a different origin from each other (such as localhost:8080 vs. localhost:8081), I would need to add a CORS response header <code>access-control-allow-origins</code> with information about permitted origins. The CORS middleware will add that header automatically for every request that is sent to the server.</p>
<h4 id="dotenv">dotenv</h4>
<p>This is a very important node module. It allows me to use environment variables in my server file, pulling the values for those variables from the <code>.env</code> file. The <code>.env</code> file will never be tracked by git, so I can put anything super-secret in the <code>.env</code> file and not worry that it will end up on Github for the world to see.</p>
<h3 id="run-the-server">Run the server</h3>
<p>Now I can start up the server to check that everything is working so far.</p>
<p>I will add a script command to the <code>package.json</code> file to make it easier to start up the server. In my <code>package.json</code>, in the “scripts” object, I’ll add one for “start”:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #A5D6FF">&quot;scripts&quot;</span><span style="color: #C9D1D9">: {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #A5D6FF">&quot;serve&quot;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;vue-cli-service serve&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">...</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #A5D6FF">&quot;start&quot;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&quot;node server.js&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">},</span></span></code></pre>
<p>Now, in the terminal, when I’m in the project folder, I can type <code>npm run start</code> to start the backend server, and if I open another terminal, I can type <code>npm run serve</code> to start the frontend development server.</p>
<h3 id="add-the-secret-code-value-to-env">Add the secret code value to <code>.env</code></h3>
<p>Before I set up the endpoint, I want to put the expected code value in the <code>.env</code> file so that I can access it in the server using <code>process.env.SECRET_CODE</code>.</p>
<p>In the <code>.env</code> file, I will add the secret code that I want users to type into the input on the frontend to be able to enter the site. I can add any value I want. In this case, I’ll just make the value ‘code’ (in the earlier section, I used ‘pb’ as the code, but I’m using ‘code’ here to make it more obvious that this is the code):</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">SECRET_CODE=</span><span style="color: #A5D6FF">&quot;code&quot;</span></span></code></pre>
<h3 id="create-the-secret-code-endpoint">Create the secret-code endpoint</h3>
<p>Now I’ll start on the backend creating the endpoint. The endpoint will expect a value to come in from the frontend (the code entered by the user). Since a value is being sent back, this will be a POST request endpoint.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">post</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;/secret-code&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">req</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {})</span></span></code></pre>
<p>The app.post() method is available because of express, and it requires the route path as a slash and whatever I want to name the path, in this case <code>"/secret-code"</code>.</p>
<p>When the code is sent from the frontend to the backend, it comes in as part of the request body (which is an object), so I will get the code value from <code>req.body</code>. Because I plan to send it back in a JSON object as <code>{ code: "code" }</code>, the value will come back as <code>req.body.code</code>.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (req.body.code._value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> process.env.</span><span style="color: #79C0FF">SECRET_CODE</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>However, the value that is sent back is put into another object, which I see when I examine the shape of the req.body.code by using <code>console.log</code>. I see this:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1647979619/blog/2022/03/build-a-livestream-web-application-vue-and-express-setup/reqbodycode.png" alt="req.body.code object shape" style="width: 50%; margin:auto;">
<p>The <code>_value</code> property actually contains the value that I want to match to my code value I have put in the <code>.env</code> file. So I need to access it with <code>req.body.code._value</code>. This is how I can check that there is a match:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">app.</span><span style="color: #D2A8FF">post</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;/secret-code&#39;</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">req</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">res</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (req.body.code._value </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> process.env.</span><span style="color: #79C0FF">SECRET_CODE</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    res.</span><span style="color: #D2A8FF">status</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">).</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Correct code&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    res.</span><span style="color: #D2A8FF">status</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">).</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;Incorrect code&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>The <code>res.status()</code> method will send back the result status code, and the .json() method will make sure it returns to the frontend as JSON data.</p>
<p>Now I can go back to the frontend and write a fetch request that will send the secret code that I need for this verification.</p>
<h3 id="fetch-post-request">Fetch POST request</h3>
<p>To write a fetch POST request, I will use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">the fetch API</a>.</p>
<p>To write a fetch request, I use the <code>fetch()</code> method with a first argument of the endpoint path (including the port number) and the second argument an options object:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/secret-code&#39;</span><span style="color: #C9D1D9">, requestOptions)</span></span></code></pre>
<p>The options object will give information about the type of request (POST), the headers (to tell that the content will be of the type JSON) and the request body (I will send a JSON object that contains the code):</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">requestOptions</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  method: </span><span style="color: #A5D6FF">&#39;POST&#39;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">  headers: { </span><span style="color: #A5D6FF">&#39;Content-Type&#39;</span><span style="color: #C9D1D9">: </span><span style="color: #A5D6FF">&#39;application/json&#39;</span><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">  body: </span><span style="color: #79C0FF">JSON</span><span style="color: #C9D1D9">.</span><span style="color: #D2A8FF">stringify</span><span style="color: #C9D1D9">({ code: code }),</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>The fetch request will send the code to the backend server, and since that will take a little bit of time, I will use a promise to wait for the response, doing the following action once that response has been returned. To use a promise, I will attach a <code>.then()</code> to the request, which means that anything inside the <code>.then()</code> will happen after the response is returned from the fetch request.</p>
<p>Once the response returns, I will turn it back into JSON and then take that response data to verify if it is correct or not. Depending on if it is correct, I update the state in the store.</p>
<p>Remember, for a verified response of true, I am expecting the backend server to return a response with a JSON string of <code>"Correct code"</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">fetch</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;http://localhost:8080/secret-code&#39;</span><span style="color: #C9D1D9">, requestOptions)</span></span>
<span class="line"><span style="color: #C9D1D9">  .</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">response</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> response.</span><span style="color: #D2A8FF">json</span><span style="color: #C9D1D9">())</span></span>
<span class="line"><span style="color: #C9D1D9">  .</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">((</span><span style="color: #FFA657">data</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (data </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;Correct code&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">//dispatch payload to store</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span>
<span class="line"><span style="color: #C9D1D9">  .</span><span style="color: #D2A8FF">then</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (store.state.allowAccess) {</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #8B949E">// navigate to channel or alert that code is wrong</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span></code></pre>
<p>I’ve created a branch in the repo called <a href="https://github.com/deepgram-devs/livestream-amazonIVS-and-deepgram/blob/vuex-with-server/src/views/EnterCode.vue">vuex-with-server </a>where the code from this step can be viewed in its entirety.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post, I set up a Vue project and added some of the common features used in a full-stack application: routes, a state management library, and a backend server with endpoints.</p>
<p>Now I am ready to build the <strong>Channel</strong> page, which will contain the video player for my live stream and the audio captions that display the transcript.</p>
<p>Previously, I went over how to build a live stream web application with <strong>Amazon IVS</strong>, using only vanilla javascript and HTML. But now, I want to use the Vue framework to help me build this in a way that is more reusable, and that incorporates common practices for using Vue.js.</p>
<p>In my next post, I will introduce how to build the <strong>Amazon IVS</strong> player using <strong>Vue 3 composables</strong>, which will give me a chance to discuss more specifically some of the new features of Vue 3.</p>
<p>I will also introduce how to use Vue 3 composables to create the <strong>Deepgram captions</strong>, and I’ll include a more secure way of connecting to Deepgram by requesting a Deepgram token from the backend.</p>
<p>I hope you’ll join me for my next post. As always, feel free to reach out on <a href="https://twitter.com/sandra_rodgers_">Twitter</a>.</p>`;
}, "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/build-a-livestream-web-application-vue-and-express-setup/index.md");

export { compiledContent, $$Index as default, frontmatter, metadata, rawContent };
