import { c as createAstro, a as createComponent, r as renderTemplate, b as renderHead } from '../entry.mjs';
import Slugger from 'github-slugger';
import '@astrojs/netlify/netlify-functions.js';
import 'preact';
import 'preact-render-to-string';
import 'vue';
import 'vue/server-renderer';
import 'html-escaper';
import 'node-html-parser';
import 'axios';
/* empty css                           *//* empty css                           *//* empty css                           */import '@storyblok/js';
/* empty css                           *//* empty css                          */import 'clone-deep';
import 'slugify';
import 'shiki';
/* empty css                           */import 'camelcase';
import '@astrojs/rss';
/* empty css                           */import 'mime';
import 'cookie';
import 'kleur/colors';
import 'string-width';
import 'path-browserify';
import 'path-to-regexp';

const metadata = { "headings": [{ "depth": 2, "slug": "introduction", "text": "Introduction" }, { "depth": 2, "slug": "example-component", "text": "Example Component" }, { "depth": 3, "slug": "vue-2", "text": "Vue 2" }, { "depth": 3, "slug": "vue-3", "text": "Vue 3" }, { "depth": 4, "slug": "template-refs", "text": "Template Refs" }, { "depth": 4, "slug": "lifecycle-hooks", "text": "Lifecycle Hooks" }, { "depth": 4, "slug": "watch", "text": "watch" }, { "depth": 2, "slug": "reusability-in-the-composition-api", "text": "Reusability in The Composition API" }, { "depth": 2, "slug": "composables", "text": "Composables" }, { "depth": 3, "slug": "usewindowevent", "text": "useWindowEvent" }, { "depth": 3, "slug": "useresizetext", "text": "useResizeText" }, { "depth": 2, "slug": "conclusion", "text": "Conclusion" }], "source": "\n## Introduction\n\nThis is the fifth and final post of my 'Diving Into Vue 3' series. Today I will combine what I have learned so far with a demonstration of how to use the Composition API to take advantage of its biggest strength: writing reusable code. This post will:\n\n*   review everything I've learned so far by walking through how I build an **example component**, focusing on challenges of working with the DOM and using lifecycle methods.\n*   introduce how to use a **template ref** to keep track of an element in the DOM.\n*   demonstrate how to refactor the project to use **composition functions** (i.e. **composables**).\n\nDon't forget there are four previous posts in this series that might be useful to you:\n\n*   [Diving Into Vue 3 - Getting Started](https://blog.deepgram.com/diving-into-vue-3-getting-started/)\n*   [Diving Into Vue 3 - The Setup Function](https://blog.deepgram.com/diving-into-vue-3-setup-function/)\n*   [Diving Into Vue 3: Methods, Watch, and Computed](https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/)\n*   [Diving Into Vue 3: The Reactivity API](https://blog.deepgram.com/diving-into-vue-3-reactivity-api/)\n\nIf you don't need the walk-through for building the example project, feel free to jump to the section on [reusability](#reusability-in-the-composition-api), where I show how to refactor the project to use composables.\n\n## Example Component\n\nI am going to build a single-file component that has a mast with an image on the left and text on the right. The problem I need to address is that I want to change the size of the text based on the image being resized.\n\nHere's the demo:\n\n![Rendered component to that uses method to increment and decrement](https://res.cloudinary.com/deepgram/image/upload/v1645128984/blog/2022/02/diving-into-vue-3-reusability-with-composables/demo.gif)\n\nTo achieve this, I will:\n\n*   listen for resizing of the window with an event listener.\n*   track the image size.\n*   update the text size if the image gets to a certain size.\n\nThe repo to go along with this example can be found [here](https://github.com/deepgram-devs/vue-reusability-with-composables/tree/main/src). There are several branches to show the progression of how the project gets refactored.\n\n### Vue 2\n\nI won't go over how I built the project in Vue 2, but if it helps, the completed project in Vue 2 can be viewed [here](https://stackblitz.com/edit/vue2-vue-cli-vnp6kn?file=src/components/Mast.vue).\n\nResizing the window will show how the text size changes as the width of the image changes.\n\n### Vue 3\n\nHere's how to build the component in Vue 3. The html in the `template` is exactly the same as the Vue 2 project:\n\n```html\n<template>\n  <div class=\"mast\">\n    <div class=\"container\">\n      <div class=\"image-container\">\n        <img ref=\"imageRef\" src=\"../assets/meatball.jpeg\" />\n      </div>\n      <div ref=\"textRef\" class=\"text-container\">\n        <p>\n          Meatball, 9. Barks at Amazon guy. Likes sharing your apple slices.\n          Wants you to grab the toy but won't let you have it.\n        </p>\n      </div>\n    </div>\n  </div>\n</template>\n```\n\nIn the script section, I'll need to add the `setup` function, and then I will define the variables for the data I'll be tracking. Since elements in the DOM will depend on each other to either trigger a change or react to a change, I will need to make them reactive using `ref` so everything stays in sync. Here's how I do that:\n\n```js\n<script>\nimport { ref } from \"vue\";\nexport default {\n  name: \"Mast\",\n  setup() {\n    let imageWidth = ref(0);\n\n    //template refs\n    let imageRef = ref(null);\n    let textRef = ref(null);\n\n    return { imageRef, textRef };\n  },\n};\n<\/script>\n```\n\nThe important data to keep track of is the `imageWidth` because that value is what I will use to determine if the text size should change.\n\nThe `imageWidth` value has to come from the image element in the DOM. It will be based on the actual size of the image at a point in time, so I will need to connect to the actual DOM element using a [template ref](https://vuejs.org/guide/essentials/template-refs.html).\n\n#### Template Refs\n\nI think of template refs as the Vue way of using Javascript to hook into a DOM element, such as the method `document.getElementById()` or `document.querySelector()`.\n\nIn Vue 2, the way to do that is to add `ref=\"nameOfRef\"` as an attribute on the element that I am targeting, then in the script, I could perform some action on it using `this.$refs.nameOfRef`.\n\nIn Vue 3, template refs are now part of the reactive API. If I want to set up a template ref, I still need to add `ref=\"nameOfRef\"` as an attribute on the element that I want to hook into.\n\n```html\n<img ref=\"imageRef\" src=\"../assets/meatball.jpeg\" />\n```\n\nThe difference now is that in the script, I need to define the template ref as a reactive reference variable wrapped in `ref`. And I MUST return it in the `return` object of the `setup` function so that it connects to that DOM element in the template. If I don't, it won't work.\n\n```js\nsetup() {\n    //template refs\n    let imageRef = ref(null);\n    let textRef = ref(null);\n\n    return { imageRef, textRef };\n  },\n```\n\nAlso, I need to be aware that I won't be able to actually access the ref to do something with it until the component has mounted - which brings me to the next topic.\n\n#### Lifecycle Hooks\n\nNow that I have the data set up I can add the logic to listen for the resize event.\n\nI want to track the size of the image, which will change depending on if the window is resized. Since I'm dealing with a visual element, I need to consider timing of when that element will appear in the browser. It won't appear until the component has mounted.\n\nThe hooks that I'll need for setting up the event listener (and destroying it) are `onMounted` and `onUnmounted`, which are the equivalent to `mounted` and `unmounted` in Vue 2.\n\nIn `onMounted`, I have access to the template ref, so I will first set the initial value of the `imageWidth` based on the width of the actual image, which I pull from the template ref. I will also put a listener on the window to track the resizing event so that as the window is resized, the `resizeHandler` function runs.\n\nEverything currently resides in the setup function for now, but will be refactored later and moved into composables:\n\n```js\n// inside setup function:\n\nonMounted(() => {\n  //set initial value\n  imageWidth.value = imageRef.value.offsetWidth\n\n  //add listener to track resize\n  window.addEventListener('resize', resizeHandler)\n})\n```\n\nThe `resizeHandler` sets the `imageWidth` value to the `imageRef`'s width. I have to remember that with refs in the script, I have to unwrap the value using `.value`:\n\n```js\n// inside setup function:\n\nfunction resizeHandler() {\n  //tracking of width changes\n  imageWidth.value = imageRef.value.offsetWidth\n}\n```\n\nSince I'm listening for the resize event starting when the component mounts, I need to be sure to destroy the listener when the component unmounts:\n\n```js\n// inside setup function:\n\nonUnmounted(() => {\n  //remove listener\n  window.removeEventListener('resize', resizeHandler)\n})\n```\n\n#### watch\n\nI now have the data set up so that the `imageWidth` updates in-sync with the `imageRef`'s width as the event listener fires the `resizeHandler` function.\n\nThe last thing I need to do is make something happen as a side effect of the `imageWidth` increasing or decreasing. Vue offers `watch` and `watchEffect` as part of the API for watching a reactive property and causing a side effect to occur based on changes to the property.\n\nIn this case, I will use `watch` because I only need to track the `imageWidth` value since a change to `imageWidth` is what I'm using to cause the text size to change.\n\n```js\n// inside setup function:\n\nwatch(imageWidth, () => {\n  //initiate side effects to change text size when window width changes\n  if (imageWidth.value < 150) {\n    textRef.value.style.fontSize = '.8em'\n    textRef.value.style.lineHeight = '1.3'\n  }\n  if (imageWidth.value < 200 && imageWidth.value > 150) {\n    textRef.value.style.fontSize = '1em'\n    textRef.value.style.lineHeight = '1.4'\n  }\n  if (imageWidth.value > 200) {\n    textRef.value.style.fontSize = '1.3em'\n    textRef.value.style.lineHeight = '1.5'\n  }\n})\n```\n\nHere is the finished [example code](https://github.com/SandraRodgers/vue-reusability-with-composables/tree/no-composables/src) using Vue 3 (and before I refactor it to use composables). Now that everything is working, I will refactor my code to make it more reusable.\n\n## Reusability in The Composition API\n\nMany people would say that the biggest advantage of using Vue 3's Composition API is its emphasis on organizing code by logical concern rather than by option types like in Vue 2. If I'm building a small application that is only going to have minimal logic in a component, the Options API, or even just putting all my logic in the setup function, is fine. But as a component grows larger, it can be challenging to follow the data flow.\n\nFor example, a UI component such as a dropdown menu has to deal with opening and closing the dropdown, keyboard interactions, pulling in data to populate the menu, and more. All that logic in one component spread out among the options like `methods`, `watch`, `mounted`, etc., can be hard to decipher.\n\nVue 2 does offer approaches for separating out logic, such as **mixins** and **utility functions**. But Vue 3's whole philosophy is designed around the idea of writing code that is reusable, focused around logical concern, and easy to read. The most fundamental way it does this is through **composition functions** (i.e. **composables**).\n\n## Composables\n\nThe advantage of organizing code by logical concern encapsulated in a composable function is that it becomes easier to read, but it also becomes easier to reuse in other parts of the project or even in other projects.\n\nI feel that the ultimate goal should be to write the most agnostic code possible in a composable, i.e. code that can be recycled in different contexts and isn't so dependent on the one unique context it starts out in.\n\nIt does take time and practice to get better at this skill, but the good news is, Vue 3 is the perfect framework to work at it because using the Composition API really emphasizes this approach to coding.\n\nWith that in mind, I'll think about how I can refactor my project to take advantage of composables.\n\n### useWindowEvent\n\nA common situation is having to listen for an event on the window, such as a resize event. I see an opportunity to write a composable that can be reused when I want to add or destroy an event listener on the window.\n\nIn my project, in the `onMounted` hook I currently have:\n\n```js\nwindow.addEventListener('resize', resizeHandler)\n```\n\nAnd in the `unMounted` hook:\n\n```js\nwindow.removeEventListener('resize', resizeHandler)\n```\n\nI can create a composable function that accepts an event-type, a handler, and a string saying 'add' or 'destroy', and write logic that will set up the window event listener. I will put this file in a folder called `~/composables`. The Vue 3 convention is to name composable files with the prefix 'use' as in *useWindowEvent*.\n\nHere is the composable `useWindowEvent.js`:\n\n```js\nexport default function useWindowEvent(event, handler, addOrDestroy) {\n  if (addOrDestroy === 'add') {\n    window.addEventListener(event, handler)\n  }\n\n  if (addOrDestroy === 'destroy') {\n    window.removeEventListener(event, handler)\n  }\n}\n```\n\nNow in my project, I import it into the component where it will be used:\n\n```js\nimport useWindowEvent from '../composables/useWindowEvent'\n```\n\nThen I invoke the function with the arguments that I set it up to receive:\n\n```js\nuseWindowEvent('resize', resizeHandler, 'add')\n```\n\nThis is just a small composable, and it doesn't really make my life that much easier since I didn't have to write very much code anyways to set up the listener on the window.\n\nBut there is a significant advantage to creating reusable code. I know the composable is written to work, so I'm less likely to have little errors or typos since I'm reusing code that has been tested and used before. Because I've tested it, I can feel confident reusing it in many contexts.\n\nConsistency is another benefit. I keep functionality consistent by using the composable in multiple places, rather than having to reinvent the wheel every time, potentially introducing differences (and problems).\n\nAnd now that I have created a `useWindowEvent`, I could try to make it to work for all kinds of elements, not just the window. If I spend some time improving it so that it can add an event listener to any type of element, then I have a really useful composable that I can reuse.\n\n### useResizeText\n\nThe main feature of my project is that the text resizes based on the image element's width. I can turn this into a composable that can be reused in cases where I want text to resize based on some other element.\n\nIn my goal to write it in a way that is more agnostic, I can think of the element that is watched (the image) as the *trigger element*, and the element that changes (the text) as the *react element*. In the `resizeText` composable, I'll refer to them as the `triggerElement` and the `reactElement`, but in the `Mast.vue` component they are the `imageRef` and the `textRef`. These are more specific references to the context of my project, while `triggerElement` and `reactElement` are more general since I would like the composable to be reused if I ever need it in a different project.\n\nI create the composable file called `useResizeText.js`. I anticipate that I'll need to accept two arguments, the `triggerElement` and the `reactElement` (which come in from `Mast.vue` as the `imageRef` and the `textRef`):\n\n```js\n//useResizeText.js:\n\nexport default function useResizeText(triggerElement, reactElement) {\n  return { elementWidth }\n}\n```\n\nI've included the return object because any data from the composable that I want to make available in the component (or another file) must be included in it. I'll return the `elementWidth` to the component so I can put it in my template in `Mast.vue` and see the resize logic working in real-time.\n\nIn the `Mast.vue` component, I will call the composable. I have to send in the template refs so the composable can compute the text size based on those DOM elements. I will destructure the composable so that I get the returned `elementWidth`.\n\nInside `setup` in `Mast.vue`:\n\n```js\n//destructure to get data sent back from the composable\n//get updated width for template\nconst { elementWidth } = useResizeText(imageRef, textRef)\n```\n\nI will return `elementWidth` to the template so that I see that number reacting to the window resizing. I also return `imageRef` and `textRef` because that is required for the template refs to stay in-sync between the script and the template.\n\nHere is everything in the `setup` function:\n\n```js\nsetup() {\n    //template refs\n    let imageRef = ref(null);\n    let textRef = ref(null);\n    //destructure to get data sent back from the composable\n    //get updated width for template\n    const { elementWidth } = useResizeText(imageRef, textRef);\n    return { imageRef, textRef, elementWidth };\n  },\n\n```\n\nThe composable itself is mostly the same as it was when I wrote the logic in the setup function, with a few small updates.\n\nTo make sure I don't get an error when I set the `elementWidth` to the imageRef/triggerElement `offsetHeight` value, I use an 'if' statement to make sure the `triggerElement` exists:\n\n```js\nif (triggerElement.value) {\n  elementWidth.value = triggerElement.value.offsetWidth\n}\n```\n\nI also set the initial text styles as soon as the component mounts and then run that `setTextStyles` function again inside the watch every time the `elementWidth` (the image's width) changes.\n\nHere is the full code for the `resizeText.js` composable:\n\n```js\nimport { ref, watch, onMounted, onUnmounted } from 'vue'\nimport useWindowEvent from './useWindowEvent'\n\nexport default function useResize(triggerElement, reactElement) {\n  let elementWidth = ref(0)\n\n  //handler to send into useWindowEvent\n  function resizeHandler() {\n    if (triggerElement.value) {\n      elementWidth.value = triggerElement.value.offsetWidth\n    }\n  }\n\n  //set initial values for elementWidth and text styles\n  onMounted(() => {\n    if (triggerElement.value) {\n      elementWidth.value = triggerElement.value.offsetWidth\n      setTextStyles()\n    }\n  })\n\n  //function to set text styles on mount and in watcher\n  function setTextStyles() {\n    if (elementWidth.value < 150) {\n      reactElement.value.style.fontSize = '.8em'\n      reactElement.value.style.lineHeight = '1.3'\n    }\n    if (elementWidth.value < 200 && elementWidth.value > 150) {\n      reactElement.value.style.fontSize = '1em'\n      reactElement.value.style.lineHeight = '1.4'\n    }\n    if (elementWidth.value > 200) {\n      reactElement.value.style.fontSize = '1.3em'\n      reactElement.value.style.lineHeight = '1.5'\n    }\n  }\n\n  //add and destroy event listeners\n  useWindowEvent('resize', resizeHandler, 'add')\n  onUnmounted(() => {\n    useWindowEvent('resize', resizeHandler, 'destroy')\n  })\n\n  //watch elementWidth and set text styles\n  watch(elementWidth, () => {\n    setTextStyles()\n  })\n\n  return { elementWidth }\n}\n```\n\nThis [refactoring](https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-first-refactor/src) makes `Mast.vue` much easier to read because the logic for resizing the text and for adding a window event listener are separated out into composables.\n\nHowever, my ultimate goal is to make composables that are more reusable in general. There is more I can do to make the `resizeText` composable reusable in other projects.\n\nFor example, I could set it up to take a breakpoints object, so that I don't have to always use the same hardcoded width sizes to influence the text.\n\nI could also rework it accept a styles object for the text styles so that I'm not required to use the same hardcoded values for text styles for any component that uses the composable. Something like this in the component:\n\n```js\n//constants\nconst breakPoints = { small: '100', medium: '150', large: '200' }\nconst textStyles = {\n  fontSize: { small: '.8em', medium: '1em', large: '1.3em' },\n  lineHeight: { small: '1.3', medium: '1.4', large: '1.5' },\n}\n```\n\nHere is the [full example](https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-second-refactor/src).\n\nThere are still many ways to improve this composable to make it more agnostic, but this gives a general idea of the process that goes into making a composable more reusable.\n\n## Conclusion\n\nThis concludes my series on Diving into Vue 3. I have learned the fundamentals that will allow me to jump into building projects using the Composition API. I feel so much more confident in Vue 3 now, and I'm also really excited about it.\n\nI hope you have enjoyed this series. There is always more to learn, so stay tuned for future posts about Vue topics.\n\nQuestions? Comments? Just want to say hi? You can find me on [Twitter](https://twitter.com/sandra_rodgers_)!\n\n        ", "html": '<h2 id="introduction">Introduction</h2>\n<p>This is the fifth and final post of my \u2018Diving Into Vue 3\u2019 series. Today I will combine what I have learned so far with a demonstration of how to use the Composition API to take advantage of its biggest strength: writing reusable code. This post will:</p>\n<ul>\n<li>review everything I\u2019ve learned so far by walking through how I build an <strong>example component</strong>, focusing on challenges of working with the DOM and using lifecycle methods.</li>\n<li>introduce how to use a <strong>template ref</strong> to keep track of an element in the DOM.</li>\n<li>demonstrate how to refactor the project to use <strong>composition functions</strong> (i.e. <strong>composables</strong>).</li>\n</ul>\n<p>Don\u2019t forget there are four previous posts in this series that might be useful to you:</p>\n<ul>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3 - Getting Started</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-setup-function/">Diving Into Vue 3 - The Setup Function</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/">Diving Into Vue 3: Methods, Watch, and Computed</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-reactivity-api/">Diving Into Vue 3: The Reactivity API</a></li>\n</ul>\n<p>If you don\u2019t need the walk-through for building the example project, feel free to jump to the section on <a href="#reusability-in-the-composition-api">reusability</a>, where I show how to refactor the project to use composables.</p>\n<h2 id="example-component">Example Component</h2>\n<p>I am going to build a single-file component that has a mast with an image on the left and text on the right. The problem I need to address is that I want to change the size of the text based on the image being resized.</p>\n<p>Here\u2019s the demo:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1645128984/blog/2022/02/diving-into-vue-3-reusability-with-composables/demo.gif" alt="Rendered component to that uses method to increment and decrement"></p>\n<p>To achieve this, I will:</p>\n<ul>\n<li>listen for resizing of the window with an event listener.</li>\n<li>track the image size.</li>\n<li>update the text size if the image gets to a certain size.</li>\n</ul>\n<p>The repo to go along with this example can be found <a href="https://github.com/deepgram-devs/vue-reusability-with-composables/tree/main/src">here</a>. There are several branches to show the progression of how the project gets refactored.</p>\n<h3 id="vue-2">Vue 2</h3>\n<p>I won\u2019t go over how I built the project in Vue 2, but if it helps, the completed project in Vue 2 can be viewed <a href="https://stackblitz.com/edit/vue2-vue-cli-vnp6kn?file=src/components/Mast.vue">here</a>.</p>\n<p>Resizing the window will show how the text size changes as the width of the image changes.</p>\n<h3 id="vue-3">Vue 3</h3>\n<p>Here\u2019s how to build the component in Vue 3. The html in the <code is:raw>template</code> is exactly the same as the Vue 2 project:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;mast&quot;</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;container&quot;</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">      &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;image-container&quot;</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">        &lt;</span><span style="color: #7EE787">img</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">ref</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;imageRef&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">src</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;../assets/meatball.jpeg&quot;</span><span style="color: #C9D1D9"> /&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">      &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">      &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">ref</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;textRef&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;text-container&quot;</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">        &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">          Meatball, 9. Barks at Amazon guy. Likes sharing your apple slices.</span></span>\n<span class="line"><span style="color: #C9D1D9">          Wants you to grab the toy but won&#39;t let you have it.</span></span>\n<span class="line"><span style="color: #C9D1D9">        &lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">      &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>In the script section, I\u2019ll need to add the <code is:raw>setup</code> function, and then I will define the variables for the data I\u2019ll be tracking. Since elements in the DOM will depend on each other to either trigger a change or react to a change, I will need to make them reactive using <code is:raw>ref</code> so everything stays in sync. Here\u2019s how I do that:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  name: </span><span style="color: #A5D6FF">&quot;Mast&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let imageWidth </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//template refs</span></span>\n<span class="line"><span style="color: #C9D1D9">    let imageRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    let textRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { imageRef, textRef };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>The important data to keep track of is the <code is:raw>imageWidth</code> because that value is what I will use to determine if the text size should change.</p>\n<p>The <code is:raw>imageWidth</code> value has to come from the image element in the DOM. It will be based on the actual size of the image at a point in time, so I will need to connect to the actual DOM element using a <a href="https://vuejs.org/guide/essentials/template-refs.html">template ref</a>.</p>\n<h4 id="template-refs">Template Refs</h4>\n<p>I think of template refs as the Vue way of using Javascript to hook into a DOM element, such as the method <code is:raw>document.getElementById()</code> or <code is:raw>document.querySelector()</code>.</p>\n<p>In Vue 2, the way to do that is to add <code is:raw>ref="nameOfRef"</code> as an attribute on the element that I am targeting, then in the script, I could perform some action on it using <code is:raw>this.$refs.nameOfRef</code>.</p>\n<p>In Vue 3, template refs are now part of the reactive API. If I want to set up a template ref, I still need to add <code is:raw>ref="nameOfRef"</code> as an attribute on the element that I want to hook into.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">img</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">ref</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;imageRef&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">src</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;../assets/meatball.jpeg&quot;</span><span style="color: #C9D1D9"> /&gt;</span></span></code></pre>\n<p>The difference now is that in the script, I need to define the template ref as a reactive reference variable wrapped in <code is:raw>ref</code>. And I MUST return it in the <code is:raw>return</code> object of the <code is:raw>setup</code> function so that it connects to that DOM element in the template. If I don\u2019t, it won\u2019t work.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//template refs</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> imageRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> textRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { imageRef, textRef };</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span></code></pre>\n<p>Also, I need to be aware that I won\u2019t be able to actually access the ref to do something with it until the component has mounted - which brings me to the next topic.</p>\n<h4 id="lifecycle-hooks">Lifecycle Hooks</h4>\n<p>Now that I have the data set up I can add the logic to listen for the resize event.</p>\n<p>I want to track the size of the image, which will change depending on if the window is resized. Since I\u2019m dealing with a visual element, I need to consider timing of when that element will appear in the browser. It won\u2019t appear until the component has mounted.</p>\n<p>The hooks that I\u2019ll need for setting up the event listener (and destroying it) are <code is:raw>onMounted</code> and <code is:raw>onUnmounted</code>, which are the equivalent to <code is:raw>mounted</code> and <code is:raw>unmounted</code> in Vue 2.</p>\n<p>In <code is:raw>onMounted</code>, I have access to the template ref, so I will first set the initial value of the <code is:raw>imageWidth</code> based on the width of the actual image, which I pull from the template ref. I will also put a listener on the window to track the resizing event so that as the window is resized, the <code is:raw>resizeHandler</code> function runs.</p>\n<p>Everything currently resides in the setup function for now, but will be refactored later and moved into composables:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #D2A8FF">onMounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//set initial value</span></span>\n<span class="line"><span style="color: #C9D1D9">  imageWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> imageRef.value.offsetWidth</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//add listener to track resize</span></span>\n<span class="line"><span style="color: #C9D1D9">  window.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>The <code is:raw>resizeHandler</code> sets the <code is:raw>imageWidth</code> value to the <code is:raw>imageRef</code>\u2019s width. I have to remember that with refs in the script, I have to unwrap the value using <code is:raw>.value</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">resizeHandler</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//tracking of width changes</span></span>\n<span class="line"><span style="color: #C9D1D9">  imageWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> imageRef.value.offsetWidth</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Since I\u2019m listening for the resize event starting when the component mounts, I need to be sure to destroy the listener when the component unmounts:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #D2A8FF">onUnmounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//remove listener</span></span>\n<span class="line"><span style="color: #C9D1D9">  window.</span><span style="color: #D2A8FF">removeEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<h4 id="watch">watch</h4>\n<p>I now have the data set up so that the <code is:raw>imageWidth</code> updates in-sync with the <code is:raw>imageRef</code>\u2019s width as the event listener fires the <code is:raw>resizeHandler</code> function.</p>\n<p>The last thing I need to do is make something happen as a side effect of the <code is:raw>imageWidth</code> increasing or decreasing. Vue offers <code is:raw>watch</code> and <code is:raw>watchEffect</code> as part of the API for watching a reactive property and causing a side effect to occur based on changes to the property.</p>\n<p>In this case, I will use <code is:raw>watch</code> because I only need to track the <code is:raw>imageWidth</code> value since a change to <code is:raw>imageWidth</code> is what I\u2019m using to cause the text size to change.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(imageWidth, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//initiate side effects to change text size when window width changes</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (imageWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;.8em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (imageWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> imageWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.4&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (imageWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.5&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>Here is the finished <a href="https://github.com/SandraRodgers/vue-reusability-with-composables/tree/no-composables/src">example code</a> using Vue 3 (and before I refactor it to use composables). Now that everything is working, I will refactor my code to make it more reusable.</p>\n<h2 id="reusability-in-the-composition-api">Reusability in The Composition API</h2>\n<p>Many people would say that the biggest advantage of using Vue 3\u2019s Composition API is its emphasis on organizing code by logical concern rather than by option types like in Vue 2. If I\u2019m building a small application that is only going to have minimal logic in a component, the Options API, or even just putting all my logic in the setup function, is fine. But as a component grows larger, it can be challenging to follow the data flow.</p>\n<p>For example, a UI component such as a dropdown menu has to deal with opening and closing the dropdown, keyboard interactions, pulling in data to populate the menu, and more. All that logic in one component spread out among the options like <code is:raw>methods</code>, <code is:raw>watch</code>, <code is:raw>mounted</code>, etc., can be hard to decipher.</p>\n<p>Vue 2 does offer approaches for separating out logic, such as <strong>mixins</strong> and <strong>utility functions</strong>. But Vue 3\u2019s whole philosophy is designed around the idea of writing code that is reusable, focused around logical concern, and easy to read. The most fundamental way it does this is through <strong>composition functions</strong> (i.e. <strong>composables</strong>).</p>\n<h2 id="composables">Composables</h2>\n<p>The advantage of organizing code by logical concern encapsulated in a composable function is that it becomes easier to read, but it also becomes easier to reuse in other parts of the project or even in other projects.</p>\n<p>I feel that the ultimate goal should be to write the most agnostic code possible in a composable, i.e. code that can be recycled in different contexts and isn\u2019t so dependent on the one unique context it starts out in.</p>\n<p>It does take time and practice to get better at this skill, but the good news is, Vue 3 is the perfect framework to work at it because using the Composition API really emphasizes this approach to coding.</p>\n<p>With that in mind, I\u2019ll think about how I can refactor my project to take advantage of composables.</p>\n<h3 id="usewindowevent">useWindowEvent</h3>\n<p>A common situation is having to listen for an event on the window, such as a resize event. I see an opportunity to write a composable that can be reused when I want to add or destroy an event listener on the window.</p>\n<p>In my project, in the <code is:raw>onMounted</code> hook I currently have:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">window.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span></code></pre>\n<p>And in the <code is:raw>unMounted</code> hook:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">window.</span><span style="color: #D2A8FF">removeEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span></code></pre>\n<p>I can create a composable function that accepts an event-type, a handler, and a string saying \u2018add\u2019 or \u2018destroy\u2019, and write logic that will set up the window event listener. I will put this file in a folder called <code is:raw>~/composables</code>. The Vue 3 convention is to name composable files with the prefix \u2018use\u2019 as in <em>useWindowEvent</em>.</p>\n<p>Here is the composable <code is:raw>useWindowEvent.js</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #FFA657">(event, handler, addOrDestroy) </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (addOrDestroy </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;add&#39;</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    window.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(event, handler)</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (addOrDestroy </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;destroy&#39;</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    window.</span><span style="color: #D2A8FF">removeEventListener</span><span style="color: #C9D1D9">(event, handler)</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now in my project, I import it into the component where it will be used:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useWindowEvent </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../composables/useWindowEvent&#39;</span></span></code></pre>\n<p>Then I invoke the function with the arguments that I set it up to receive:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler, </span><span style="color: #A5D6FF">&#39;add&#39;</span><span style="color: #C9D1D9">)</span></span></code></pre>\n<p>This is just a small composable, and it doesn\u2019t really make my life that much easier since I didn\u2019t have to write very much code anyways to set up the listener on the window.</p>\n<p>But there is a significant advantage to creating reusable code. I know the composable is written to work, so I\u2019m less likely to have little errors or typos since I\u2019m reusing code that has been tested and used before. Because I\u2019ve tested it, I can feel confident reusing it in many contexts.</p>\n<p>Consistency is another benefit. I keep functionality consistent by using the composable in multiple places, rather than having to reinvent the wheel every time, potentially introducing differences (and problems).</p>\n<p>And now that I have created a <code is:raw>useWindowEvent</code>, I could try to make it to work for all kinds of elements, not just the window. If I spend some time improving it so that it can add an event listener to any type of element, then I have a really useful composable that I can reuse.</p>\n<h3 id="useresizetext">useResizeText</h3>\n<p>The main feature of my project is that the text resizes based on the image element\u2019s width. I can turn this into a composable that can be reused in cases where I want text to resize based on some other element.</p>\n<p>In my goal to write it in a way that is more agnostic, I can think of the element that is watched (the image) as the <em>trigger element</em>, and the element that changes (the text) as the <em>react element</em>. In the <code is:raw>resizeText</code> composable, I\u2019ll refer to them as the <code is:raw>triggerElement</code> and the <code is:raw>reactElement</code>, but in the <code is:raw>Mast.vue</code> component they are the <code is:raw>imageRef</code> and the <code is:raw>textRef</code>. These are more specific references to the context of my project, while <code is:raw>triggerElement</code> and <code is:raw>reactElement</code> are more general since I would like the composable to be reused if I ever need it in a different project.</p>\n<p>I create the composable file called <code is:raw>useResizeText.js</code>. I anticipate that I\u2019ll need to accept two arguments, the <code is:raw>triggerElement</code> and the <code is:raw>reactElement</code> (which come in from <code is:raw>Mast.vue</code> as the <code is:raw>imageRef</code> and the <code is:raw>textRef</code>):</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//useResizeText.js:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useResizeText</span><span style="color: #FFA657">(triggerElement, reactElement) </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { elementWidth }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I\u2019ve included the return object because any data from the composable that I want to make available in the component (or another file) must be included in it. I\u2019ll return the <code is:raw>elementWidth</code> to the component so I can put it in my template in <code is:raw>Mast.vue</code> and see the resize logic working in real-time.</p>\n<p>In the <code is:raw>Mast.vue</code> component, I will call the composable. I have to send in the template refs so the composable can compute the text size based on those DOM elements. I will destructure the composable so that I get the returned <code is:raw>elementWidth</code>.</p>\n<p>Inside <code is:raw>setup</code> in <code is:raw>Mast.vue</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//destructure to get data sent back from the composable</span></span>\n<span class="line"><span style="color: #8B949E">//get updated width for template</span></span>\n<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">elementWidth</span><span style="color: #C9D1D9"> } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useResizeText</span><span style="color: #C9D1D9">(imageRef, textRef)</span></span></code></pre>\n<p>I will return <code is:raw>elementWidth</code> to the template so that I see that number reacting to the window resizing. I also return <code is:raw>imageRef</code> and <code is:raw>textRef</code> because that is required for the template refs to stay in-sync between the script and the template.</p>\n<p>Here is everything in the <code is:raw>setup</code> function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//template refs</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> imageRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> textRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//destructure to get data sent back from the composable</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//get updated width for template</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">elementWidth</span><span style="color: #C9D1D9"> } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useResizeText</span><span style="color: #C9D1D9">(imageRef, textRef);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { imageRef, textRef, elementWidth };</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span>\n<span class="line"></span></code></pre>\n<p>The composable itself is mostly the same as it was when I wrote the logic in the setup function, with a few small updates.</p>\n<p>To make sure I don\u2019t get an error when I set the <code is:raw>elementWidth</code> to the imageRef/triggerElement <code is:raw>offsetHeight</code> value, I use an \u2018if\u2019 statement to make sure the <code is:raw>triggerElement</code> exists:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (triggerElement.value) {</span></span>\n<span class="line"><span style="color: #C9D1D9">  elementWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> triggerElement.value.offsetWidth</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I also set the initial text styles as soon as the component mounts and then run that <code is:raw>setTextStyles</code> function again inside the watch every time the <code is:raw>elementWidth</code> (the image\u2019s width) changes.</p>\n<p>Here is the full code for the <code is:raw>resizeText.js</code> composable:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref, watch, onMounted, onUnmounted } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useWindowEvent </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;./useWindowEvent&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useResize</span><span style="color: #FFA657">(triggerElement, reactElement) </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> elementWidth </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//handler to send into useWindowEvent</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">resizeHandler</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (triggerElement.value) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      elementWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> triggerElement.value.offsetWidth</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//set initial values for elementWidth and text styles</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">onMounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (triggerElement.value) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      elementWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> triggerElement.value.offsetWidth</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">setTextStyles</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//function to set text styles on mount and in watcher</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">setTextStyles</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (elementWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;.8em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (elementWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> elementWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.4&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (elementWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.5&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//add and destroy event listeners</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler, </span><span style="color: #A5D6FF">&#39;add&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">onUnmounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler, </span><span style="color: #A5D6FF">&#39;destroy&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//watch elementWidth and set text styles</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(elementWidth, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">setTextStyles</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { elementWidth }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>This <a href="https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-first-refactor/src">refactoring</a> makes <code is:raw>Mast.vue</code> much easier to read because the logic for resizing the text and for adding a window event listener are separated out into composables.</p>\n<p>However, my ultimate goal is to make composables that are more reusable in general. There is more I can do to make the <code is:raw>resizeText</code> composable reusable in other projects.</p>\n<p>For example, I could set it up to take a breakpoints object, so that I don\u2019t have to always use the same hardcoded width sizes to influence the text.</p>\n<p>I could also rework it accept a styles object for the text styles so that I\u2019m not required to use the same hardcoded values for text styles for any component that uses the composable. Something like this in the component:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//constants</span></span>\n<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">breakPoints</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { small: </span><span style="color: #A5D6FF">&#39;100&#39;</span><span style="color: #C9D1D9">, medium: </span><span style="color: #A5D6FF">&#39;150&#39;</span><span style="color: #C9D1D9">, large: </span><span style="color: #A5D6FF">&#39;200&#39;</span><span style="color: #C9D1D9"> }</span></span>\n<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">textStyles</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  fontSize: { small: </span><span style="color: #A5D6FF">&#39;.8em&#39;</span><span style="color: #C9D1D9">, medium: </span><span style="color: #A5D6FF">&#39;1em&#39;</span><span style="color: #C9D1D9">, large: </span><span style="color: #A5D6FF">&#39;1.3em&#39;</span><span style="color: #C9D1D9"> },</span></span>\n<span class="line"><span style="color: #C9D1D9">  lineHeight: { small: </span><span style="color: #A5D6FF">&#39;1.3&#39;</span><span style="color: #C9D1D9">, medium: </span><span style="color: #A5D6FF">&#39;1.4&#39;</span><span style="color: #C9D1D9">, large: </span><span style="color: #A5D6FF">&#39;1.5&#39;</span><span style="color: #C9D1D9"> },</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Here is the <a href="https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-second-refactor/src">full example</a>.</p>\n<p>There are still many ways to improve this composable to make it more agnostic, but this gives a general idea of the process that goes into making a composable more reusable.</p>\n<h2 id="conclusion">Conclusion</h2>\n<p>This concludes my series on Diving into Vue 3. I have learned the fundamentals that will allow me to jump into building projects using the Composition API. I feel so much more confident in Vue 3 now, and I\u2019m also really excited about it.</p>\n<p>I hope you have enjoyed this series. There is always more to learn, so stay tuned for future posts about Vue topics.</p>\n<p>Questions? Comments? Just want to say hi? You can find me on <a href="https://twitter.com/sandra_rodgers_">Twitter</a>!</p>' };
const frontmatter = { "title": "Diving Into Vue 3 - Reusability with Composables", "description": "Put everything together that we've learned in the series, and then refactor it all to use composables.", "date": "2022-02-25T00:00:00.000Z", "cover": "https://res.cloudinary.com/deepgram/image/upload/v1645127714/blog/2022/02/diving-into-vue-3-reusability-with-composables/dive-into-vue-3%402x.jpg", "authors": ["sandra-rodgers"], "category": "tutorial", "tags": ["vuejs", "javascript"], "seo": { "title": "Diving Into Vue 3 - Reusability with Composables", "description": "Put everything together that we've learned in the series, and then refactor it all to use composables." }, "shorturls": { "share": "https://dpgr.am/d629f17", "twitter": "https://dpgr.am/89aab6c", "linkedin": "https://dpgr.am/4f3ec42", "reddit": "https://dpgr.am/aa1b88d", "facebook": "https://dpgr.am/cc7baa5" }, "og": { "image": "https://res.cloudinary.com/deepgram/image/upload/v1661453993/blog/diving-into-vue-3-reusability-with-composables/ograph.png" }, "astro": { "headings": [{ "depth": 2, "slug": "introduction", "text": "Introduction" }, { "depth": 2, "slug": "example-component", "text": "Example Component" }, { "depth": 3, "slug": "vue-2", "text": "Vue 2" }, { "depth": 3, "slug": "vue-3", "text": "Vue 3" }, { "depth": 4, "slug": "template-refs", "text": "Template Refs" }, { "depth": 4, "slug": "lifecycle-hooks", "text": "Lifecycle Hooks" }, { "depth": 4, "slug": "watch", "text": "watch" }, { "depth": 2, "slug": "reusability-in-the-composition-api", "text": "Reusability in The Composition API" }, { "depth": 2, "slug": "composables", "text": "Composables" }, { "depth": 3, "slug": "usewindowevent", "text": "useWindowEvent" }, { "depth": 3, "slug": "useresizetext", "text": "useResizeText" }, { "depth": 2, "slug": "conclusion", "text": "Conclusion" }], "source": "\n## Introduction\n\nThis is the fifth and final post of my 'Diving Into Vue 3' series. Today I will combine what I have learned so far with a demonstration of how to use the Composition API to take advantage of its biggest strength: writing reusable code. This post will:\n\n*   review everything I've learned so far by walking through how I build an **example component**, focusing on challenges of working with the DOM and using lifecycle methods.\n*   introduce how to use a **template ref** to keep track of an element in the DOM.\n*   demonstrate how to refactor the project to use **composition functions** (i.e. **composables**).\n\nDon't forget there are four previous posts in this series that might be useful to you:\n\n*   [Diving Into Vue 3 - Getting Started](https://blog.deepgram.com/diving-into-vue-3-getting-started/)\n*   [Diving Into Vue 3 - The Setup Function](https://blog.deepgram.com/diving-into-vue-3-setup-function/)\n*   [Diving Into Vue 3: Methods, Watch, and Computed](https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/)\n*   [Diving Into Vue 3: The Reactivity API](https://blog.deepgram.com/diving-into-vue-3-reactivity-api/)\n\nIf you don't need the walk-through for building the example project, feel free to jump to the section on [reusability](#reusability-in-the-composition-api), where I show how to refactor the project to use composables.\n\n## Example Component\n\nI am going to build a single-file component that has a mast with an image on the left and text on the right. The problem I need to address is that I want to change the size of the text based on the image being resized.\n\nHere's the demo:\n\n![Rendered component to that uses method to increment and decrement](https://res.cloudinary.com/deepgram/image/upload/v1645128984/blog/2022/02/diving-into-vue-3-reusability-with-composables/demo.gif)\n\nTo achieve this, I will:\n\n*   listen for resizing of the window with an event listener.\n*   track the image size.\n*   update the text size if the image gets to a certain size.\n\nThe repo to go along with this example can be found [here](https://github.com/deepgram-devs/vue-reusability-with-composables/tree/main/src). There are several branches to show the progression of how the project gets refactored.\n\n### Vue 2\n\nI won't go over how I built the project in Vue 2, but if it helps, the completed project in Vue 2 can be viewed [here](https://stackblitz.com/edit/vue2-vue-cli-vnp6kn?file=src/components/Mast.vue).\n\nResizing the window will show how the text size changes as the width of the image changes.\n\n### Vue 3\n\nHere's how to build the component in Vue 3. The html in the `template` is exactly the same as the Vue 2 project:\n\n```html\n<template>\n  <div class=\"mast\">\n    <div class=\"container\">\n      <div class=\"image-container\">\n        <img ref=\"imageRef\" src=\"../assets/meatball.jpeg\" />\n      </div>\n      <div ref=\"textRef\" class=\"text-container\">\n        <p>\n          Meatball, 9. Barks at Amazon guy. Likes sharing your apple slices.\n          Wants you to grab the toy but won't let you have it.\n        </p>\n      </div>\n    </div>\n  </div>\n</template>\n```\n\nIn the script section, I'll need to add the `setup` function, and then I will define the variables for the data I'll be tracking. Since elements in the DOM will depend on each other to either trigger a change or react to a change, I will need to make them reactive using `ref` so everything stays in sync. Here's how I do that:\n\n```js\n<script>\nimport { ref } from \"vue\";\nexport default {\n  name: \"Mast\",\n  setup() {\n    let imageWidth = ref(0);\n\n    //template refs\n    let imageRef = ref(null);\n    let textRef = ref(null);\n\n    return { imageRef, textRef };\n  },\n};\n<\/script>\n```\n\nThe important data to keep track of is the `imageWidth` because that value is what I will use to determine if the text size should change.\n\nThe `imageWidth` value has to come from the image element in the DOM. It will be based on the actual size of the image at a point in time, so I will need to connect to the actual DOM element using a [template ref](https://vuejs.org/guide/essentials/template-refs.html).\n\n#### Template Refs\n\nI think of template refs as the Vue way of using Javascript to hook into a DOM element, such as the method `document.getElementById()` or `document.querySelector()`.\n\nIn Vue 2, the way to do that is to add `ref=\"nameOfRef\"` as an attribute on the element that I am targeting, then in the script, I could perform some action on it using `this.$refs.nameOfRef`.\n\nIn Vue 3, template refs are now part of the reactive API. If I want to set up a template ref, I still need to add `ref=\"nameOfRef\"` as an attribute on the element that I want to hook into.\n\n```html\n<img ref=\"imageRef\" src=\"../assets/meatball.jpeg\" />\n```\n\nThe difference now is that in the script, I need to define the template ref as a reactive reference variable wrapped in `ref`. And I MUST return it in the `return` object of the `setup` function so that it connects to that DOM element in the template. If I don't, it won't work.\n\n```js\nsetup() {\n    //template refs\n    let imageRef = ref(null);\n    let textRef = ref(null);\n\n    return { imageRef, textRef };\n  },\n```\n\nAlso, I need to be aware that I won't be able to actually access the ref to do something with it until the component has mounted - which brings me to the next topic.\n\n#### Lifecycle Hooks\n\nNow that I have the data set up I can add the logic to listen for the resize event.\n\nI want to track the size of the image, which will change depending on if the window is resized. Since I'm dealing with a visual element, I need to consider timing of when that element will appear in the browser. It won't appear until the component has mounted.\n\nThe hooks that I'll need for setting up the event listener (and destroying it) are `onMounted` and `onUnmounted`, which are the equivalent to `mounted` and `unmounted` in Vue 2.\n\nIn `onMounted`, I have access to the template ref, so I will first set the initial value of the `imageWidth` based on the width of the actual image, which I pull from the template ref. I will also put a listener on the window to track the resizing event so that as the window is resized, the `resizeHandler` function runs.\n\nEverything currently resides in the setup function for now, but will be refactored later and moved into composables:\n\n```js\n// inside setup function:\n\nonMounted(() => {\n  //set initial value\n  imageWidth.value = imageRef.value.offsetWidth\n\n  //add listener to track resize\n  window.addEventListener('resize', resizeHandler)\n})\n```\n\nThe `resizeHandler` sets the `imageWidth` value to the `imageRef`'s width. I have to remember that with refs in the script, I have to unwrap the value using `.value`:\n\n```js\n// inside setup function:\n\nfunction resizeHandler() {\n  //tracking of width changes\n  imageWidth.value = imageRef.value.offsetWidth\n}\n```\n\nSince I'm listening for the resize event starting when the component mounts, I need to be sure to destroy the listener when the component unmounts:\n\n```js\n// inside setup function:\n\nonUnmounted(() => {\n  //remove listener\n  window.removeEventListener('resize', resizeHandler)\n})\n```\n\n#### watch\n\nI now have the data set up so that the `imageWidth` updates in-sync with the `imageRef`'s width as the event listener fires the `resizeHandler` function.\n\nThe last thing I need to do is make something happen as a side effect of the `imageWidth` increasing or decreasing. Vue offers `watch` and `watchEffect` as part of the API for watching a reactive property and causing a side effect to occur based on changes to the property.\n\nIn this case, I will use `watch` because I only need to track the `imageWidth` value since a change to `imageWidth` is what I'm using to cause the text size to change.\n\n```js\n// inside setup function:\n\nwatch(imageWidth, () => {\n  //initiate side effects to change text size when window width changes\n  if (imageWidth.value < 150) {\n    textRef.value.style.fontSize = '.8em'\n    textRef.value.style.lineHeight = '1.3'\n  }\n  if (imageWidth.value < 200 && imageWidth.value > 150) {\n    textRef.value.style.fontSize = '1em'\n    textRef.value.style.lineHeight = '1.4'\n  }\n  if (imageWidth.value > 200) {\n    textRef.value.style.fontSize = '1.3em'\n    textRef.value.style.lineHeight = '1.5'\n  }\n})\n```\n\nHere is the finished [example code](https://github.com/SandraRodgers/vue-reusability-with-composables/tree/no-composables/src) using Vue 3 (and before I refactor it to use composables). Now that everything is working, I will refactor my code to make it more reusable.\n\n## Reusability in The Composition API\n\nMany people would say that the biggest advantage of using Vue 3's Composition API is its emphasis on organizing code by logical concern rather than by option types like in Vue 2. If I'm building a small application that is only going to have minimal logic in a component, the Options API, or even just putting all my logic in the setup function, is fine. But as a component grows larger, it can be challenging to follow the data flow.\n\nFor example, a UI component such as a dropdown menu has to deal with opening and closing the dropdown, keyboard interactions, pulling in data to populate the menu, and more. All that logic in one component spread out among the options like `methods`, `watch`, `mounted`, etc., can be hard to decipher.\n\nVue 2 does offer approaches for separating out logic, such as **mixins** and **utility functions**. But Vue 3's whole philosophy is designed around the idea of writing code that is reusable, focused around logical concern, and easy to read. The most fundamental way it does this is through **composition functions** (i.e. **composables**).\n\n## Composables\n\nThe advantage of organizing code by logical concern encapsulated in a composable function is that it becomes easier to read, but it also becomes easier to reuse in other parts of the project or even in other projects.\n\nI feel that the ultimate goal should be to write the most agnostic code possible in a composable, i.e. code that can be recycled in different contexts and isn't so dependent on the one unique context it starts out in.\n\nIt does take time and practice to get better at this skill, but the good news is, Vue 3 is the perfect framework to work at it because using the Composition API really emphasizes this approach to coding.\n\nWith that in mind, I'll think about how I can refactor my project to take advantage of composables.\n\n### useWindowEvent\n\nA common situation is having to listen for an event on the window, such as a resize event. I see an opportunity to write a composable that can be reused when I want to add or destroy an event listener on the window.\n\nIn my project, in the `onMounted` hook I currently have:\n\n```js\nwindow.addEventListener('resize', resizeHandler)\n```\n\nAnd in the `unMounted` hook:\n\n```js\nwindow.removeEventListener('resize', resizeHandler)\n```\n\nI can create a composable function that accepts an event-type, a handler, and a string saying 'add' or 'destroy', and write logic that will set up the window event listener. I will put this file in a folder called `~/composables`. The Vue 3 convention is to name composable files with the prefix 'use' as in *useWindowEvent*.\n\nHere is the composable `useWindowEvent.js`:\n\n```js\nexport default function useWindowEvent(event, handler, addOrDestroy) {\n  if (addOrDestroy === 'add') {\n    window.addEventListener(event, handler)\n  }\n\n  if (addOrDestroy === 'destroy') {\n    window.removeEventListener(event, handler)\n  }\n}\n```\n\nNow in my project, I import it into the component where it will be used:\n\n```js\nimport useWindowEvent from '../composables/useWindowEvent'\n```\n\nThen I invoke the function with the arguments that I set it up to receive:\n\n```js\nuseWindowEvent('resize', resizeHandler, 'add')\n```\n\nThis is just a small composable, and it doesn't really make my life that much easier since I didn't have to write very much code anyways to set up the listener on the window.\n\nBut there is a significant advantage to creating reusable code. I know the composable is written to work, so I'm less likely to have little errors or typos since I'm reusing code that has been tested and used before. Because I've tested it, I can feel confident reusing it in many contexts.\n\nConsistency is another benefit. I keep functionality consistent by using the composable in multiple places, rather than having to reinvent the wheel every time, potentially introducing differences (and problems).\n\nAnd now that I have created a `useWindowEvent`, I could try to make it to work for all kinds of elements, not just the window. If I spend some time improving it so that it can add an event listener to any type of element, then I have a really useful composable that I can reuse.\n\n### useResizeText\n\nThe main feature of my project is that the text resizes based on the image element's width. I can turn this into a composable that can be reused in cases where I want text to resize based on some other element.\n\nIn my goal to write it in a way that is more agnostic, I can think of the element that is watched (the image) as the *trigger element*, and the element that changes (the text) as the *react element*. In the `resizeText` composable, I'll refer to them as the `triggerElement` and the `reactElement`, but in the `Mast.vue` component they are the `imageRef` and the `textRef`. These are more specific references to the context of my project, while `triggerElement` and `reactElement` are more general since I would like the composable to be reused if I ever need it in a different project.\n\nI create the composable file called `useResizeText.js`. I anticipate that I'll need to accept two arguments, the `triggerElement` and the `reactElement` (which come in from `Mast.vue` as the `imageRef` and the `textRef`):\n\n```js\n//useResizeText.js:\n\nexport default function useResizeText(triggerElement, reactElement) {\n  return { elementWidth }\n}\n```\n\nI've included the return object because any data from the composable that I want to make available in the component (or another file) must be included in it. I'll return the `elementWidth` to the component so I can put it in my template in `Mast.vue` and see the resize logic working in real-time.\n\nIn the `Mast.vue` component, I will call the composable. I have to send in the template refs so the composable can compute the text size based on those DOM elements. I will destructure the composable so that I get the returned `elementWidth`.\n\nInside `setup` in `Mast.vue`:\n\n```js\n//destructure to get data sent back from the composable\n//get updated width for template\nconst { elementWidth } = useResizeText(imageRef, textRef)\n```\n\nI will return `elementWidth` to the template so that I see that number reacting to the window resizing. I also return `imageRef` and `textRef` because that is required for the template refs to stay in-sync between the script and the template.\n\nHere is everything in the `setup` function:\n\n```js\nsetup() {\n    //template refs\n    let imageRef = ref(null);\n    let textRef = ref(null);\n    //destructure to get data sent back from the composable\n    //get updated width for template\n    const { elementWidth } = useResizeText(imageRef, textRef);\n    return { imageRef, textRef, elementWidth };\n  },\n\n```\n\nThe composable itself is mostly the same as it was when I wrote the logic in the setup function, with a few small updates.\n\nTo make sure I don't get an error when I set the `elementWidth` to the imageRef/triggerElement `offsetHeight` value, I use an 'if' statement to make sure the `triggerElement` exists:\n\n```js\nif (triggerElement.value) {\n  elementWidth.value = triggerElement.value.offsetWidth\n}\n```\n\nI also set the initial text styles as soon as the component mounts and then run that `setTextStyles` function again inside the watch every time the `elementWidth` (the image's width) changes.\n\nHere is the full code for the `resizeText.js` composable:\n\n```js\nimport { ref, watch, onMounted, onUnmounted } from 'vue'\nimport useWindowEvent from './useWindowEvent'\n\nexport default function useResize(triggerElement, reactElement) {\n  let elementWidth = ref(0)\n\n  //handler to send into useWindowEvent\n  function resizeHandler() {\n    if (triggerElement.value) {\n      elementWidth.value = triggerElement.value.offsetWidth\n    }\n  }\n\n  //set initial values for elementWidth and text styles\n  onMounted(() => {\n    if (triggerElement.value) {\n      elementWidth.value = triggerElement.value.offsetWidth\n      setTextStyles()\n    }\n  })\n\n  //function to set text styles on mount and in watcher\n  function setTextStyles() {\n    if (elementWidth.value < 150) {\n      reactElement.value.style.fontSize = '.8em'\n      reactElement.value.style.lineHeight = '1.3'\n    }\n    if (elementWidth.value < 200 && elementWidth.value > 150) {\n      reactElement.value.style.fontSize = '1em'\n      reactElement.value.style.lineHeight = '1.4'\n    }\n    if (elementWidth.value > 200) {\n      reactElement.value.style.fontSize = '1.3em'\n      reactElement.value.style.lineHeight = '1.5'\n    }\n  }\n\n  //add and destroy event listeners\n  useWindowEvent('resize', resizeHandler, 'add')\n  onUnmounted(() => {\n    useWindowEvent('resize', resizeHandler, 'destroy')\n  })\n\n  //watch elementWidth and set text styles\n  watch(elementWidth, () => {\n    setTextStyles()\n  })\n\n  return { elementWidth }\n}\n```\n\nThis [refactoring](https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-first-refactor/src) makes `Mast.vue` much easier to read because the logic for resizing the text and for adding a window event listener are separated out into composables.\n\nHowever, my ultimate goal is to make composables that are more reusable in general. There is more I can do to make the `resizeText` composable reusable in other projects.\n\nFor example, I could set it up to take a breakpoints object, so that I don't have to always use the same hardcoded width sizes to influence the text.\n\nI could also rework it accept a styles object for the text styles so that I'm not required to use the same hardcoded values for text styles for any component that uses the composable. Something like this in the component:\n\n```js\n//constants\nconst breakPoints = { small: '100', medium: '150', large: '200' }\nconst textStyles = {\n  fontSize: { small: '.8em', medium: '1em', large: '1.3em' },\n  lineHeight: { small: '1.3', medium: '1.4', large: '1.5' },\n}\n```\n\nHere is the [full example](https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-second-refactor/src).\n\nThere are still many ways to improve this composable to make it more agnostic, but this gives a general idea of the process that goes into making a composable more reusable.\n\n## Conclusion\n\nThis concludes my series on Diving into Vue 3. I have learned the fundamentals that will allow me to jump into building projects using the Composition API. I feel so much more confident in Vue 3 now, and I'm also really excited about it.\n\nI hope you have enjoyed this series. There is always more to learn, so stay tuned for future posts about Vue topics.\n\nQuestions? Comments? Just want to say hi? You can find me on [Twitter](https://twitter.com/sandra_rodgers_)!\n\n        ", "html": '<h2 id="introduction">Introduction</h2>\n<p>This is the fifth and final post of my \u2018Diving Into Vue 3\u2019 series. Today I will combine what I have learned so far with a demonstration of how to use the Composition API to take advantage of its biggest strength: writing reusable code. This post will:</p>\n<ul>\n<li>review everything I\u2019ve learned so far by walking through how I build an <strong>example component</strong>, focusing on challenges of working with the DOM and using lifecycle methods.</li>\n<li>introduce how to use a <strong>template ref</strong> to keep track of an element in the DOM.</li>\n<li>demonstrate how to refactor the project to use <strong>composition functions</strong> (i.e. <strong>composables</strong>).</li>\n</ul>\n<p>Don\u2019t forget there are four previous posts in this series that might be useful to you:</p>\n<ul>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3 - Getting Started</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-setup-function/">Diving Into Vue 3 - The Setup Function</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/">Diving Into Vue 3: Methods, Watch, and Computed</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-reactivity-api/">Diving Into Vue 3: The Reactivity API</a></li>\n</ul>\n<p>If you don\u2019t need the walk-through for building the example project, feel free to jump to the section on <a href="#reusability-in-the-composition-api">reusability</a>, where I show how to refactor the project to use composables.</p>\n<h2 id="example-component">Example Component</h2>\n<p>I am going to build a single-file component that has a mast with an image on the left and text on the right. The problem I need to address is that I want to change the size of the text based on the image being resized.</p>\n<p>Here\u2019s the demo:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1645128984/blog/2022/02/diving-into-vue-3-reusability-with-composables/demo.gif" alt="Rendered component to that uses method to increment and decrement"></p>\n<p>To achieve this, I will:</p>\n<ul>\n<li>listen for resizing of the window with an event listener.</li>\n<li>track the image size.</li>\n<li>update the text size if the image gets to a certain size.</li>\n</ul>\n<p>The repo to go along with this example can be found <a href="https://github.com/deepgram-devs/vue-reusability-with-composables/tree/main/src">here</a>. There are several branches to show the progression of how the project gets refactored.</p>\n<h3 id="vue-2">Vue 2</h3>\n<p>I won\u2019t go over how I built the project in Vue 2, but if it helps, the completed project in Vue 2 can be viewed <a href="https://stackblitz.com/edit/vue2-vue-cli-vnp6kn?file=src/components/Mast.vue">here</a>.</p>\n<p>Resizing the window will show how the text size changes as the width of the image changes.</p>\n<h3 id="vue-3">Vue 3</h3>\n<p>Here\u2019s how to build the component in Vue 3. The html in the <code is:raw>template</code> is exactly the same as the Vue 2 project:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;mast&quot;</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;container&quot;</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">      &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;image-container&quot;</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">        &lt;</span><span style="color: #7EE787">img</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">ref</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;imageRef&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">src</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;../assets/meatball.jpeg&quot;</span><span style="color: #C9D1D9"> /&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">      &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">      &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">ref</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;textRef&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;text-container&quot;</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">        &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">          Meatball, 9. Barks at Amazon guy. Likes sharing your apple slices.</span></span>\n<span class="line"><span style="color: #C9D1D9">          Wants you to grab the toy but won&#39;t let you have it.</span></span>\n<span class="line"><span style="color: #C9D1D9">        &lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">      &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>In the script section, I\u2019ll need to add the <code is:raw>setup</code> function, and then I will define the variables for the data I\u2019ll be tracking. Since elements in the DOM will depend on each other to either trigger a change or react to a change, I will need to make them reactive using <code is:raw>ref</code> so everything stays in sync. Here\u2019s how I do that:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  name: </span><span style="color: #A5D6FF">&quot;Mast&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let imageWidth </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//template refs</span></span>\n<span class="line"><span style="color: #C9D1D9">    let imageRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    let textRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { imageRef, textRef };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>The important data to keep track of is the <code is:raw>imageWidth</code> because that value is what I will use to determine if the text size should change.</p>\n<p>The <code is:raw>imageWidth</code> value has to come from the image element in the DOM. It will be based on the actual size of the image at a point in time, so I will need to connect to the actual DOM element using a <a href="https://vuejs.org/guide/essentials/template-refs.html">template ref</a>.</p>\n<h4 id="template-refs">Template Refs</h4>\n<p>I think of template refs as the Vue way of using Javascript to hook into a DOM element, such as the method <code is:raw>document.getElementById()</code> or <code is:raw>document.querySelector()</code>.</p>\n<p>In Vue 2, the way to do that is to add <code is:raw>ref="nameOfRef"</code> as an attribute on the element that I am targeting, then in the script, I could perform some action on it using <code is:raw>this.$refs.nameOfRef</code>.</p>\n<p>In Vue 3, template refs are now part of the reactive API. If I want to set up a template ref, I still need to add <code is:raw>ref="nameOfRef"</code> as an attribute on the element that I want to hook into.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">img</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">ref</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;imageRef&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">src</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;../assets/meatball.jpeg&quot;</span><span style="color: #C9D1D9"> /&gt;</span></span></code></pre>\n<p>The difference now is that in the script, I need to define the template ref as a reactive reference variable wrapped in <code is:raw>ref</code>. And I MUST return it in the <code is:raw>return</code> object of the <code is:raw>setup</code> function so that it connects to that DOM element in the template. If I don\u2019t, it won\u2019t work.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//template refs</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> imageRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> textRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { imageRef, textRef };</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span></code></pre>\n<p>Also, I need to be aware that I won\u2019t be able to actually access the ref to do something with it until the component has mounted - which brings me to the next topic.</p>\n<h4 id="lifecycle-hooks">Lifecycle Hooks</h4>\n<p>Now that I have the data set up I can add the logic to listen for the resize event.</p>\n<p>I want to track the size of the image, which will change depending on if the window is resized. Since I\u2019m dealing with a visual element, I need to consider timing of when that element will appear in the browser. It won\u2019t appear until the component has mounted.</p>\n<p>The hooks that I\u2019ll need for setting up the event listener (and destroying it) are <code is:raw>onMounted</code> and <code is:raw>onUnmounted</code>, which are the equivalent to <code is:raw>mounted</code> and <code is:raw>unmounted</code> in Vue 2.</p>\n<p>In <code is:raw>onMounted</code>, I have access to the template ref, so I will first set the initial value of the <code is:raw>imageWidth</code> based on the width of the actual image, which I pull from the template ref. I will also put a listener on the window to track the resizing event so that as the window is resized, the <code is:raw>resizeHandler</code> function runs.</p>\n<p>Everything currently resides in the setup function for now, but will be refactored later and moved into composables:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #D2A8FF">onMounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//set initial value</span></span>\n<span class="line"><span style="color: #C9D1D9">  imageWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> imageRef.value.offsetWidth</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//add listener to track resize</span></span>\n<span class="line"><span style="color: #C9D1D9">  window.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>The <code is:raw>resizeHandler</code> sets the <code is:raw>imageWidth</code> value to the <code is:raw>imageRef</code>\u2019s width. I have to remember that with refs in the script, I have to unwrap the value using <code is:raw>.value</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">resizeHandler</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//tracking of width changes</span></span>\n<span class="line"><span style="color: #C9D1D9">  imageWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> imageRef.value.offsetWidth</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Since I\u2019m listening for the resize event starting when the component mounts, I need to be sure to destroy the listener when the component unmounts:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #D2A8FF">onUnmounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//remove listener</span></span>\n<span class="line"><span style="color: #C9D1D9">  window.</span><span style="color: #D2A8FF">removeEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<h4 id="watch">watch</h4>\n<p>I now have the data set up so that the <code is:raw>imageWidth</code> updates in-sync with the <code is:raw>imageRef</code>\u2019s width as the event listener fires the <code is:raw>resizeHandler</code> function.</p>\n<p>The last thing I need to do is make something happen as a side effect of the <code is:raw>imageWidth</code> increasing or decreasing. Vue offers <code is:raw>watch</code> and <code is:raw>watchEffect</code> as part of the API for watching a reactive property and causing a side effect to occur based on changes to the property.</p>\n<p>In this case, I will use <code is:raw>watch</code> because I only need to track the <code is:raw>imageWidth</code> value since a change to <code is:raw>imageWidth</code> is what I\u2019m using to cause the text size to change.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(imageWidth, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//initiate side effects to change text size when window width changes</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (imageWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;.8em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (imageWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> imageWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.4&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (imageWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.5&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>Here is the finished <a href="https://github.com/SandraRodgers/vue-reusability-with-composables/tree/no-composables/src">example code</a> using Vue 3 (and before I refactor it to use composables). Now that everything is working, I will refactor my code to make it more reusable.</p>\n<h2 id="reusability-in-the-composition-api">Reusability in The Composition API</h2>\n<p>Many people would say that the biggest advantage of using Vue 3\u2019s Composition API is its emphasis on organizing code by logical concern rather than by option types like in Vue 2. If I\u2019m building a small application that is only going to have minimal logic in a component, the Options API, or even just putting all my logic in the setup function, is fine. But as a component grows larger, it can be challenging to follow the data flow.</p>\n<p>For example, a UI component such as a dropdown menu has to deal with opening and closing the dropdown, keyboard interactions, pulling in data to populate the menu, and more. All that logic in one component spread out among the options like <code is:raw>methods</code>, <code is:raw>watch</code>, <code is:raw>mounted</code>, etc., can be hard to decipher.</p>\n<p>Vue 2 does offer approaches for separating out logic, such as <strong>mixins</strong> and <strong>utility functions</strong>. But Vue 3\u2019s whole philosophy is designed around the idea of writing code that is reusable, focused around logical concern, and easy to read. The most fundamental way it does this is through <strong>composition functions</strong> (i.e. <strong>composables</strong>).</p>\n<h2 id="composables">Composables</h2>\n<p>The advantage of organizing code by logical concern encapsulated in a composable function is that it becomes easier to read, but it also becomes easier to reuse in other parts of the project or even in other projects.</p>\n<p>I feel that the ultimate goal should be to write the most agnostic code possible in a composable, i.e. code that can be recycled in different contexts and isn\u2019t so dependent on the one unique context it starts out in.</p>\n<p>It does take time and practice to get better at this skill, but the good news is, Vue 3 is the perfect framework to work at it because using the Composition API really emphasizes this approach to coding.</p>\n<p>With that in mind, I\u2019ll think about how I can refactor my project to take advantage of composables.</p>\n<h3 id="usewindowevent">useWindowEvent</h3>\n<p>A common situation is having to listen for an event on the window, such as a resize event. I see an opportunity to write a composable that can be reused when I want to add or destroy an event listener on the window.</p>\n<p>In my project, in the <code is:raw>onMounted</code> hook I currently have:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">window.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span></code></pre>\n<p>And in the <code is:raw>unMounted</code> hook:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">window.</span><span style="color: #D2A8FF">removeEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span></code></pre>\n<p>I can create a composable function that accepts an event-type, a handler, and a string saying \u2018add\u2019 or \u2018destroy\u2019, and write logic that will set up the window event listener. I will put this file in a folder called <code is:raw>~/composables</code>. The Vue 3 convention is to name composable files with the prefix \u2018use\u2019 as in <em>useWindowEvent</em>.</p>\n<p>Here is the composable <code is:raw>useWindowEvent.js</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #FFA657">(event, handler, addOrDestroy) </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (addOrDestroy </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;add&#39;</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    window.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(event, handler)</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (addOrDestroy </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;destroy&#39;</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    window.</span><span style="color: #D2A8FF">removeEventListener</span><span style="color: #C9D1D9">(event, handler)</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now in my project, I import it into the component where it will be used:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useWindowEvent </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../composables/useWindowEvent&#39;</span></span></code></pre>\n<p>Then I invoke the function with the arguments that I set it up to receive:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler, </span><span style="color: #A5D6FF">&#39;add&#39;</span><span style="color: #C9D1D9">)</span></span></code></pre>\n<p>This is just a small composable, and it doesn\u2019t really make my life that much easier since I didn\u2019t have to write very much code anyways to set up the listener on the window.</p>\n<p>But there is a significant advantage to creating reusable code. I know the composable is written to work, so I\u2019m less likely to have little errors or typos since I\u2019m reusing code that has been tested and used before. Because I\u2019ve tested it, I can feel confident reusing it in many contexts.</p>\n<p>Consistency is another benefit. I keep functionality consistent by using the composable in multiple places, rather than having to reinvent the wheel every time, potentially introducing differences (and problems).</p>\n<p>And now that I have created a <code is:raw>useWindowEvent</code>, I could try to make it to work for all kinds of elements, not just the window. If I spend some time improving it so that it can add an event listener to any type of element, then I have a really useful composable that I can reuse.</p>\n<h3 id="useresizetext">useResizeText</h3>\n<p>The main feature of my project is that the text resizes based on the image element\u2019s width. I can turn this into a composable that can be reused in cases where I want text to resize based on some other element.</p>\n<p>In my goal to write it in a way that is more agnostic, I can think of the element that is watched (the image) as the <em>trigger element</em>, and the element that changes (the text) as the <em>react element</em>. In the <code is:raw>resizeText</code> composable, I\u2019ll refer to them as the <code is:raw>triggerElement</code> and the <code is:raw>reactElement</code>, but in the <code is:raw>Mast.vue</code> component they are the <code is:raw>imageRef</code> and the <code is:raw>textRef</code>. These are more specific references to the context of my project, while <code is:raw>triggerElement</code> and <code is:raw>reactElement</code> are more general since I would like the composable to be reused if I ever need it in a different project.</p>\n<p>I create the composable file called <code is:raw>useResizeText.js</code>. I anticipate that I\u2019ll need to accept two arguments, the <code is:raw>triggerElement</code> and the <code is:raw>reactElement</code> (which come in from <code is:raw>Mast.vue</code> as the <code is:raw>imageRef</code> and the <code is:raw>textRef</code>):</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//useResizeText.js:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useResizeText</span><span style="color: #FFA657">(triggerElement, reactElement) </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { elementWidth }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I\u2019ve included the return object because any data from the composable that I want to make available in the component (or another file) must be included in it. I\u2019ll return the <code is:raw>elementWidth</code> to the component so I can put it in my template in <code is:raw>Mast.vue</code> and see the resize logic working in real-time.</p>\n<p>In the <code is:raw>Mast.vue</code> component, I will call the composable. I have to send in the template refs so the composable can compute the text size based on those DOM elements. I will destructure the composable so that I get the returned <code is:raw>elementWidth</code>.</p>\n<p>Inside <code is:raw>setup</code> in <code is:raw>Mast.vue</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//destructure to get data sent back from the composable</span></span>\n<span class="line"><span style="color: #8B949E">//get updated width for template</span></span>\n<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">elementWidth</span><span style="color: #C9D1D9"> } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useResizeText</span><span style="color: #C9D1D9">(imageRef, textRef)</span></span></code></pre>\n<p>I will return <code is:raw>elementWidth</code> to the template so that I see that number reacting to the window resizing. I also return <code is:raw>imageRef</code> and <code is:raw>textRef</code> because that is required for the template refs to stay in-sync between the script and the template.</p>\n<p>Here is everything in the <code is:raw>setup</code> function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//template refs</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> imageRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> textRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//destructure to get data sent back from the composable</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//get updated width for template</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">elementWidth</span><span style="color: #C9D1D9"> } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useResizeText</span><span style="color: #C9D1D9">(imageRef, textRef);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { imageRef, textRef, elementWidth };</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span>\n<span class="line"></span></code></pre>\n<p>The composable itself is mostly the same as it was when I wrote the logic in the setup function, with a few small updates.</p>\n<p>To make sure I don\u2019t get an error when I set the <code is:raw>elementWidth</code> to the imageRef/triggerElement <code is:raw>offsetHeight</code> value, I use an \u2018if\u2019 statement to make sure the <code is:raw>triggerElement</code> exists:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (triggerElement.value) {</span></span>\n<span class="line"><span style="color: #C9D1D9">  elementWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> triggerElement.value.offsetWidth</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I also set the initial text styles as soon as the component mounts and then run that <code is:raw>setTextStyles</code> function again inside the watch every time the <code is:raw>elementWidth</code> (the image\u2019s width) changes.</p>\n<p>Here is the full code for the <code is:raw>resizeText.js</code> composable:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref, watch, onMounted, onUnmounted } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useWindowEvent </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;./useWindowEvent&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useResize</span><span style="color: #FFA657">(triggerElement, reactElement) </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> elementWidth </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//handler to send into useWindowEvent</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">resizeHandler</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (triggerElement.value) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      elementWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> triggerElement.value.offsetWidth</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//set initial values for elementWidth and text styles</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">onMounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (triggerElement.value) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      elementWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> triggerElement.value.offsetWidth</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">setTextStyles</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//function to set text styles on mount and in watcher</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">setTextStyles</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (elementWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;.8em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (elementWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> elementWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.4&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (elementWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.5&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//add and destroy event listeners</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler, </span><span style="color: #A5D6FF">&#39;add&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">onUnmounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler, </span><span style="color: #A5D6FF">&#39;destroy&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//watch elementWidth and set text styles</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(elementWidth, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">setTextStyles</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { elementWidth }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>This <a href="https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-first-refactor/src">refactoring</a> makes <code is:raw>Mast.vue</code> much easier to read because the logic for resizing the text and for adding a window event listener are separated out into composables.</p>\n<p>However, my ultimate goal is to make composables that are more reusable in general. There is more I can do to make the <code is:raw>resizeText</code> composable reusable in other projects.</p>\n<p>For example, I could set it up to take a breakpoints object, so that I don\u2019t have to always use the same hardcoded width sizes to influence the text.</p>\n<p>I could also rework it accept a styles object for the text styles so that I\u2019m not required to use the same hardcoded values for text styles for any component that uses the composable. Something like this in the component:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//constants</span></span>\n<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">breakPoints</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { small: </span><span style="color: #A5D6FF">&#39;100&#39;</span><span style="color: #C9D1D9">, medium: </span><span style="color: #A5D6FF">&#39;150&#39;</span><span style="color: #C9D1D9">, large: </span><span style="color: #A5D6FF">&#39;200&#39;</span><span style="color: #C9D1D9"> }</span></span>\n<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">textStyles</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  fontSize: { small: </span><span style="color: #A5D6FF">&#39;.8em&#39;</span><span style="color: #C9D1D9">, medium: </span><span style="color: #A5D6FF">&#39;1em&#39;</span><span style="color: #C9D1D9">, large: </span><span style="color: #A5D6FF">&#39;1.3em&#39;</span><span style="color: #C9D1D9"> },</span></span>\n<span class="line"><span style="color: #C9D1D9">  lineHeight: { small: </span><span style="color: #A5D6FF">&#39;1.3&#39;</span><span style="color: #C9D1D9">, medium: </span><span style="color: #A5D6FF">&#39;1.4&#39;</span><span style="color: #C9D1D9">, large: </span><span style="color: #A5D6FF">&#39;1.5&#39;</span><span style="color: #C9D1D9"> },</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Here is the <a href="https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-second-refactor/src">full example</a>.</p>\n<p>There are still many ways to improve this composable to make it more agnostic, but this gives a general idea of the process that goes into making a composable more reusable.</p>\n<h2 id="conclusion">Conclusion</h2>\n<p>This concludes my series on Diving into Vue 3. I have learned the fundamentals that will allow me to jump into building projects using the Composition API. I feel so much more confident in Vue 3 now, and I\u2019m also really excited about it.</p>\n<p>I hope you have enjoyed this series. There is always more to learn, so stay tuned for future posts about Vue topics.</p>\n<p>Questions? Comments? Just want to say hi? You can find me on <a href="https://twitter.com/sandra_rodgers_">Twitter</a>!</p>' }, "file": "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/diving-into-vue-3-reusability-with-composables/index.md" };
function rawContent() {
  return "\n## Introduction\n\nThis is the fifth and final post of my 'Diving Into Vue 3' series. Today I will combine what I have learned so far with a demonstration of how to use the Composition API to take advantage of its biggest strength: writing reusable code. This post will:\n\n*   review everything I've learned so far by walking through how I build an **example component**, focusing on challenges of working with the DOM and using lifecycle methods.\n*   introduce how to use a **template ref** to keep track of an element in the DOM.\n*   demonstrate how to refactor the project to use **composition functions** (i.e. **composables**).\n\nDon't forget there are four previous posts in this series that might be useful to you:\n\n*   [Diving Into Vue 3 - Getting Started](https://blog.deepgram.com/diving-into-vue-3-getting-started/)\n*   [Diving Into Vue 3 - The Setup Function](https://blog.deepgram.com/diving-into-vue-3-setup-function/)\n*   [Diving Into Vue 3: Methods, Watch, and Computed](https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/)\n*   [Diving Into Vue 3: The Reactivity API](https://blog.deepgram.com/diving-into-vue-3-reactivity-api/)\n\nIf you don't need the walk-through for building the example project, feel free to jump to the section on [reusability](#reusability-in-the-composition-api), where I show how to refactor the project to use composables.\n\n## Example Component\n\nI am going to build a single-file component that has a mast with an image on the left and text on the right. The problem I need to address is that I want to change the size of the text based on the image being resized.\n\nHere's the demo:\n\n![Rendered component to that uses method to increment and decrement](https://res.cloudinary.com/deepgram/image/upload/v1645128984/blog/2022/02/diving-into-vue-3-reusability-with-composables/demo.gif)\n\nTo achieve this, I will:\n\n*   listen for resizing of the window with an event listener.\n*   track the image size.\n*   update the text size if the image gets to a certain size.\n\nThe repo to go along with this example can be found [here](https://github.com/deepgram-devs/vue-reusability-with-composables/tree/main/src). There are several branches to show the progression of how the project gets refactored.\n\n### Vue 2\n\nI won't go over how I built the project in Vue 2, but if it helps, the completed project in Vue 2 can be viewed [here](https://stackblitz.com/edit/vue2-vue-cli-vnp6kn?file=src/components/Mast.vue).\n\nResizing the window will show how the text size changes as the width of the image changes.\n\n### Vue 3\n\nHere's how to build the component in Vue 3. The html in the `template` is exactly the same as the Vue 2 project:\n\n```html\n<template>\n  <div class=\"mast\">\n    <div class=\"container\">\n      <div class=\"image-container\">\n        <img ref=\"imageRef\" src=\"../assets/meatball.jpeg\" />\n      </div>\n      <div ref=\"textRef\" class=\"text-container\">\n        <p>\n          Meatball, 9. Barks at Amazon guy. Likes sharing your apple slices.\n          Wants you to grab the toy but won't let you have it.\n        </p>\n      </div>\n    </div>\n  </div>\n</template>\n```\n\nIn the script section, I'll need to add the `setup` function, and then I will define the variables for the data I'll be tracking. Since elements in the DOM will depend on each other to either trigger a change or react to a change, I will need to make them reactive using `ref` so everything stays in sync. Here's how I do that:\n\n```js\n<script>\nimport { ref } from \"vue\";\nexport default {\n  name: \"Mast\",\n  setup() {\n    let imageWidth = ref(0);\n\n    //template refs\n    let imageRef = ref(null);\n    let textRef = ref(null);\n\n    return { imageRef, textRef };\n  },\n};\n<\/script>\n```\n\nThe important data to keep track of is the `imageWidth` because that value is what I will use to determine if the text size should change.\n\nThe `imageWidth` value has to come from the image element in the DOM. It will be based on the actual size of the image at a point in time, so I will need to connect to the actual DOM element using a [template ref](https://vuejs.org/guide/essentials/template-refs.html).\n\n#### Template Refs\n\nI think of template refs as the Vue way of using Javascript to hook into a DOM element, such as the method `document.getElementById()` or `document.querySelector()`.\n\nIn Vue 2, the way to do that is to add `ref=\"nameOfRef\"` as an attribute on the element that I am targeting, then in the script, I could perform some action on it using `this.$refs.nameOfRef`.\n\nIn Vue 3, template refs are now part of the reactive API. If I want to set up a template ref, I still need to add `ref=\"nameOfRef\"` as an attribute on the element that I want to hook into.\n\n```html\n<img ref=\"imageRef\" src=\"../assets/meatball.jpeg\" />\n```\n\nThe difference now is that in the script, I need to define the template ref as a reactive reference variable wrapped in `ref`. And I MUST return it in the `return` object of the `setup` function so that it connects to that DOM element in the template. If I don't, it won't work.\n\n```js\nsetup() {\n    //template refs\n    let imageRef = ref(null);\n    let textRef = ref(null);\n\n    return { imageRef, textRef };\n  },\n```\n\nAlso, I need to be aware that I won't be able to actually access the ref to do something with it until the component has mounted - which brings me to the next topic.\n\n#### Lifecycle Hooks\n\nNow that I have the data set up I can add the logic to listen for the resize event.\n\nI want to track the size of the image, which will change depending on if the window is resized. Since I'm dealing with a visual element, I need to consider timing of when that element will appear in the browser. It won't appear until the component has mounted.\n\nThe hooks that I'll need for setting up the event listener (and destroying it) are `onMounted` and `onUnmounted`, which are the equivalent to `mounted` and `unmounted` in Vue 2.\n\nIn `onMounted`, I have access to the template ref, so I will first set the initial value of the `imageWidth` based on the width of the actual image, which I pull from the template ref. I will also put a listener on the window to track the resizing event so that as the window is resized, the `resizeHandler` function runs.\n\nEverything currently resides in the setup function for now, but will be refactored later and moved into composables:\n\n```js\n// inside setup function:\n\nonMounted(() => {\n  //set initial value\n  imageWidth.value = imageRef.value.offsetWidth\n\n  //add listener to track resize\n  window.addEventListener('resize', resizeHandler)\n})\n```\n\nThe `resizeHandler` sets the `imageWidth` value to the `imageRef`'s width. I have to remember that with refs in the script, I have to unwrap the value using `.value`:\n\n```js\n// inside setup function:\n\nfunction resizeHandler() {\n  //tracking of width changes\n  imageWidth.value = imageRef.value.offsetWidth\n}\n```\n\nSince I'm listening for the resize event starting when the component mounts, I need to be sure to destroy the listener when the component unmounts:\n\n```js\n// inside setup function:\n\nonUnmounted(() => {\n  //remove listener\n  window.removeEventListener('resize', resizeHandler)\n})\n```\n\n#### watch\n\nI now have the data set up so that the `imageWidth` updates in-sync with the `imageRef`'s width as the event listener fires the `resizeHandler` function.\n\nThe last thing I need to do is make something happen as a side effect of the `imageWidth` increasing or decreasing. Vue offers `watch` and `watchEffect` as part of the API for watching a reactive property and causing a side effect to occur based on changes to the property.\n\nIn this case, I will use `watch` because I only need to track the `imageWidth` value since a change to `imageWidth` is what I'm using to cause the text size to change.\n\n```js\n// inside setup function:\n\nwatch(imageWidth, () => {\n  //initiate side effects to change text size when window width changes\n  if (imageWidth.value < 150) {\n    textRef.value.style.fontSize = '.8em'\n    textRef.value.style.lineHeight = '1.3'\n  }\n  if (imageWidth.value < 200 && imageWidth.value > 150) {\n    textRef.value.style.fontSize = '1em'\n    textRef.value.style.lineHeight = '1.4'\n  }\n  if (imageWidth.value > 200) {\n    textRef.value.style.fontSize = '1.3em'\n    textRef.value.style.lineHeight = '1.5'\n  }\n})\n```\n\nHere is the finished [example code](https://github.com/SandraRodgers/vue-reusability-with-composables/tree/no-composables/src) using Vue 3 (and before I refactor it to use composables). Now that everything is working, I will refactor my code to make it more reusable.\n\n## Reusability in The Composition API\n\nMany people would say that the biggest advantage of using Vue 3's Composition API is its emphasis on organizing code by logical concern rather than by option types like in Vue 2. If I'm building a small application that is only going to have minimal logic in a component, the Options API, or even just putting all my logic in the setup function, is fine. But as a component grows larger, it can be challenging to follow the data flow.\n\nFor example, a UI component such as a dropdown menu has to deal with opening and closing the dropdown, keyboard interactions, pulling in data to populate the menu, and more. All that logic in one component spread out among the options like `methods`, `watch`, `mounted`, etc., can be hard to decipher.\n\nVue 2 does offer approaches for separating out logic, such as **mixins** and **utility functions**. But Vue 3's whole philosophy is designed around the idea of writing code that is reusable, focused around logical concern, and easy to read. The most fundamental way it does this is through **composition functions** (i.e. **composables**).\n\n## Composables\n\nThe advantage of organizing code by logical concern encapsulated in a composable function is that it becomes easier to read, but it also becomes easier to reuse in other parts of the project or even in other projects.\n\nI feel that the ultimate goal should be to write the most agnostic code possible in a composable, i.e. code that can be recycled in different contexts and isn't so dependent on the one unique context it starts out in.\n\nIt does take time and practice to get better at this skill, but the good news is, Vue 3 is the perfect framework to work at it because using the Composition API really emphasizes this approach to coding.\n\nWith that in mind, I'll think about how I can refactor my project to take advantage of composables.\n\n### useWindowEvent\n\nA common situation is having to listen for an event on the window, such as a resize event. I see an opportunity to write a composable that can be reused when I want to add or destroy an event listener on the window.\n\nIn my project, in the `onMounted` hook I currently have:\n\n```js\nwindow.addEventListener('resize', resizeHandler)\n```\n\nAnd in the `unMounted` hook:\n\n```js\nwindow.removeEventListener('resize', resizeHandler)\n```\n\nI can create a composable function that accepts an event-type, a handler, and a string saying 'add' or 'destroy', and write logic that will set up the window event listener. I will put this file in a folder called `~/composables`. The Vue 3 convention is to name composable files with the prefix 'use' as in *useWindowEvent*.\n\nHere is the composable `useWindowEvent.js`:\n\n```js\nexport default function useWindowEvent(event, handler, addOrDestroy) {\n  if (addOrDestroy === 'add') {\n    window.addEventListener(event, handler)\n  }\n\n  if (addOrDestroy === 'destroy') {\n    window.removeEventListener(event, handler)\n  }\n}\n```\n\nNow in my project, I import it into the component where it will be used:\n\n```js\nimport useWindowEvent from '../composables/useWindowEvent'\n```\n\nThen I invoke the function with the arguments that I set it up to receive:\n\n```js\nuseWindowEvent('resize', resizeHandler, 'add')\n```\n\nThis is just a small composable, and it doesn't really make my life that much easier since I didn't have to write very much code anyways to set up the listener on the window.\n\nBut there is a significant advantage to creating reusable code. I know the composable is written to work, so I'm less likely to have little errors or typos since I'm reusing code that has been tested and used before. Because I've tested it, I can feel confident reusing it in many contexts.\n\nConsistency is another benefit. I keep functionality consistent by using the composable in multiple places, rather than having to reinvent the wheel every time, potentially introducing differences (and problems).\n\nAnd now that I have created a `useWindowEvent`, I could try to make it to work for all kinds of elements, not just the window. If I spend some time improving it so that it can add an event listener to any type of element, then I have a really useful composable that I can reuse.\n\n### useResizeText\n\nThe main feature of my project is that the text resizes based on the image element's width. I can turn this into a composable that can be reused in cases where I want text to resize based on some other element.\n\nIn my goal to write it in a way that is more agnostic, I can think of the element that is watched (the image) as the *trigger element*, and the element that changes (the text) as the *react element*. In the `resizeText` composable, I'll refer to them as the `triggerElement` and the `reactElement`, but in the `Mast.vue` component they are the `imageRef` and the `textRef`. These are more specific references to the context of my project, while `triggerElement` and `reactElement` are more general since I would like the composable to be reused if I ever need it in a different project.\n\nI create the composable file called `useResizeText.js`. I anticipate that I'll need to accept two arguments, the `triggerElement` and the `reactElement` (which come in from `Mast.vue` as the `imageRef` and the `textRef`):\n\n```js\n//useResizeText.js:\n\nexport default function useResizeText(triggerElement, reactElement) {\n  return { elementWidth }\n}\n```\n\nI've included the return object because any data from the composable that I want to make available in the component (or another file) must be included in it. I'll return the `elementWidth` to the component so I can put it in my template in `Mast.vue` and see the resize logic working in real-time.\n\nIn the `Mast.vue` component, I will call the composable. I have to send in the template refs so the composable can compute the text size based on those DOM elements. I will destructure the composable so that I get the returned `elementWidth`.\n\nInside `setup` in `Mast.vue`:\n\n```js\n//destructure to get data sent back from the composable\n//get updated width for template\nconst { elementWidth } = useResizeText(imageRef, textRef)\n```\n\nI will return `elementWidth` to the template so that I see that number reacting to the window resizing. I also return `imageRef` and `textRef` because that is required for the template refs to stay in-sync between the script and the template.\n\nHere is everything in the `setup` function:\n\n```js\nsetup() {\n    //template refs\n    let imageRef = ref(null);\n    let textRef = ref(null);\n    //destructure to get data sent back from the composable\n    //get updated width for template\n    const { elementWidth } = useResizeText(imageRef, textRef);\n    return { imageRef, textRef, elementWidth };\n  },\n\n```\n\nThe composable itself is mostly the same as it was when I wrote the logic in the setup function, with a few small updates.\n\nTo make sure I don't get an error when I set the `elementWidth` to the imageRef/triggerElement `offsetHeight` value, I use an 'if' statement to make sure the `triggerElement` exists:\n\n```js\nif (triggerElement.value) {\n  elementWidth.value = triggerElement.value.offsetWidth\n}\n```\n\nI also set the initial text styles as soon as the component mounts and then run that `setTextStyles` function again inside the watch every time the `elementWidth` (the image's width) changes.\n\nHere is the full code for the `resizeText.js` composable:\n\n```js\nimport { ref, watch, onMounted, onUnmounted } from 'vue'\nimport useWindowEvent from './useWindowEvent'\n\nexport default function useResize(triggerElement, reactElement) {\n  let elementWidth = ref(0)\n\n  //handler to send into useWindowEvent\n  function resizeHandler() {\n    if (triggerElement.value) {\n      elementWidth.value = triggerElement.value.offsetWidth\n    }\n  }\n\n  //set initial values for elementWidth and text styles\n  onMounted(() => {\n    if (triggerElement.value) {\n      elementWidth.value = triggerElement.value.offsetWidth\n      setTextStyles()\n    }\n  })\n\n  //function to set text styles on mount and in watcher\n  function setTextStyles() {\n    if (elementWidth.value < 150) {\n      reactElement.value.style.fontSize = '.8em'\n      reactElement.value.style.lineHeight = '1.3'\n    }\n    if (elementWidth.value < 200 && elementWidth.value > 150) {\n      reactElement.value.style.fontSize = '1em'\n      reactElement.value.style.lineHeight = '1.4'\n    }\n    if (elementWidth.value > 200) {\n      reactElement.value.style.fontSize = '1.3em'\n      reactElement.value.style.lineHeight = '1.5'\n    }\n  }\n\n  //add and destroy event listeners\n  useWindowEvent('resize', resizeHandler, 'add')\n  onUnmounted(() => {\n    useWindowEvent('resize', resizeHandler, 'destroy')\n  })\n\n  //watch elementWidth and set text styles\n  watch(elementWidth, () => {\n    setTextStyles()\n  })\n\n  return { elementWidth }\n}\n```\n\nThis [refactoring](https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-first-refactor/src) makes `Mast.vue` much easier to read because the logic for resizing the text and for adding a window event listener are separated out into composables.\n\nHowever, my ultimate goal is to make composables that are more reusable in general. There is more I can do to make the `resizeText` composable reusable in other projects.\n\nFor example, I could set it up to take a breakpoints object, so that I don't have to always use the same hardcoded width sizes to influence the text.\n\nI could also rework it accept a styles object for the text styles so that I'm not required to use the same hardcoded values for text styles for any component that uses the composable. Something like this in the component:\n\n```js\n//constants\nconst breakPoints = { small: '100', medium: '150', large: '200' }\nconst textStyles = {\n  fontSize: { small: '.8em', medium: '1em', large: '1.3em' },\n  lineHeight: { small: '1.3', medium: '1.4', large: '1.5' },\n}\n```\n\nHere is the [full example](https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-second-refactor/src).\n\nThere are still many ways to improve this composable to make it more agnostic, but this gives a general idea of the process that goes into making a composable more reusable.\n\n## Conclusion\n\nThis concludes my series on Diving into Vue 3. I have learned the fundamentals that will allow me to jump into building projects using the Composition API. I feel so much more confident in Vue 3 now, and I'm also really excited about it.\n\nI hope you have enjoyed this series. There is always more to learn, so stay tuned for future posts about Vue topics.\n\nQuestions? Comments? Just want to say hi? You can find me on [Twitter](https://twitter.com/sandra_rodgers_)!\n\n        ";
}
function compiledContent() {
  return '<h2 id="introduction">Introduction</h2>\n<p>This is the fifth and final post of my \u2018Diving Into Vue 3\u2019 series. Today I will combine what I have learned so far with a demonstration of how to use the Composition API to take advantage of its biggest strength: writing reusable code. This post will:</p>\n<ul>\n<li>review everything I\u2019ve learned so far by walking through how I build an <strong>example component</strong>, focusing on challenges of working with the DOM and using lifecycle methods.</li>\n<li>introduce how to use a <strong>template ref</strong> to keep track of an element in the DOM.</li>\n<li>demonstrate how to refactor the project to use <strong>composition functions</strong> (i.e. <strong>composables</strong>).</li>\n</ul>\n<p>Don\u2019t forget there are four previous posts in this series that might be useful to you:</p>\n<ul>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3 - Getting Started</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-setup-function/">Diving Into Vue 3 - The Setup Function</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/">Diving Into Vue 3: Methods, Watch, and Computed</a></li>\n<li><a href="https://blog.deepgram.com/diving-into-vue-3-reactivity-api/">Diving Into Vue 3: The Reactivity API</a></li>\n</ul>\n<p>If you don\u2019t need the walk-through for building the example project, feel free to jump to the section on <a href="#reusability-in-the-composition-api">reusability</a>, where I show how to refactor the project to use composables.</p>\n<h2 id="example-component">Example Component</h2>\n<p>I am going to build a single-file component that has a mast with an image on the left and text on the right. The problem I need to address is that I want to change the size of the text based on the image being resized.</p>\n<p>Here\u2019s the demo:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1645128984/blog/2022/02/diving-into-vue-3-reusability-with-composables/demo.gif" alt="Rendered component to that uses method to increment and decrement"></p>\n<p>To achieve this, I will:</p>\n<ul>\n<li>listen for resizing of the window with an event listener.</li>\n<li>track the image size.</li>\n<li>update the text size if the image gets to a certain size.</li>\n</ul>\n<p>The repo to go along with this example can be found <a href="https://github.com/deepgram-devs/vue-reusability-with-composables/tree/main/src">here</a>. There are several branches to show the progression of how the project gets refactored.</p>\n<h3 id="vue-2">Vue 2</h3>\n<p>I won\u2019t go over how I built the project in Vue 2, but if it helps, the completed project in Vue 2 can be viewed <a href="https://stackblitz.com/edit/vue2-vue-cli-vnp6kn?file=src/components/Mast.vue">here</a>.</p>\n<p>Resizing the window will show how the text size changes as the width of the image changes.</p>\n<h3 id="vue-3">Vue 3</h3>\n<p>Here\u2019s how to build the component in Vue 3. The html in the <code is:raw>template</code> is exactly the same as the Vue 2 project:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;mast&quot;</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;container&quot;</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">      &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;image-container&quot;</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">        &lt;</span><span style="color: #7EE787">img</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">ref</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;imageRef&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">src</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;../assets/meatball.jpeg&quot;</span><span style="color: #C9D1D9"> /&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">      &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">      &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">ref</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;textRef&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;text-container&quot;</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">        &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">          Meatball, 9. Barks at Amazon guy. Likes sharing your apple slices.</span></span>\n<span class="line"><span style="color: #C9D1D9">          Wants you to grab the toy but won&#39;t let you have it.</span></span>\n<span class="line"><span style="color: #C9D1D9">        &lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">      &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>In the script section, I\u2019ll need to add the <code is:raw>setup</code> function, and then I will define the variables for the data I\u2019ll be tracking. Since elements in the DOM will depend on each other to either trigger a change or react to a change, I will need to make them reactive using <code is:raw>ref</code> so everything stays in sync. Here\u2019s how I do that:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>\n<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  name: </span><span style="color: #A5D6FF">&quot;Mast&quot;</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    let imageWidth </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//template refs</span></span>\n<span class="line"><span style="color: #C9D1D9">    let imageRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    let textRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    return { imageRef, textRef };</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>\n<span class="line"><span style="color: #C9D1D9">};</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>The important data to keep track of is the <code is:raw>imageWidth</code> because that value is what I will use to determine if the text size should change.</p>\n<p>The <code is:raw>imageWidth</code> value has to come from the image element in the DOM. It will be based on the actual size of the image at a point in time, so I will need to connect to the actual DOM element using a <a href="https://vuejs.org/guide/essentials/template-refs.html">template ref</a>.</p>\n<h4 id="template-refs">Template Refs</h4>\n<p>I think of template refs as the Vue way of using Javascript to hook into a DOM element, such as the method <code is:raw>document.getElementById()</code> or <code is:raw>document.querySelector()</code>.</p>\n<p>In Vue 2, the way to do that is to add <code is:raw>ref="nameOfRef"</code> as an attribute on the element that I am targeting, then in the script, I could perform some action on it using <code is:raw>this.$refs.nameOfRef</code>.</p>\n<p>In Vue 3, template refs are now part of the reactive API. If I want to set up a template ref, I still need to add <code is:raw>ref="nameOfRef"</code> as an attribute on the element that I want to hook into.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">img</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">ref</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;imageRef&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">src</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;../assets/meatball.jpeg&quot;</span><span style="color: #C9D1D9"> /&gt;</span></span></code></pre>\n<p>The difference now is that in the script, I need to define the template ref as a reactive reference variable wrapped in <code is:raw>ref</code>. And I MUST return it in the <code is:raw>return</code> object of the <code is:raw>setup</code> function so that it connects to that DOM element in the template. If I don\u2019t, it won\u2019t work.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//template refs</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> imageRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> textRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { imageRef, textRef };</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span></code></pre>\n<p>Also, I need to be aware that I won\u2019t be able to actually access the ref to do something with it until the component has mounted - which brings me to the next topic.</p>\n<h4 id="lifecycle-hooks">Lifecycle Hooks</h4>\n<p>Now that I have the data set up I can add the logic to listen for the resize event.</p>\n<p>I want to track the size of the image, which will change depending on if the window is resized. Since I\u2019m dealing with a visual element, I need to consider timing of when that element will appear in the browser. It won\u2019t appear until the component has mounted.</p>\n<p>The hooks that I\u2019ll need for setting up the event listener (and destroying it) are <code is:raw>onMounted</code> and <code is:raw>onUnmounted</code>, which are the equivalent to <code is:raw>mounted</code> and <code is:raw>unmounted</code> in Vue 2.</p>\n<p>In <code is:raw>onMounted</code>, I have access to the template ref, so I will first set the initial value of the <code is:raw>imageWidth</code> based on the width of the actual image, which I pull from the template ref. I will also put a listener on the window to track the resizing event so that as the window is resized, the <code is:raw>resizeHandler</code> function runs.</p>\n<p>Everything currently resides in the setup function for now, but will be refactored later and moved into composables:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #D2A8FF">onMounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//set initial value</span></span>\n<span class="line"><span style="color: #C9D1D9">  imageWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> imageRef.value.offsetWidth</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//add listener to track resize</span></span>\n<span class="line"><span style="color: #C9D1D9">  window.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>The <code is:raw>resizeHandler</code> sets the <code is:raw>imageWidth</code> value to the <code is:raw>imageRef</code>\u2019s width. I have to remember that with refs in the script, I have to unwrap the value using <code is:raw>.value</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">resizeHandler</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//tracking of width changes</span></span>\n<span class="line"><span style="color: #C9D1D9">  imageWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> imageRef.value.offsetWidth</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Since I\u2019m listening for the resize event starting when the component mounts, I need to be sure to destroy the listener when the component unmounts:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #D2A8FF">onUnmounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//remove listener</span></span>\n<span class="line"><span style="color: #C9D1D9">  window.</span><span style="color: #D2A8FF">removeEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<h4 id="watch">watch</h4>\n<p>I now have the data set up so that the <code is:raw>imageWidth</code> updates in-sync with the <code is:raw>imageRef</code>\u2019s width as the event listener fires the <code is:raw>resizeHandler</code> function.</p>\n<p>The last thing I need to do is make something happen as a side effect of the <code is:raw>imageWidth</code> increasing or decreasing. Vue offers <code is:raw>watch</code> and <code is:raw>watchEffect</code> as part of the API for watching a reactive property and causing a side effect to occur based on changes to the property.</p>\n<p>In this case, I will use <code is:raw>watch</code> because I only need to track the <code is:raw>imageWidth</code> value since a change to <code is:raw>imageWidth</code> is what I\u2019m using to cause the text size to change.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(imageWidth, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//initiate side effects to change text size when window width changes</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (imageWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;.8em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (imageWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> imageWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.4&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (imageWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    textRef.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.5&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>\n<p>Here is the finished <a href="https://github.com/SandraRodgers/vue-reusability-with-composables/tree/no-composables/src">example code</a> using Vue 3 (and before I refactor it to use composables). Now that everything is working, I will refactor my code to make it more reusable.</p>\n<h2 id="reusability-in-the-composition-api">Reusability in The Composition API</h2>\n<p>Many people would say that the biggest advantage of using Vue 3\u2019s Composition API is its emphasis on organizing code by logical concern rather than by option types like in Vue 2. If I\u2019m building a small application that is only going to have minimal logic in a component, the Options API, or even just putting all my logic in the setup function, is fine. But as a component grows larger, it can be challenging to follow the data flow.</p>\n<p>For example, a UI component such as a dropdown menu has to deal with opening and closing the dropdown, keyboard interactions, pulling in data to populate the menu, and more. All that logic in one component spread out among the options like <code is:raw>methods</code>, <code is:raw>watch</code>, <code is:raw>mounted</code>, etc., can be hard to decipher.</p>\n<p>Vue 2 does offer approaches for separating out logic, such as <strong>mixins</strong> and <strong>utility functions</strong>. But Vue 3\u2019s whole philosophy is designed around the idea of writing code that is reusable, focused around logical concern, and easy to read. The most fundamental way it does this is through <strong>composition functions</strong> (i.e. <strong>composables</strong>).</p>\n<h2 id="composables">Composables</h2>\n<p>The advantage of organizing code by logical concern encapsulated in a composable function is that it becomes easier to read, but it also becomes easier to reuse in other parts of the project or even in other projects.</p>\n<p>I feel that the ultimate goal should be to write the most agnostic code possible in a composable, i.e. code that can be recycled in different contexts and isn\u2019t so dependent on the one unique context it starts out in.</p>\n<p>It does take time and practice to get better at this skill, but the good news is, Vue 3 is the perfect framework to work at it because using the Composition API really emphasizes this approach to coding.</p>\n<p>With that in mind, I\u2019ll think about how I can refactor my project to take advantage of composables.</p>\n<h3 id="usewindowevent">useWindowEvent</h3>\n<p>A common situation is having to listen for an event on the window, such as a resize event. I see an opportunity to write a composable that can be reused when I want to add or destroy an event listener on the window.</p>\n<p>In my project, in the <code is:raw>onMounted</code> hook I currently have:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">window.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span></code></pre>\n<p>And in the <code is:raw>unMounted</code> hook:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">window.</span><span style="color: #D2A8FF">removeEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span></code></pre>\n<p>I can create a composable function that accepts an event-type, a handler, and a string saying \u2018add\u2019 or \u2018destroy\u2019, and write logic that will set up the window event listener. I will put this file in a folder called <code is:raw>~/composables</code>. The Vue 3 convention is to name composable files with the prefix \u2018use\u2019 as in <em>useWindowEvent</em>.</p>\n<p>Here is the composable <code is:raw>useWindowEvent.js</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #FFA657">(event, handler, addOrDestroy) </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (addOrDestroy </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;add&#39;</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    window.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(event, handler)</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (addOrDestroy </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;destroy&#39;</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">    window.</span><span style="color: #D2A8FF">removeEventListener</span><span style="color: #C9D1D9">(event, handler)</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Now in my project, I import it into the component where it will be used:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useWindowEvent </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../composables/useWindowEvent&#39;</span></span></code></pre>\n<p>Then I invoke the function with the arguments that I set it up to receive:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler, </span><span style="color: #A5D6FF">&#39;add&#39;</span><span style="color: #C9D1D9">)</span></span></code></pre>\n<p>This is just a small composable, and it doesn\u2019t really make my life that much easier since I didn\u2019t have to write very much code anyways to set up the listener on the window.</p>\n<p>But there is a significant advantage to creating reusable code. I know the composable is written to work, so I\u2019m less likely to have little errors or typos since I\u2019m reusing code that has been tested and used before. Because I\u2019ve tested it, I can feel confident reusing it in many contexts.</p>\n<p>Consistency is another benefit. I keep functionality consistent by using the composable in multiple places, rather than having to reinvent the wheel every time, potentially introducing differences (and problems).</p>\n<p>And now that I have created a <code is:raw>useWindowEvent</code>, I could try to make it to work for all kinds of elements, not just the window. If I spend some time improving it so that it can add an event listener to any type of element, then I have a really useful composable that I can reuse.</p>\n<h3 id="useresizetext">useResizeText</h3>\n<p>The main feature of my project is that the text resizes based on the image element\u2019s width. I can turn this into a composable that can be reused in cases where I want text to resize based on some other element.</p>\n<p>In my goal to write it in a way that is more agnostic, I can think of the element that is watched (the image) as the <em>trigger element</em>, and the element that changes (the text) as the <em>react element</em>. In the <code is:raw>resizeText</code> composable, I\u2019ll refer to them as the <code is:raw>triggerElement</code> and the <code is:raw>reactElement</code>, but in the <code is:raw>Mast.vue</code> component they are the <code is:raw>imageRef</code> and the <code is:raw>textRef</code>. These are more specific references to the context of my project, while <code is:raw>triggerElement</code> and <code is:raw>reactElement</code> are more general since I would like the composable to be reused if I ever need it in a different project.</p>\n<p>I create the composable file called <code is:raw>useResizeText.js</code>. I anticipate that I\u2019ll need to accept two arguments, the <code is:raw>triggerElement</code> and the <code is:raw>reactElement</code> (which come in from <code is:raw>Mast.vue</code> as the <code is:raw>imageRef</code> and the <code is:raw>textRef</code>):</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//useResizeText.js:</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useResizeText</span><span style="color: #FFA657">(triggerElement, reactElement) </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { elementWidth }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I\u2019ve included the return object because any data from the composable that I want to make available in the component (or another file) must be included in it. I\u2019ll return the <code is:raw>elementWidth</code> to the component so I can put it in my template in <code is:raw>Mast.vue</code> and see the resize logic working in real-time.</p>\n<p>In the <code is:raw>Mast.vue</code> component, I will call the composable. I have to send in the template refs so the composable can compute the text size based on those DOM elements. I will destructure the composable so that I get the returned <code is:raw>elementWidth</code>.</p>\n<p>Inside <code is:raw>setup</code> in <code is:raw>Mast.vue</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//destructure to get data sent back from the composable</span></span>\n<span class="line"><span style="color: #8B949E">//get updated width for template</span></span>\n<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">elementWidth</span><span style="color: #C9D1D9"> } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useResizeText</span><span style="color: #C9D1D9">(imageRef, textRef)</span></span></code></pre>\n<p>I will return <code is:raw>elementWidth</code> to the template so that I see that number reacting to the window resizing. I also return <code is:raw>imageRef</code> and <code is:raw>textRef</code> because that is required for the template refs to stay in-sync between the script and the template.</p>\n<p>Here is everything in the <code is:raw>setup</code> function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//template refs</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> imageRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> textRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//destructure to get data sent back from the composable</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//get updated width for template</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">elementWidth</span><span style="color: #C9D1D9"> } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useResizeText</span><span style="color: #C9D1D9">(imageRef, textRef);</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { imageRef, textRef, elementWidth };</span></span>\n<span class="line"><span style="color: #C9D1D9">  },</span></span>\n<span class="line"></span></code></pre>\n<p>The composable itself is mostly the same as it was when I wrote the logic in the setup function, with a few small updates.</p>\n<p>To make sure I don\u2019t get an error when I set the <code is:raw>elementWidth</code> to the imageRef/triggerElement <code is:raw>offsetHeight</code> value, I use an \u2018if\u2019 statement to make sure the <code is:raw>triggerElement</code> exists:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (triggerElement.value) {</span></span>\n<span class="line"><span style="color: #C9D1D9">  elementWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> triggerElement.value.offsetWidth</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>I also set the initial text styles as soon as the component mounts and then run that <code is:raw>setTextStyles</code> function again inside the watch every time the <code is:raw>elementWidth</code> (the image\u2019s width) changes.</p>\n<p>Here is the full code for the <code is:raw>resizeText.js</code> composable:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref, watch, onMounted, onUnmounted } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useWindowEvent </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;./useWindowEvent&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useResize</span><span style="color: #FFA657">(triggerElement, reactElement) </span><span style="color: #C9D1D9">{</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> elementWidth </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//handler to send into useWindowEvent</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">resizeHandler</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (triggerElement.value) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      elementWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> triggerElement.value.offsetWidth</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//set initial values for elementWidth and text styles</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">onMounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (triggerElement.value) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      elementWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> triggerElement.value.offsetWidth</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">setTextStyles</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//function to set text styles on mount and in watcher</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">setTextStyles</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (elementWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;.8em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (elementWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> elementWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.4&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (elementWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">) {</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3em&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.5&#39;</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//add and destroy event listeners</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler, </span><span style="color: #A5D6FF">&#39;add&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">onUnmounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler, </span><span style="color: #A5D6FF">&#39;destroy&#39;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//watch elementWidth and set text styles</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(elementWidth, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">setTextStyles</span><span style="color: #C9D1D9">()</span></span>\n<span class="line"><span style="color: #C9D1D9">  })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { elementWidth }</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>This <a href="https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-first-refactor/src">refactoring</a> makes <code is:raw>Mast.vue</code> much easier to read because the logic for resizing the text and for adding a window event listener are separated out into composables.</p>\n<p>However, my ultimate goal is to make composables that are more reusable in general. There is more I can do to make the <code is:raw>resizeText</code> composable reusable in other projects.</p>\n<p>For example, I could set it up to take a breakpoints object, so that I don\u2019t have to always use the same hardcoded width sizes to influence the text.</p>\n<p>I could also rework it accept a styles object for the text styles so that I\u2019m not required to use the same hardcoded values for text styles for any component that uses the composable. Something like this in the component:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//constants</span></span>\n<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">breakPoints</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { small: </span><span style="color: #A5D6FF">&#39;100&#39;</span><span style="color: #C9D1D9">, medium: </span><span style="color: #A5D6FF">&#39;150&#39;</span><span style="color: #C9D1D9">, large: </span><span style="color: #A5D6FF">&#39;200&#39;</span><span style="color: #C9D1D9"> }</span></span>\n<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">textStyles</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span></span>\n<span class="line"><span style="color: #C9D1D9">  fontSize: { small: </span><span style="color: #A5D6FF">&#39;.8em&#39;</span><span style="color: #C9D1D9">, medium: </span><span style="color: #A5D6FF">&#39;1em&#39;</span><span style="color: #C9D1D9">, large: </span><span style="color: #A5D6FF">&#39;1.3em&#39;</span><span style="color: #C9D1D9"> },</span></span>\n<span class="line"><span style="color: #C9D1D9">  lineHeight: { small: </span><span style="color: #A5D6FF">&#39;1.3&#39;</span><span style="color: #C9D1D9">, medium: </span><span style="color: #A5D6FF">&#39;1.4&#39;</span><span style="color: #C9D1D9">, large: </span><span style="color: #A5D6FF">&#39;1.5&#39;</span><span style="color: #C9D1D9"> },</span></span>\n<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>\n<p>Here is the <a href="https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-second-refactor/src">full example</a>.</p>\n<p>There are still many ways to improve this composable to make it more agnostic, but this gives a general idea of the process that goes into making a composable more reusable.</p>\n<h2 id="conclusion">Conclusion</h2>\n<p>This concludes my series on Diving into Vue 3. I have learned the fundamentals that will allow me to jump into building projects using the Composition API. I feel so much more confident in Vue 3 now, and I\u2019m also really excited about it.</p>\n<p>I hope you have enjoyed this series. There is always more to learn, so stay tuned for future posts about Vue topics.</p>\n<p>Questions? Comments? Just want to say hi? You can find me on <a href="https://twitter.com/sandra_rodgers_">Twitter</a>!</p>';
}
const $$Astro = createAstro("/Users/sandrarodgers/web-next/blog/src/content/blog/posts/diving-into-vue-3-reusability-with-composables/index.md", "", "file:///Users/sandrarodgers/web-next/blog/");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  new Slugger();
  return renderTemplate`<head>${renderHead($$result)}</head><h2 id="introduction">Introduction</h2>
<p>This is the fifth and final post of my ‘Diving Into Vue 3’ series. Today I will combine what I have learned so far with a demonstration of how to use the Composition API to take advantage of its biggest strength: writing reusable code. This post will:</p>
<ul>
<li>review everything I’ve learned so far by walking through how I build an <strong>example component</strong>, focusing on challenges of working with the DOM and using lifecycle methods.</li>
<li>introduce how to use a <strong>template ref</strong> to keep track of an element in the DOM.</li>
<li>demonstrate how to refactor the project to use <strong>composition functions</strong> (i.e. <strong>composables</strong>).</li>
</ul>
<p>Don’t forget there are four previous posts in this series that might be useful to you:</p>
<ul>
<li><a href="https://blog.deepgram.com/diving-into-vue-3-getting-started/">Diving Into Vue 3 - Getting Started</a></li>
<li><a href="https://blog.deepgram.com/diving-into-vue-3-setup-function/">Diving Into Vue 3 - The Setup Function</a></li>
<li><a href="https://blog.deepgram.com/diving-into-vue-3-methods-watch-and-computed/">Diving Into Vue 3: Methods, Watch, and Computed</a></li>
<li><a href="https://blog.deepgram.com/diving-into-vue-3-reactivity-api/">Diving Into Vue 3: The Reactivity API</a></li>
</ul>
<p>If you don’t need the walk-through for building the example project, feel free to jump to the section on <a href="#reusability-in-the-composition-api">reusability</a>, where I show how to refactor the project to use composables.</p>
<h2 id="example-component">Example Component</h2>
<p>I am going to build a single-file component that has a mast with an image on the left and text on the right. The problem I need to address is that I want to change the size of the text based on the image being resized.</p>
<p>Here’s the demo:</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1645128984/blog/2022/02/diving-into-vue-3-reusability-with-composables/demo.gif" alt="Rendered component to that uses method to increment and decrement"></p>
<p>To achieve this, I will:</p>
<ul>
<li>listen for resizing of the window with an event listener.</li>
<li>track the image size.</li>
<li>update the text size if the image gets to a certain size.</li>
</ul>
<p>The repo to go along with this example can be found <a href="https://github.com/deepgram-devs/vue-reusability-with-composables/tree/main/src">here</a>. There are several branches to show the progression of how the project gets refactored.</p>
<h3 id="vue-2">Vue 2</h3>
<p>I won’t go over how I built the project in Vue 2, but if it helps, the completed project in Vue 2 can be viewed <a href="https://stackblitz.com/edit/vue2-vue-cli-vnp6kn?file=src/components/Mast.vue">here</a>.</p>
<p>Resizing the window will show how the text size changes as the width of the image changes.</p>
<h3 id="vue-3">Vue 3</h3>
<p>Here’s how to build the component in Vue 3. The html in the <code>template</code> is exactly the same as the Vue 2 project:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;mast&quot;</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;container&quot;</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">      &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;image-container&quot;</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">        &lt;</span><span style="color: #7EE787">img</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">ref</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;imageRef&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">src</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;../assets/meatball.jpeg&quot;</span><span style="color: #C9D1D9"> /&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">      &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">      &lt;</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">ref</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;textRef&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">class</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;text-container&quot;</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">        &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">          Meatball, 9. Barks at Amazon guy. Likes sharing your apple slices.</span></span>
<span class="line"><span style="color: #C9D1D9">          Wants you to grab the toy but won&#39;t let you have it.</span></span>
<span class="line"><span style="color: #C9D1D9">        &lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">      &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">div</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">template</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>In the script section, I’ll need to add the <code>setup</code> function, and then I will define the variables for the data I’ll be tracking. Since elements in the DOM will depend on each other to either trigger a change or react to a change, I will need to make them reactive using <code>ref</code> so everything stays in sync. Here’s how I do that:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">import </span><span style="color: #FF7B72">{</span><span style="color: #C9D1D9"> ref </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9"> from &quot;vue&quot;;</span></span>
<span class="line"><span style="color: #C9D1D9">export default </span><span style="color: #FF7B72">{</span></span>
<span class="line"><span style="color: #C9D1D9">  name: </span><span style="color: #A5D6FF">&quot;Mast&quot;</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    let imageWidth </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//template refs</span></span>
<span class="line"><span style="color: #C9D1D9">    let imageRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    let textRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    return { imageRef, textRef };</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">}</span><span style="color: #C9D1D9">,</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">script</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>The important data to keep track of is the <code>imageWidth</code> because that value is what I will use to determine if the text size should change.</p>
<p>The <code>imageWidth</code> value has to come from the image element in the DOM. It will be based on the actual size of the image at a point in time, so I will need to connect to the actual DOM element using a <a href="https://vuejs.org/guide/essentials/template-refs.html">template ref</a>.</p>
<h4 id="template-refs">Template Refs</h4>
<p>I think of template refs as the Vue way of using Javascript to hook into a DOM element, such as the method <code>document.getElementById()</code> or <code>document.querySelector()</code>.</p>
<p>In Vue 2, the way to do that is to add <code>ref="nameOfRef"</code> as an attribute on the element that I am targeting, then in the script, I could perform some action on it using <code>this.$refs.nameOfRef</code>.</p>
<p>In Vue 3, template refs are now part of the reactive API. If I want to set up a template ref, I still need to add <code>ref="nameOfRef"</code> as an attribute on the element that I want to hook into.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">img</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">ref</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;imageRef&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">src</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;../assets/meatball.jpeg&quot;</span><span style="color: #C9D1D9"> /&gt;</span></span></code></pre>
<p>The difference now is that in the script, I need to define the template ref as a reactive reference variable wrapped in <code>ref</code>. And I MUST return it in the <code>return</code> object of the <code>setup</code> function so that it connects to that DOM element in the template. If I don’t, it won’t work.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//template refs</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> imageRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> textRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { imageRef, textRef };</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span></code></pre>
<p>Also, I need to be aware that I won’t be able to actually access the ref to do something with it until the component has mounted - which brings me to the next topic.</p>
<h4 id="lifecycle-hooks">Lifecycle Hooks</h4>
<p>Now that I have the data set up I can add the logic to listen for the resize event.</p>
<p>I want to track the size of the image, which will change depending on if the window is resized. Since I’m dealing with a visual element, I need to consider timing of when that element will appear in the browser. It won’t appear until the component has mounted.</p>
<p>The hooks that I’ll need for setting up the event listener (and destroying it) are <code>onMounted</code> and <code>onUnmounted</code>, which are the equivalent to <code>mounted</code> and <code>unmounted</code> in Vue 2.</p>
<p>In <code>onMounted</code>, I have access to the template ref, so I will first set the initial value of the <code>imageWidth</code> based on the width of the actual image, which I pull from the template ref. I will also put a listener on the window to track the resizing event so that as the window is resized, the <code>resizeHandler</code> function runs.</p>
<p>Everything currently resides in the setup function for now, but will be refactored later and moved into composables:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D2A8FF">onMounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//set initial value</span></span>
<span class="line"><span style="color: #C9D1D9">  imageWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> imageRef.value.offsetWidth</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//add listener to track resize</span></span>
<span class="line"><span style="color: #C9D1D9">  window.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>The <code>resizeHandler</code> sets the <code>imageWidth</code> value to the <code>imageRef</code>’s width. I have to remember that with refs in the script, I have to unwrap the value using <code>.value</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">resizeHandler</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//tracking of width changes</span></span>
<span class="line"><span style="color: #C9D1D9">  imageWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> imageRef.value.offsetWidth</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>Since I’m listening for the resize event starting when the component mounts, I need to be sure to destroy the listener when the component unmounts:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D2A8FF">onUnmounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//remove listener</span></span>
<span class="line"><span style="color: #C9D1D9">  window.</span><span style="color: #D2A8FF">removeEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<h4 id="watch">watch</h4>
<p>I now have the data set up so that the <code>imageWidth</code> updates in-sync with the <code>imageRef</code>’s width as the event listener fires the <code>resizeHandler</code> function.</p>
<p>The last thing I need to do is make something happen as a side effect of the <code>imageWidth</code> increasing or decreasing. Vue offers <code>watch</code> and <code>watchEffect</code> as part of the API for watching a reactive property and causing a side effect to occur based on changes to the property.</p>
<p>In this case, I will use <code>watch</code> because I only need to track the <code>imageWidth</code> value since a change to <code>imageWidth</code> is what I’m using to cause the text size to change.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// inside setup function:</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(imageWidth, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//initiate side effects to change text size when window width changes</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (imageWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    textRef.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;.8em&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">    textRef.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (imageWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> imageWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    textRef.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1em&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">    textRef.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.4&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (imageWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    textRef.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3em&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">    textRef.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.5&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">})</span></span></code></pre>
<p>Here is the finished <a href="https://github.com/SandraRodgers/vue-reusability-with-composables/tree/no-composables/src">example code</a> using Vue 3 (and before I refactor it to use composables). Now that everything is working, I will refactor my code to make it more reusable.</p>
<h2 id="reusability-in-the-composition-api">Reusability in The Composition API</h2>
<p>Many people would say that the biggest advantage of using Vue 3’s Composition API is its emphasis on organizing code by logical concern rather than by option types like in Vue 2. If I’m building a small application that is only going to have minimal logic in a component, the Options API, or even just putting all my logic in the setup function, is fine. But as a component grows larger, it can be challenging to follow the data flow.</p>
<p>For example, a UI component such as a dropdown menu has to deal with opening and closing the dropdown, keyboard interactions, pulling in data to populate the menu, and more. All that logic in one component spread out among the options like <code>methods</code>, <code>watch</code>, <code>mounted</code>, etc., can be hard to decipher.</p>
<p>Vue 2 does offer approaches for separating out logic, such as <strong>mixins</strong> and <strong>utility functions</strong>. But Vue 3’s whole philosophy is designed around the idea of writing code that is reusable, focused around logical concern, and easy to read. The most fundamental way it does this is through <strong>composition functions</strong> (i.e. <strong>composables</strong>).</p>
<h2 id="composables">Composables</h2>
<p>The advantage of organizing code by logical concern encapsulated in a composable function is that it becomes easier to read, but it also becomes easier to reuse in other parts of the project or even in other projects.</p>
<p>I feel that the ultimate goal should be to write the most agnostic code possible in a composable, i.e. code that can be recycled in different contexts and isn’t so dependent on the one unique context it starts out in.</p>
<p>It does take time and practice to get better at this skill, but the good news is, Vue 3 is the perfect framework to work at it because using the Composition API really emphasizes this approach to coding.</p>
<p>With that in mind, I’ll think about how I can refactor my project to take advantage of composables.</p>
<h3 id="usewindowevent">useWindowEvent</h3>
<p>A common situation is having to listen for an event on the window, such as a resize event. I see an opportunity to write a composable that can be reused when I want to add or destroy an event listener on the window.</p>
<p>In my project, in the <code>onMounted</code> hook I currently have:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">window.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span></code></pre>
<p>And in the <code>unMounted</code> hook:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">window.</span><span style="color: #D2A8FF">removeEventListener</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler)</span></span></code></pre>
<p>I can create a composable function that accepts an event-type, a handler, and a string saying ‘add’ or ‘destroy’, and write logic that will set up the window event listener. I will put this file in a folder called <code>~/composables</code>. The Vue 3 convention is to name composable files with the prefix ‘use’ as in <em>useWindowEvent</em>.</p>
<p>Here is the composable <code>useWindowEvent.js</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #FFA657">(event, handler, addOrDestroy) </span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (addOrDestroy </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;add&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    window.</span><span style="color: #D2A8FF">addEventListener</span><span style="color: #C9D1D9">(event, handler)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (addOrDestroy </span><span style="color: #FF7B72">===</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;destroy&#39;</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    window.</span><span style="color: #D2A8FF">removeEventListener</span><span style="color: #C9D1D9">(event, handler)</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>Now in my project, I import it into the component where it will be used:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useWindowEvent </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;../composables/useWindowEvent&#39;</span></span></code></pre>
<p>Then I invoke the function with the arguments that I set it up to receive:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler, </span><span style="color: #A5D6FF">&#39;add&#39;</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>This is just a small composable, and it doesn’t really make my life that much easier since I didn’t have to write very much code anyways to set up the listener on the window.</p>
<p>But there is a significant advantage to creating reusable code. I know the composable is written to work, so I’m less likely to have little errors or typos since I’m reusing code that has been tested and used before. Because I’ve tested it, I can feel confident reusing it in many contexts.</p>
<p>Consistency is another benefit. I keep functionality consistent by using the composable in multiple places, rather than having to reinvent the wheel every time, potentially introducing differences (and problems).</p>
<p>And now that I have created a <code>useWindowEvent</code>, I could try to make it to work for all kinds of elements, not just the window. If I spend some time improving it so that it can add an event listener to any type of element, then I have a really useful composable that I can reuse.</p>
<h3 id="useresizetext">useResizeText</h3>
<p>The main feature of my project is that the text resizes based on the image element’s width. I can turn this into a composable that can be reused in cases where I want text to resize based on some other element.</p>
<p>In my goal to write it in a way that is more agnostic, I can think of the element that is watched (the image) as the <em>trigger element</em>, and the element that changes (the text) as the <em>react element</em>. In the <code>resizeText</code> composable, I’ll refer to them as the <code>triggerElement</code> and the <code>reactElement</code>, but in the <code>Mast.vue</code> component they are the <code>imageRef</code> and the <code>textRef</code>. These are more specific references to the context of my project, while <code>triggerElement</code> and <code>reactElement</code> are more general since I would like the composable to be reused if I ever need it in a different project.</p>
<p>I create the composable file called <code>useResizeText.js</code>. I anticipate that I’ll need to accept two arguments, the <code>triggerElement</code> and the <code>reactElement</code> (which come in from <code>Mast.vue</code> as the <code>imageRef</code> and the <code>textRef</code>):</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//useResizeText.js:</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useResizeText</span><span style="color: #FFA657">(triggerElement, reactElement) </span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { elementWidth }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>I’ve included the return object because any data from the composable that I want to make available in the component (or another file) must be included in it. I’ll return the <code>elementWidth</code> to the component so I can put it in my template in <code>Mast.vue</code> and see the resize logic working in real-time.</p>
<p>In the <code>Mast.vue</code> component, I will call the composable. I have to send in the template refs so the composable can compute the text size based on those DOM elements. I will destructure the composable so that I get the returned <code>elementWidth</code>.</p>
<p>Inside <code>setup</code> in <code>Mast.vue</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//destructure to get data sent back from the composable</span></span>
<span class="line"><span style="color: #8B949E">//get updated width for template</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">elementWidth</span><span style="color: #C9D1D9"> } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useResizeText</span><span style="color: #C9D1D9">(imageRef, textRef)</span></span></code></pre>
<p>I will return <code>elementWidth</code> to the template so that I see that number reacting to the window resizing. I also return <code>imageRef</code> and <code>textRef</code> because that is required for the template refs to stay in-sync between the script and the template.</p>
<p>Here is everything in the <code>setup</code> function:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">setup</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//template refs</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> imageRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> textRef </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">null</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//destructure to get data sent back from the composable</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">//get updated width for template</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">elementWidth</span><span style="color: #C9D1D9"> } </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">useResizeText</span><span style="color: #C9D1D9">(imageRef, textRef);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { imageRef, textRef, elementWidth };</span></span>
<span class="line"><span style="color: #C9D1D9">  },</span></span>
<span class="line"></span></code></pre>
<p>The composable itself is mostly the same as it was when I wrote the logic in the setup function, with a few small updates.</p>
<p>To make sure I don’t get an error when I set the <code>elementWidth</code> to the imageRef/triggerElement <code>offsetHeight</code> value, I use an ‘if’ statement to make sure the <code>triggerElement</code> exists:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (triggerElement.value) {</span></span>
<span class="line"><span style="color: #C9D1D9">  elementWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> triggerElement.value.offsetWidth</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>I also set the initial text styles as soon as the component mounts and then run that <code>setTextStyles</code> function again inside the watch every time the <code>elementWidth</code> (the image’s width) changes.</p>
<p>Here is the full code for the <code>resizeText.js</code> composable:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> { ref, watch, onMounted, onUnmounted } </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;vue&#39;</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> useWindowEvent </span><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;./useWindowEvent&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">export</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">default</span><span style="color: #FFA657"> </span><span style="color: #FF7B72">function</span><span style="color: #FFA657"> </span><span style="color: #D2A8FF">useResize</span><span style="color: #FFA657">(triggerElement, reactElement) </span><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">let</span><span style="color: #C9D1D9"> elementWidth </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">ref</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//handler to send into useWindowEvent</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">resizeHandler</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (triggerElement.value) {</span></span>
<span class="line"><span style="color: #C9D1D9">      elementWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> triggerElement.value.offsetWidth</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//set initial values for elementWidth and text styles</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">onMounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (triggerElement.value) {</span></span>
<span class="line"><span style="color: #C9D1D9">      elementWidth.value </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> triggerElement.value.offsetWidth</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #D2A8FF">setTextStyles</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//function to set text styles on mount and in watcher</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">function</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">setTextStyles</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (elementWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;.8em&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (elementWidth.value </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&amp;&amp;</span><span style="color: #C9D1D9"> elementWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">150</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1em&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.4&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (elementWidth.value </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">200</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.fontSize </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.3em&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">      reactElement.value.style.lineHeight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;1.5&#39;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//add and destroy event listeners</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler, </span><span style="color: #A5D6FF">&#39;add&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">onUnmounted</span><span style="color: #C9D1D9">(() </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">useWindowEvent</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&#39;resize&#39;</span><span style="color: #C9D1D9">, resizeHandler, </span><span style="color: #A5D6FF">&#39;destroy&#39;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #8B949E">//watch elementWidth and set text styles</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">watch</span><span style="color: #C9D1D9">(elementWidth, () </span><span style="color: #FF7B72">=&gt;</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">setTextStyles</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #C9D1D9">  })</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> { elementWidth }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>This <a href="https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-first-refactor/src">refactoring</a> makes <code>Mast.vue</code> much easier to read because the logic for resizing the text and for adding a window event listener are separated out into composables.</p>
<p>However, my ultimate goal is to make composables that are more reusable in general. There is more I can do to make the <code>resizeText</code> composable reusable in other projects.</p>
<p>For example, I could set it up to take a breakpoints object, so that I don’t have to always use the same hardcoded width sizes to influence the text.</p>
<p>I could also rework it accept a styles object for the text styles so that I’m not required to use the same hardcoded values for text styles for any component that uses the composable. Something like this in the component:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">//constants</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">breakPoints</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { small: </span><span style="color: #A5D6FF">&#39;100&#39;</span><span style="color: #C9D1D9">, medium: </span><span style="color: #A5D6FF">&#39;150&#39;</span><span style="color: #C9D1D9">, large: </span><span style="color: #A5D6FF">&#39;200&#39;</span><span style="color: #C9D1D9"> }</span></span>
<span class="line"><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">textStyles</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">  fontSize: { small: </span><span style="color: #A5D6FF">&#39;.8em&#39;</span><span style="color: #C9D1D9">, medium: </span><span style="color: #A5D6FF">&#39;1em&#39;</span><span style="color: #C9D1D9">, large: </span><span style="color: #A5D6FF">&#39;1.3em&#39;</span><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">  lineHeight: { small: </span><span style="color: #A5D6FF">&#39;1.3&#39;</span><span style="color: #C9D1D9">, medium: </span><span style="color: #A5D6FF">&#39;1.4&#39;</span><span style="color: #C9D1D9">, large: </span><span style="color: #A5D6FF">&#39;1.5&#39;</span><span style="color: #C9D1D9"> },</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>Here is the <a href="https://github.com/SandraRodgers/vue-reusability-with-composables/tree/composables-second-refactor/src">full example</a>.</p>
<p>There are still many ways to improve this composable to make it more agnostic, but this gives a general idea of the process that goes into making a composable more reusable.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This concludes my series on Diving into Vue 3. I have learned the fundamentals that will allow me to jump into building projects using the Composition API. I feel so much more confident in Vue 3 now, and I’m also really excited about it.</p>
<p>I hope you have enjoyed this series. There is always more to learn, so stay tuned for future posts about Vue topics.</p>
<p>Questions? Comments? Just want to say hi? You can find me on <a href="https://twitter.com/sandra_rodgers_">Twitter</a>!</p>`;
}, "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/diving-into-vue-3-reusability-with-composables/index.md");

export { compiledContent, $$Index as default, frontmatter, metadata, rawContent };
