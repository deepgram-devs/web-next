import { c as createAstro, a as createComponent, r as renderTemplate, b as renderHead } from '../entry.mjs';
import Slugger from 'github-slugger';
import '@astrojs/netlify/netlify-functions.js';
import 'preact';
import 'preact-render-to-string';
import 'vue';
import 'vue/server-renderer';
import 'html-escaper';
import 'node-html-parser';
import 'axios';
/* empty css                           *//* empty css                           *//* empty css                           */import '@storyblok/js';
/* empty css                           *//* empty css                          */import 'clone-deep';
import 'slugify';
import 'shiki';
/* empty css                           */import 'camelcase';
import '@astrojs/rss';
/* empty css                           */import 'mime';
import 'cookie';
import 'kleur/colors';
import 'string-width';
import 'path-browserify';
import 'path-to-regexp';

const metadata = { "headings": [{ "depth": 2, "slug": "before-you-start", "text": "Before You Start" }, { "depth": 2, "slug": "getting-started", "text": "Getting Started" }, { "depth": 3, "slug": "get-just-the-episode-items", "text": "Get Just The Episode Items" }, { "depth": 3, "slug": "get-specific-items", "text": "Get Specific Items" }, { "depth": 2, "slug": "displaying-specific-properties", "text": "Displaying Specific Properties" }, { "depth": 2, "slug": "looping-through-objects", "text": "Looping Through Objects" }, { "depth": 2, "slug": "transcribing-each-episode", "text": "Transcribing Each Episode" }, { "depth": 2, "slug": "wrapping-up", "text": "Wrapping Up" }], "source": "\r\nEvery true podcast has a free and publicly available RSS feed that contains information about the show and each episode. In turn, those episode items include metadata about the show and a link to a hosted audio file. In this tutorial, we will download transcripts for the latest episodes of our favorite shows and store them in text files on our computer.\r\n\r\n## Before You Start\r\n\r\nYou will need a Deepgram API Key - [get one here](https://console.deepgram.com/signup?jump=keys). You will also need to install [jq](https://stedolan.github.io/jq/) and  [yq](https://kislyuk.github.io/yq/) to traverse and manipulate XML in your terminal (the data format used for RSS feeds).\r\n\r\nThis tutorial will be a set of building blocks, slowly growing in complexity towards our end goal. We'll take it slow and explain each step so you can apply this knowledge in other contexts, too.\r\n\r\nWe'll use the [NPR Morning Edition](https://www.npr.org/programs/morning-edition/) Podcast Feed: https://feeds.npr.org/510318/podcast.xml, but this can be swapped out for your favorite podcast.\r\n\r\n## Getting Started\r\n\r\nOpen up your terminal and run the following:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml\r\n```\r\n\r\nThis should display the full RSS feed - a bunch of XML (similar to HTML) containing information about the feed.\r\n\r\n### Get Just The Episode Items\r\n\r\nThe structure of the XML includes an `rss` tag containing a `channel` tag. Inside of `channel` is a whole bunch of metadata tags for the show and a set of `item` tags for each episode. `item` tags are not inside of a containing list as we might expect with HTML - they are all direct children of `channel`. Try running the following command:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[]'\r\n```\r\n\r\nThis pipes the curl output into the `xq` command and extracts all of the `item` tags. It also pretty prints it in the terminal, which I find quite helpful when exploring the data. What is after the `xq` command in quotes is known as the 'expression.'\r\n\r\n![Terminal showing pretty-printed item data](https://res.cloudinary.com/deepgram/image/upload/v1658494374/blog/2022/08/downloading-podcast-transcripts-from-terminal/extract-items.png)\r\n\r\n### Get Specific Items\r\n\r\nWe can specify an index position in the square brackets to extract specific items. This will return only the first (latest) `item`:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[0]'\r\n```\r\n\r\nWe can also slice the results and list the items with the first `n` items. This will return only the first three items:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3]'\r\n```\r\n\r\nImportant note - this returns an array (items surrounded in `[]`) while before, it was just several objects being printed to the terminal. To turn this back into a set of objects we can further manipulate, append `[]` to the command:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3][]'\r\n```\r\n\r\n![Showing the difference between the two commands above](https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/arrays-vs-object-list.png)\r\n\r\n## Displaying Specific Properties\r\n\r\nEven once you extract a list of items, we can extract just a single property by continuing to use the dot syntax:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3][].title'\r\n```\r\n\r\nIf we want to extract a single property from an array of objects, we can use `map`:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map(.title)'\r\n```\r\n\r\n![The terminal showing an array with three strings](https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/mapped-array-one-key.png)\r\n\r\nAs opposed to JSON documents, XML also has attributes (like HTML). To access these, we use the following syntax:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map(.enclosure.\"@url\")'\r\n```\r\n\r\nWant to create a new data structure? Here we create an object with just the `title` and `url`:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map({ title: .title, url: .enclosure.\"@url\" })'\r\n```\r\n\r\n![Terminal showing an array of three objects - each with a title and url](https://res.cloudinary.com/deepgram/image/upload/v1658494375/blog/2022/08/downloading-podcast-transcripts-from-terminal/new-structure.png)\r\n\r\n## Looping Through Objects\r\n\r\nObjects don't really exist in BASH - so looping through them and extracting values can be a bit tough. Thankfully, a working approach is presented by Start & Wayne's [Ruben Koster](https://www.starkandwayne.com/blog/bash-for-loop-over-json-array-using-jq/). Let's walk through it.\r\n\r\nFirstly, store the output from the previous step in a variable:\r\n\r\n```bash\r\nDATA=$(curl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map({ title: .title, url: .enclosure.\"@url\" })')\r\n```\r\n\r\nThis can now be addressed in your terminal as `$DATA`:\r\n\r\n```bash\r\necho $DATA\r\n# Array of objects with title and url will show here\r\n```\r\n\r\nIf you try and loop through this data, you'll notice something undesirable:\r\n\r\n![Every log is a string](https://res.cloudinary.com/deepgram/image/upload/v1658494373/blog/2022/08/downloading-podcast-transcripts-from-terminal/every-log-is-a-string.png)\r\n\r\nIf the whole payload is thought of as a string, this is looping through each word. This isn't what we want. The solution is to base64-encode the data, so it's only one string, then decode it in the loop with a helper function:\r\n\r\n```bash\r\nfor row in $(echo \"${DATA}\" | jq -r '.[] | @base64'); do\r\n    _jq() {\r\n        echo ${row} | base64 --decode | jq -r ${1}\r\n    }\r\n    url=$(_jq '.url')\r\n    title=$(_jq '.title')\r\n\r\n    echo $url, $title\r\ndone\r\n```\r\n\r\n## Transcribing Each Episode\r\n\r\nNow that each podcast item is available in a loop, with both the `url` and `title` properties individually addressable, we can generate a transcript using cURL. We go through it in more detail in our [recent blog post](https://blog.deepgram.com/saving-transcripts-from-terminal/).\r\n\r\nMake sure you replace `YOUR_DEEPGRAM_API_KEY` with your own Deepgram API Key.\r\n\r\n```bash\r\nDATA=$(curl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map({ title: .title, url: .enclosure.\"@url\" })')\r\nfor row in $(echo \"${DATA}\" | jq -r '.[] | @base64'); do\r\n    _jq() {\r\n        echo ${row} | base64 --decode | jq -r ${1}\r\n    }\r\n    RESPONSE=$(\r\n        curl -X POST \"https://api.deepgram.com/v1/listen?punctuate=true&tier=enhanced\" \\\r\n            -H \"Authorization: Token YOUR_DEEPGRAM_API_KEY\" \\\r\n            -H \"Content-Type: application/json\" \\\r\n            -d \"{\\\"url\\\":\\\"$(_jq '.url')\\\"}\"\r\n   )\r\n   echo $RESPONSE | jq '.results.channels[0].alternatives[0].transcript' > \"$(_jq '.title').txt\"\r\ndone\r\n```\r\n\r\nThis will create one text file for each episode.\r\n\r\n## Wrapping Up\r\n\r\n`jq` and `xq` are exceptionally powerful tools, even more so when combined with cURL requests. With minimal adjustment, you can begin to alter the podcast fetched, the number of transcripts generated, or include additional metadata about the episode in the generated file.\r\n\r\nIf you have any questions, feel free to reach out - we love to help!\r\n\r\n        ", "html": '<p>Every true podcast has a free and publicly available RSS feed that contains information about the show and each episode. In turn, those episode items include metadata about the show and a link to a hosted audio file. In this tutorial, we will download transcripts for the latest episodes of our favorite shows and store them in text files on our computer.</p>\n<h2 id="before-you-start">Before You Start</h2>\n<p>You will need a Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get one here</a>. You will also need to install <a href="https://stedolan.github.io/jq/">jq</a> and  <a href="https://kislyuk.github.io/yq/">yq</a> to traverse and manipulate XML in your terminal (the data format used for RSS feeds).</p>\n<p>This tutorial will be a set of building blocks, slowly growing in complexity towards our end goal. We\u2019ll take it slow and explain each step so you can apply this knowledge in other contexts, too.</p>\n<p>We\u2019ll use the <a href="https://www.npr.org/programs/morning-edition/">NPR Morning Edition</a> Podcast Feed: <a href="https://feeds.npr.org/510318/podcast.xml">https://feeds.npr.org/510318/podcast.xml</a>, but this can be swapped out for your favorite podcast.</p>\n<h2 id="getting-started">Getting Started</h2>\n<p>Open up your terminal and run the following:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml</span></span></code></pre>\n<p>This should display the full RSS feed - a bunch of XML (similar to HTML) containing information about the feed.</p>\n<h3 id="get-just-the-episode-items">Get Just The Episode Items</h3>\n<p>The structure of the XML includes an <code is:raw>rss</code> tag containing a <code is:raw>channel</code> tag. Inside of <code is:raw>channel</code> is a whole bunch of metadata tags for the show and a set of <code is:raw>item</code> tags for each episode. <code is:raw>item</code> tags are not inside of a containing list as we might expect with HTML - they are all direct children of <code is:raw>channel</code>. Try running the following command:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[]&#39;</span></span></code></pre>\n<p>This pipes the curl output into the <code is:raw>xq</code> command and extracts all of the <code is:raw>item</code> tags. It also pretty prints it in the terminal, which I find quite helpful when exploring the data. What is after the <code is:raw>xq</code> command in quotes is known as the \u2018expression.\u2019</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494374/blog/2022/08/downloading-podcast-transcripts-from-terminal/extract-items.png" alt="Terminal showing pretty-printed item data"></p>\n<h3 id="get-specific-items">Get Specific Items</h3>\n<p>We can specify an index position in the square brackets to extract specific items. This will return only the first (latest) <code is:raw>item</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[0]&#39;</span></span></code></pre>\n<p>We can also slice the results and list the items with the first <code is:raw>n</code> items. This will return only the first three items:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3]&#39;</span></span></code></pre>\n<p>Important note - this returns an array (items surrounded in <code is:raw>[]</code>) while before, it was just several objects being printed to the terminal. To turn this back into a set of objects we can further manipulate, append <code is:raw>[]</code> to the command:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3][]&#39;</span></span></code></pre>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/arrays-vs-object-list.png" alt="Showing the difference between the two commands above"></p>\n<h2 id="displaying-specific-properties">Displaying Specific Properties</h2>\n<p>Even once you extract a list of items, we can extract just a single property by continuing to use the dot syntax:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3][].title&#39;</span></span></code></pre>\n<p>If we want to extract a single property from an array of objects, we can use <code is:raw>map</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3] | map(.title)&#39;</span></span></code></pre>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/mapped-array-one-key.png" alt="The terminal showing an array with three strings"></p>\n<p>As opposed to JSON documents, XML also has attributes (like HTML). To access these, we use the following syntax:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3] | map(.enclosure.&quot;@url&quot;)&#39;</span></span></code></pre>\n<p>Want to create a new data structure? Here we create an object with just the <code is:raw>title</code> and <code is:raw>url</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3] | map({ title: .title, url: .enclosure.&quot;@url&quot; })&#39;</span></span></code></pre>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494375/blog/2022/08/downloading-podcast-transcripts-from-terminal/new-structure.png" alt="Terminal showing an array of three objects - each with a title and url"></p>\n<h2 id="looping-through-objects">Looping Through Objects</h2>\n<p>Objects don\u2019t really exist in BASH - so looping through them and extracting values can be a bit tough. Thankfully, a working approach is presented by Start & Wayne\u2019s <a href="https://www.starkandwayne.com/blog/bash-for-loop-over-json-array-using-jq/">Ruben Koster</a>. Let\u2019s walk through it.</p>\n<p>Firstly, store the output from the previous step in a variable:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">DATA=</span><span style="color: #A5D6FF">$(curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> xq &#39;.rss.channel.item[:3] | map({ title: .title, url: .enclosure.&quot;@url&quot; })&#39;)</span></span></code></pre>\n<p>This can now be addressed in your terminal as <code is:raw>$DATA</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> $DATA</span></span>\n<span class="line"><span style="color: #8B949E"># Array of objects with title and url will show here</span></span></code></pre>\n<p>If you try and loop through this data, you\u2019ll notice something undesirable:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494373/blog/2022/08/downloading-podcast-transcripts-from-terminal/every-log-is-a-string.png" alt="Every log is a string"></p>\n<p>If the whole payload is thought of as a string, this is looping through each word. This isn\u2019t what we want. The solution is to base64-encode the data, so it\u2019s only one string, then decode it in the loop with a helper function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> row </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">$(echo &quot;</span><span style="color: #C9D1D9">${DATA}</span><span style="color: #A5D6FF">&quot; </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> jq -r &#39;.[] | @base64&#39;)</span><span style="color: #FF7B72">;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">do</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">_jq</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> ${row} </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> base64 --decode </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> jq -r ${1}</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    url=</span><span style="color: #A5D6FF">$(_jq &#39;.url&#39;)</span></span>\n<span class="line"><span style="color: #C9D1D9">    title=</span><span style="color: #A5D6FF">$(_jq &#39;.title&#39;)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> $url, $title</span></span>\n<span class="line"><span style="color: #FF7B72">done</span></span></code></pre>\n<h2 id="transcribing-each-episode">Transcribing Each Episode</h2>\n<p>Now that each podcast item is available in a loop, with both the <code is:raw>url</code> and <code is:raw>title</code> properties individually addressable, we can generate a transcript using cURL. We go through it in more detail in our <a href="https://blog.deepgram.com/saving-transcripts-from-terminal/">recent blog post</a>.</p>\n<p>Make sure you replace <code is:raw>YOUR_DEEPGRAM_API_KEY</code> with your own Deepgram API Key.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">DATA=</span><span style="color: #A5D6FF">$(curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> xq &#39;.rss.channel.item[:3] | map({ title: .title, url: .enclosure.&quot;@url&quot; })&#39;)</span></span>\n<span class="line"><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> row </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">$(echo &quot;</span><span style="color: #C9D1D9">${DATA}</span><span style="color: #A5D6FF">&quot; </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> jq -r &#39;.[] | @base64&#39;)</span><span style="color: #FF7B72">;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">do</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">_jq</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> ${row} </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> base64 --decode </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> jq -r ${1}</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    RESPONSE=</span><span style="color: #A5D6FF">$(</span></span>\n<span class="line"><span style="color: #A5D6FF">        curl -X POST &quot;https://api.deepgram.com/v1/listen?punctuate=true&amp;tier=enhanced&quot; \\</span></span>\n<span class="line"><span style="color: #A5D6FF">            -H &quot;Authorization: Token YOUR_DEEPGRAM_API_KEY&quot; \\</span></span>\n<span class="line"><span style="color: #A5D6FF">            -H &quot;Content-Type: application/json&quot; \\</span></span>\n<span class="line"><span style="color: #A5D6FF">            -d &quot;{</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">url</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">:</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">$(_jq &#39;.url&#39;)</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">}&quot;</span></span>\n<span class="line"><span style="color: #A5D6FF">   )</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> $RESPONSE </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> jq </span><span style="color: #A5D6FF">&#39;.results.channels[0].alternatives[0].transcript&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;$(_jq &#39;.title&#39;).txt&quot;</span></span>\n<span class="line"><span style="color: #FF7B72">done</span></span></code></pre>\n<p>This will create one text file for each episode.</p>\n<h2 id="wrapping-up">Wrapping Up</h2>\n<p><code is:raw>jq</code> and <code is:raw>xq</code> are exceptionally powerful tools, even more so when combined with cURL requests. With minimal adjustment, you can begin to alter the podcast fetched, the number of transcripts generated, or include additional metadata about the episode in the generated file.</p>\n<p>If you have any questions, feel free to reach out - we love to help!</p>' };
const frontmatter = { "title": "Transcribing Podcast Feeds From Your Terminal", "description": "Using some terminal magic, learn how to fetch and transcribe podcast episodes. This is a beginner-friendly guide going through every step.", "date": "2022-08-25T00:00:00.000Z", "cover": "https://res.cloudinary.com/deepgram/image/upload/v1661184408/blog/2022/08/downloading-podcast-transcripts-from-terminal/2208-Transcribing-Podcast-Feeds-From-Your-Terminal-blog%402x.jpg", "authors": ["kevin-lewis"], "category": "tutorial", "tags": ["terminal", "podcast"], "seo": { "title": "Transcribing Podcast Feeds From Your Terminal", "description": "Using some terminal magic, learn how to fetch and transcribe podcast episodes. This is a beginner-friendly guide going through every step." }, "shorturls": { "share": "https://dpgr.am/88664b0", "twitter": "https://dpgr.am/9cbc75e", "linkedin": "https://dpgr.am/361b1a4", "reddit": "https://dpgr.am/afd4fa0", "facebook": "https://dpgr.am/1f11fd0" }, "og": { "image": "https://res.cloudinary.com/deepgram/image/upload/v1661541398/blog/downloading-podcast-transcripts-from-terminal/ograph.png" }, "astro": { "headings": [{ "depth": 2, "slug": "before-you-start", "text": "Before You Start" }, { "depth": 2, "slug": "getting-started", "text": "Getting Started" }, { "depth": 3, "slug": "get-just-the-episode-items", "text": "Get Just The Episode Items" }, { "depth": 3, "slug": "get-specific-items", "text": "Get Specific Items" }, { "depth": 2, "slug": "displaying-specific-properties", "text": "Displaying Specific Properties" }, { "depth": 2, "slug": "looping-through-objects", "text": "Looping Through Objects" }, { "depth": 2, "slug": "transcribing-each-episode", "text": "Transcribing Each Episode" }, { "depth": 2, "slug": "wrapping-up", "text": "Wrapping Up" }], "source": "\r\nEvery true podcast has a free and publicly available RSS feed that contains information about the show and each episode. In turn, those episode items include metadata about the show and a link to a hosted audio file. In this tutorial, we will download transcripts for the latest episodes of our favorite shows and store them in text files on our computer.\r\n\r\n## Before You Start\r\n\r\nYou will need a Deepgram API Key - [get one here](https://console.deepgram.com/signup?jump=keys). You will also need to install [jq](https://stedolan.github.io/jq/) and  [yq](https://kislyuk.github.io/yq/) to traverse and manipulate XML in your terminal (the data format used for RSS feeds).\r\n\r\nThis tutorial will be a set of building blocks, slowly growing in complexity towards our end goal. We'll take it slow and explain each step so you can apply this knowledge in other contexts, too.\r\n\r\nWe'll use the [NPR Morning Edition](https://www.npr.org/programs/morning-edition/) Podcast Feed: https://feeds.npr.org/510318/podcast.xml, but this can be swapped out for your favorite podcast.\r\n\r\n## Getting Started\r\n\r\nOpen up your terminal and run the following:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml\r\n```\r\n\r\nThis should display the full RSS feed - a bunch of XML (similar to HTML) containing information about the feed.\r\n\r\n### Get Just The Episode Items\r\n\r\nThe structure of the XML includes an `rss` tag containing a `channel` tag. Inside of `channel` is a whole bunch of metadata tags for the show and a set of `item` tags for each episode. `item` tags are not inside of a containing list as we might expect with HTML - they are all direct children of `channel`. Try running the following command:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[]'\r\n```\r\n\r\nThis pipes the curl output into the `xq` command and extracts all of the `item` tags. It also pretty prints it in the terminal, which I find quite helpful when exploring the data. What is after the `xq` command in quotes is known as the 'expression.'\r\n\r\n![Terminal showing pretty-printed item data](https://res.cloudinary.com/deepgram/image/upload/v1658494374/blog/2022/08/downloading-podcast-transcripts-from-terminal/extract-items.png)\r\n\r\n### Get Specific Items\r\n\r\nWe can specify an index position in the square brackets to extract specific items. This will return only the first (latest) `item`:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[0]'\r\n```\r\n\r\nWe can also slice the results and list the items with the first `n` items. This will return only the first three items:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3]'\r\n```\r\n\r\nImportant note - this returns an array (items surrounded in `[]`) while before, it was just several objects being printed to the terminal. To turn this back into a set of objects we can further manipulate, append `[]` to the command:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3][]'\r\n```\r\n\r\n![Showing the difference between the two commands above](https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/arrays-vs-object-list.png)\r\n\r\n## Displaying Specific Properties\r\n\r\nEven once you extract a list of items, we can extract just a single property by continuing to use the dot syntax:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3][].title'\r\n```\r\n\r\nIf we want to extract a single property from an array of objects, we can use `map`:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map(.title)'\r\n```\r\n\r\n![The terminal showing an array with three strings](https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/mapped-array-one-key.png)\r\n\r\nAs opposed to JSON documents, XML also has attributes (like HTML). To access these, we use the following syntax:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map(.enclosure.\"@url\")'\r\n```\r\n\r\nWant to create a new data structure? Here we create an object with just the `title` and `url`:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map({ title: .title, url: .enclosure.\"@url\" })'\r\n```\r\n\r\n![Terminal showing an array of three objects - each with a title and url](https://res.cloudinary.com/deepgram/image/upload/v1658494375/blog/2022/08/downloading-podcast-transcripts-from-terminal/new-structure.png)\r\n\r\n## Looping Through Objects\r\n\r\nObjects don't really exist in BASH - so looping through them and extracting values can be a bit tough. Thankfully, a working approach is presented by Start & Wayne's [Ruben Koster](https://www.starkandwayne.com/blog/bash-for-loop-over-json-array-using-jq/). Let's walk through it.\r\n\r\nFirstly, store the output from the previous step in a variable:\r\n\r\n```bash\r\nDATA=$(curl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map({ title: .title, url: .enclosure.\"@url\" })')\r\n```\r\n\r\nThis can now be addressed in your terminal as `$DATA`:\r\n\r\n```bash\r\necho $DATA\r\n# Array of objects with title and url will show here\r\n```\r\n\r\nIf you try and loop through this data, you'll notice something undesirable:\r\n\r\n![Every log is a string](https://res.cloudinary.com/deepgram/image/upload/v1658494373/blog/2022/08/downloading-podcast-transcripts-from-terminal/every-log-is-a-string.png)\r\n\r\nIf the whole payload is thought of as a string, this is looping through each word. This isn't what we want. The solution is to base64-encode the data, so it's only one string, then decode it in the loop with a helper function:\r\n\r\n```bash\r\nfor row in $(echo \"${DATA}\" | jq -r '.[] | @base64'); do\r\n    _jq() {\r\n        echo ${row} | base64 --decode | jq -r ${1}\r\n    }\r\n    url=$(_jq '.url')\r\n    title=$(_jq '.title')\r\n\r\n    echo $url, $title\r\ndone\r\n```\r\n\r\n## Transcribing Each Episode\r\n\r\nNow that each podcast item is available in a loop, with both the `url` and `title` properties individually addressable, we can generate a transcript using cURL. We go through it in more detail in our [recent blog post](https://blog.deepgram.com/saving-transcripts-from-terminal/).\r\n\r\nMake sure you replace `YOUR_DEEPGRAM_API_KEY` with your own Deepgram API Key.\r\n\r\n```bash\r\nDATA=$(curl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map({ title: .title, url: .enclosure.\"@url\" })')\r\nfor row in $(echo \"${DATA}\" | jq -r '.[] | @base64'); do\r\n    _jq() {\r\n        echo ${row} | base64 --decode | jq -r ${1}\r\n    }\r\n    RESPONSE=$(\r\n        curl -X POST \"https://api.deepgram.com/v1/listen?punctuate=true&tier=enhanced\" \\\r\n            -H \"Authorization: Token YOUR_DEEPGRAM_API_KEY\" \\\r\n            -H \"Content-Type: application/json\" \\\r\n            -d \"{\\\"url\\\":\\\"$(_jq '.url')\\\"}\"\r\n   )\r\n   echo $RESPONSE | jq '.results.channels[0].alternatives[0].transcript' > \"$(_jq '.title').txt\"\r\ndone\r\n```\r\n\r\nThis will create one text file for each episode.\r\n\r\n## Wrapping Up\r\n\r\n`jq` and `xq` are exceptionally powerful tools, even more so when combined with cURL requests. With minimal adjustment, you can begin to alter the podcast fetched, the number of transcripts generated, or include additional metadata about the episode in the generated file.\r\n\r\nIf you have any questions, feel free to reach out - we love to help!\r\n\r\n        ", "html": '<p>Every true podcast has a free and publicly available RSS feed that contains information about the show and each episode. In turn, those episode items include metadata about the show and a link to a hosted audio file. In this tutorial, we will download transcripts for the latest episodes of our favorite shows and store them in text files on our computer.</p>\n<h2 id="before-you-start">Before You Start</h2>\n<p>You will need a Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get one here</a>. You will also need to install <a href="https://stedolan.github.io/jq/">jq</a> and  <a href="https://kislyuk.github.io/yq/">yq</a> to traverse and manipulate XML in your terminal (the data format used for RSS feeds).</p>\n<p>This tutorial will be a set of building blocks, slowly growing in complexity towards our end goal. We\u2019ll take it slow and explain each step so you can apply this knowledge in other contexts, too.</p>\n<p>We\u2019ll use the <a href="https://www.npr.org/programs/morning-edition/">NPR Morning Edition</a> Podcast Feed: <a href="https://feeds.npr.org/510318/podcast.xml">https://feeds.npr.org/510318/podcast.xml</a>, but this can be swapped out for your favorite podcast.</p>\n<h2 id="getting-started">Getting Started</h2>\n<p>Open up your terminal and run the following:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml</span></span></code></pre>\n<p>This should display the full RSS feed - a bunch of XML (similar to HTML) containing information about the feed.</p>\n<h3 id="get-just-the-episode-items">Get Just The Episode Items</h3>\n<p>The structure of the XML includes an <code is:raw>rss</code> tag containing a <code is:raw>channel</code> tag. Inside of <code is:raw>channel</code> is a whole bunch of metadata tags for the show and a set of <code is:raw>item</code> tags for each episode. <code is:raw>item</code> tags are not inside of a containing list as we might expect with HTML - they are all direct children of <code is:raw>channel</code>. Try running the following command:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[]&#39;</span></span></code></pre>\n<p>This pipes the curl output into the <code is:raw>xq</code> command and extracts all of the <code is:raw>item</code> tags. It also pretty prints it in the terminal, which I find quite helpful when exploring the data. What is after the <code is:raw>xq</code> command in quotes is known as the \u2018expression.\u2019</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494374/blog/2022/08/downloading-podcast-transcripts-from-terminal/extract-items.png" alt="Terminal showing pretty-printed item data"></p>\n<h3 id="get-specific-items">Get Specific Items</h3>\n<p>We can specify an index position in the square brackets to extract specific items. This will return only the first (latest) <code is:raw>item</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[0]&#39;</span></span></code></pre>\n<p>We can also slice the results and list the items with the first <code is:raw>n</code> items. This will return only the first three items:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3]&#39;</span></span></code></pre>\n<p>Important note - this returns an array (items surrounded in <code is:raw>[]</code>) while before, it was just several objects being printed to the terminal. To turn this back into a set of objects we can further manipulate, append <code is:raw>[]</code> to the command:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3][]&#39;</span></span></code></pre>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/arrays-vs-object-list.png" alt="Showing the difference between the two commands above"></p>\n<h2 id="displaying-specific-properties">Displaying Specific Properties</h2>\n<p>Even once you extract a list of items, we can extract just a single property by continuing to use the dot syntax:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3][].title&#39;</span></span></code></pre>\n<p>If we want to extract a single property from an array of objects, we can use <code is:raw>map</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3] | map(.title)&#39;</span></span></code></pre>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/mapped-array-one-key.png" alt="The terminal showing an array with three strings"></p>\n<p>As opposed to JSON documents, XML also has attributes (like HTML). To access these, we use the following syntax:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3] | map(.enclosure.&quot;@url&quot;)&#39;</span></span></code></pre>\n<p>Want to create a new data structure? Here we create an object with just the <code is:raw>title</code> and <code is:raw>url</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3] | map({ title: .title, url: .enclosure.&quot;@url&quot; })&#39;</span></span></code></pre>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494375/blog/2022/08/downloading-podcast-transcripts-from-terminal/new-structure.png" alt="Terminal showing an array of three objects - each with a title and url"></p>\n<h2 id="looping-through-objects">Looping Through Objects</h2>\n<p>Objects don\u2019t really exist in BASH - so looping through them and extracting values can be a bit tough. Thankfully, a working approach is presented by Start & Wayne\u2019s <a href="https://www.starkandwayne.com/blog/bash-for-loop-over-json-array-using-jq/">Ruben Koster</a>. Let\u2019s walk through it.</p>\n<p>Firstly, store the output from the previous step in a variable:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">DATA=</span><span style="color: #A5D6FF">$(curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> xq &#39;.rss.channel.item[:3] | map({ title: .title, url: .enclosure.&quot;@url&quot; })&#39;)</span></span></code></pre>\n<p>This can now be addressed in your terminal as <code is:raw>$DATA</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> $DATA</span></span>\n<span class="line"><span style="color: #8B949E"># Array of objects with title and url will show here</span></span></code></pre>\n<p>If you try and loop through this data, you\u2019ll notice something undesirable:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494373/blog/2022/08/downloading-podcast-transcripts-from-terminal/every-log-is-a-string.png" alt="Every log is a string"></p>\n<p>If the whole payload is thought of as a string, this is looping through each word. This isn\u2019t what we want. The solution is to base64-encode the data, so it\u2019s only one string, then decode it in the loop with a helper function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> row </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">$(echo &quot;</span><span style="color: #C9D1D9">${DATA}</span><span style="color: #A5D6FF">&quot; </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> jq -r &#39;.[] | @base64&#39;)</span><span style="color: #FF7B72">;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">do</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">_jq</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> ${row} </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> base64 --decode </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> jq -r ${1}</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    url=</span><span style="color: #A5D6FF">$(_jq &#39;.url&#39;)</span></span>\n<span class="line"><span style="color: #C9D1D9">    title=</span><span style="color: #A5D6FF">$(_jq &#39;.title&#39;)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> $url, $title</span></span>\n<span class="line"><span style="color: #FF7B72">done</span></span></code></pre>\n<h2 id="transcribing-each-episode">Transcribing Each Episode</h2>\n<p>Now that each podcast item is available in a loop, with both the <code is:raw>url</code> and <code is:raw>title</code> properties individually addressable, we can generate a transcript using cURL. We go through it in more detail in our <a href="https://blog.deepgram.com/saving-transcripts-from-terminal/">recent blog post</a>.</p>\n<p>Make sure you replace <code is:raw>YOUR_DEEPGRAM_API_KEY</code> with your own Deepgram API Key.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">DATA=</span><span style="color: #A5D6FF">$(curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> xq &#39;.rss.channel.item[:3] | map({ title: .title, url: .enclosure.&quot;@url&quot; })&#39;)</span></span>\n<span class="line"><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> row </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">$(echo &quot;</span><span style="color: #C9D1D9">${DATA}</span><span style="color: #A5D6FF">&quot; </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> jq -r &#39;.[] | @base64&#39;)</span><span style="color: #FF7B72">;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">do</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">_jq</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> ${row} </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> base64 --decode </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> jq -r ${1}</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    RESPONSE=</span><span style="color: #A5D6FF">$(</span></span>\n<span class="line"><span style="color: #A5D6FF">        curl -X POST &quot;https://api.deepgram.com/v1/listen?punctuate=true&amp;tier=enhanced&quot; \\</span></span>\n<span class="line"><span style="color: #A5D6FF">            -H &quot;Authorization: Token YOUR_DEEPGRAM_API_KEY&quot; \\</span></span>\n<span class="line"><span style="color: #A5D6FF">            -H &quot;Content-Type: application/json&quot; \\</span></span>\n<span class="line"><span style="color: #A5D6FF">            -d &quot;{</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">url</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">:</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">$(_jq &#39;.url&#39;)</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">}&quot;</span></span>\n<span class="line"><span style="color: #A5D6FF">   )</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> $RESPONSE </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> jq </span><span style="color: #A5D6FF">&#39;.results.channels[0].alternatives[0].transcript&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;$(_jq &#39;.title&#39;).txt&quot;</span></span>\n<span class="line"><span style="color: #FF7B72">done</span></span></code></pre>\n<p>This will create one text file for each episode.</p>\n<h2 id="wrapping-up">Wrapping Up</h2>\n<p><code is:raw>jq</code> and <code is:raw>xq</code> are exceptionally powerful tools, even more so when combined with cURL requests. With minimal adjustment, you can begin to alter the podcast fetched, the number of transcripts generated, or include additional metadata about the episode in the generated file.</p>\n<p>If you have any questions, feel free to reach out - we love to help!</p>' }, "file": "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/downloading-podcast-transcripts-from-terminal/index.md" };
function rawContent() {
  return "\r\nEvery true podcast has a free and publicly available RSS feed that contains information about the show and each episode. In turn, those episode items include metadata about the show and a link to a hosted audio file. In this tutorial, we will download transcripts for the latest episodes of our favorite shows and store them in text files on our computer.\r\n\r\n## Before You Start\r\n\r\nYou will need a Deepgram API Key - [get one here](https://console.deepgram.com/signup?jump=keys). You will also need to install [jq](https://stedolan.github.io/jq/) and  [yq](https://kislyuk.github.io/yq/) to traverse and manipulate XML in your terminal (the data format used for RSS feeds).\r\n\r\nThis tutorial will be a set of building blocks, slowly growing in complexity towards our end goal. We'll take it slow and explain each step so you can apply this knowledge in other contexts, too.\r\n\r\nWe'll use the [NPR Morning Edition](https://www.npr.org/programs/morning-edition/) Podcast Feed: https://feeds.npr.org/510318/podcast.xml, but this can be swapped out for your favorite podcast.\r\n\r\n## Getting Started\r\n\r\nOpen up your terminal and run the following:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml\r\n```\r\n\r\nThis should display the full RSS feed - a bunch of XML (similar to HTML) containing information about the feed.\r\n\r\n### Get Just The Episode Items\r\n\r\nThe structure of the XML includes an `rss` tag containing a `channel` tag. Inside of `channel` is a whole bunch of metadata tags for the show and a set of `item` tags for each episode. `item` tags are not inside of a containing list as we might expect with HTML - they are all direct children of `channel`. Try running the following command:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[]'\r\n```\r\n\r\nThis pipes the curl output into the `xq` command and extracts all of the `item` tags. It also pretty prints it in the terminal, which I find quite helpful when exploring the data. What is after the `xq` command in quotes is known as the 'expression.'\r\n\r\n![Terminal showing pretty-printed item data](https://res.cloudinary.com/deepgram/image/upload/v1658494374/blog/2022/08/downloading-podcast-transcripts-from-terminal/extract-items.png)\r\n\r\n### Get Specific Items\r\n\r\nWe can specify an index position in the square brackets to extract specific items. This will return only the first (latest) `item`:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[0]'\r\n```\r\n\r\nWe can also slice the results and list the items with the first `n` items. This will return only the first three items:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3]'\r\n```\r\n\r\nImportant note - this returns an array (items surrounded in `[]`) while before, it was just several objects being printed to the terminal. To turn this back into a set of objects we can further manipulate, append `[]` to the command:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3][]'\r\n```\r\n\r\n![Showing the difference between the two commands above](https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/arrays-vs-object-list.png)\r\n\r\n## Displaying Specific Properties\r\n\r\nEven once you extract a list of items, we can extract just a single property by continuing to use the dot syntax:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3][].title'\r\n```\r\n\r\nIf we want to extract a single property from an array of objects, we can use `map`:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map(.title)'\r\n```\r\n\r\n![The terminal showing an array with three strings](https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/mapped-array-one-key.png)\r\n\r\nAs opposed to JSON documents, XML also has attributes (like HTML). To access these, we use the following syntax:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map(.enclosure.\"@url\")'\r\n```\r\n\r\nWant to create a new data structure? Here we create an object with just the `title` and `url`:\r\n\r\n```bash\r\ncurl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map({ title: .title, url: .enclosure.\"@url\" })'\r\n```\r\n\r\n![Terminal showing an array of three objects - each with a title and url](https://res.cloudinary.com/deepgram/image/upload/v1658494375/blog/2022/08/downloading-podcast-transcripts-from-terminal/new-structure.png)\r\n\r\n## Looping Through Objects\r\n\r\nObjects don't really exist in BASH - so looping through them and extracting values can be a bit tough. Thankfully, a working approach is presented by Start & Wayne's [Ruben Koster](https://www.starkandwayne.com/blog/bash-for-loop-over-json-array-using-jq/). Let's walk through it.\r\n\r\nFirstly, store the output from the previous step in a variable:\r\n\r\n```bash\r\nDATA=$(curl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map({ title: .title, url: .enclosure.\"@url\" })')\r\n```\r\n\r\nThis can now be addressed in your terminal as `$DATA`:\r\n\r\n```bash\r\necho $DATA\r\n# Array of objects with title and url will show here\r\n```\r\n\r\nIf you try and loop through this data, you'll notice something undesirable:\r\n\r\n![Every log is a string](https://res.cloudinary.com/deepgram/image/upload/v1658494373/blog/2022/08/downloading-podcast-transcripts-from-terminal/every-log-is-a-string.png)\r\n\r\nIf the whole payload is thought of as a string, this is looping through each word. This isn't what we want. The solution is to base64-encode the data, so it's only one string, then decode it in the loop with a helper function:\r\n\r\n```bash\r\nfor row in $(echo \"${DATA}\" | jq -r '.[] | @base64'); do\r\n    _jq() {\r\n        echo ${row} | base64 --decode | jq -r ${1}\r\n    }\r\n    url=$(_jq '.url')\r\n    title=$(_jq '.title')\r\n\r\n    echo $url, $title\r\ndone\r\n```\r\n\r\n## Transcribing Each Episode\r\n\r\nNow that each podcast item is available in a loop, with both the `url` and `title` properties individually addressable, we can generate a transcript using cURL. We go through it in more detail in our [recent blog post](https://blog.deepgram.com/saving-transcripts-from-terminal/).\r\n\r\nMake sure you replace `YOUR_DEEPGRAM_API_KEY` with your own Deepgram API Key.\r\n\r\n```bash\r\nDATA=$(curl https://feeds.npr.org/510318/podcast.xml | xq '.rss.channel.item[:3] | map({ title: .title, url: .enclosure.\"@url\" })')\r\nfor row in $(echo \"${DATA}\" | jq -r '.[] | @base64'); do\r\n    _jq() {\r\n        echo ${row} | base64 --decode | jq -r ${1}\r\n    }\r\n    RESPONSE=$(\r\n        curl -X POST \"https://api.deepgram.com/v1/listen?punctuate=true&tier=enhanced\" \\\r\n            -H \"Authorization: Token YOUR_DEEPGRAM_API_KEY\" \\\r\n            -H \"Content-Type: application/json\" \\\r\n            -d \"{\\\"url\\\":\\\"$(_jq '.url')\\\"}\"\r\n   )\r\n   echo $RESPONSE | jq '.results.channels[0].alternatives[0].transcript' > \"$(_jq '.title').txt\"\r\ndone\r\n```\r\n\r\nThis will create one text file for each episode.\r\n\r\n## Wrapping Up\r\n\r\n`jq` and `xq` are exceptionally powerful tools, even more so when combined with cURL requests. With minimal adjustment, you can begin to alter the podcast fetched, the number of transcripts generated, or include additional metadata about the episode in the generated file.\r\n\r\nIf you have any questions, feel free to reach out - we love to help!\r\n\r\n        ";
}
function compiledContent() {
  return '<p>Every true podcast has a free and publicly available RSS feed that contains information about the show and each episode. In turn, those episode items include metadata about the show and a link to a hosted audio file. In this tutorial, we will download transcripts for the latest episodes of our favorite shows and store them in text files on our computer.</p>\n<h2 id="before-you-start">Before You Start</h2>\n<p>You will need a Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get one here</a>. You will also need to install <a href="https://stedolan.github.io/jq/">jq</a> and  <a href="https://kislyuk.github.io/yq/">yq</a> to traverse and manipulate XML in your terminal (the data format used for RSS feeds).</p>\n<p>This tutorial will be a set of building blocks, slowly growing in complexity towards our end goal. We\u2019ll take it slow and explain each step so you can apply this knowledge in other contexts, too.</p>\n<p>We\u2019ll use the <a href="https://www.npr.org/programs/morning-edition/">NPR Morning Edition</a> Podcast Feed: <a href="https://feeds.npr.org/510318/podcast.xml">https://feeds.npr.org/510318/podcast.xml</a>, but this can be swapped out for your favorite podcast.</p>\n<h2 id="getting-started">Getting Started</h2>\n<p>Open up your terminal and run the following:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml</span></span></code></pre>\n<p>This should display the full RSS feed - a bunch of XML (similar to HTML) containing information about the feed.</p>\n<h3 id="get-just-the-episode-items">Get Just The Episode Items</h3>\n<p>The structure of the XML includes an <code is:raw>rss</code> tag containing a <code is:raw>channel</code> tag. Inside of <code is:raw>channel</code> is a whole bunch of metadata tags for the show and a set of <code is:raw>item</code> tags for each episode. <code is:raw>item</code> tags are not inside of a containing list as we might expect with HTML - they are all direct children of <code is:raw>channel</code>. Try running the following command:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[]&#39;</span></span></code></pre>\n<p>This pipes the curl output into the <code is:raw>xq</code> command and extracts all of the <code is:raw>item</code> tags. It also pretty prints it in the terminal, which I find quite helpful when exploring the data. What is after the <code is:raw>xq</code> command in quotes is known as the \u2018expression.\u2019</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494374/blog/2022/08/downloading-podcast-transcripts-from-terminal/extract-items.png" alt="Terminal showing pretty-printed item data"></p>\n<h3 id="get-specific-items">Get Specific Items</h3>\n<p>We can specify an index position in the square brackets to extract specific items. This will return only the first (latest) <code is:raw>item</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[0]&#39;</span></span></code></pre>\n<p>We can also slice the results and list the items with the first <code is:raw>n</code> items. This will return only the first three items:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3]&#39;</span></span></code></pre>\n<p>Important note - this returns an array (items surrounded in <code is:raw>[]</code>) while before, it was just several objects being printed to the terminal. To turn this back into a set of objects we can further manipulate, append <code is:raw>[]</code> to the command:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3][]&#39;</span></span></code></pre>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/arrays-vs-object-list.png" alt="Showing the difference between the two commands above"></p>\n<h2 id="displaying-specific-properties">Displaying Specific Properties</h2>\n<p>Even once you extract a list of items, we can extract just a single property by continuing to use the dot syntax:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3][].title&#39;</span></span></code></pre>\n<p>If we want to extract a single property from an array of objects, we can use <code is:raw>map</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3] | map(.title)&#39;</span></span></code></pre>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/mapped-array-one-key.png" alt="The terminal showing an array with three strings"></p>\n<p>As opposed to JSON documents, XML also has attributes (like HTML). To access these, we use the following syntax:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3] | map(.enclosure.&quot;@url&quot;)&#39;</span></span></code></pre>\n<p>Want to create a new data structure? Here we create an object with just the <code is:raw>title</code> and <code is:raw>url</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3] | map({ title: .title, url: .enclosure.&quot;@url&quot; })&#39;</span></span></code></pre>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494375/blog/2022/08/downloading-podcast-transcripts-from-terminal/new-structure.png" alt="Terminal showing an array of three objects - each with a title and url"></p>\n<h2 id="looping-through-objects">Looping Through Objects</h2>\n<p>Objects don\u2019t really exist in BASH - so looping through them and extracting values can be a bit tough. Thankfully, a working approach is presented by Start & Wayne\u2019s <a href="https://www.starkandwayne.com/blog/bash-for-loop-over-json-array-using-jq/">Ruben Koster</a>. Let\u2019s walk through it.</p>\n<p>Firstly, store the output from the previous step in a variable:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">DATA=</span><span style="color: #A5D6FF">$(curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> xq &#39;.rss.channel.item[:3] | map({ title: .title, url: .enclosure.&quot;@url&quot; })&#39;)</span></span></code></pre>\n<p>This can now be addressed in your terminal as <code is:raw>$DATA</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> $DATA</span></span>\n<span class="line"><span style="color: #8B949E"># Array of objects with title and url will show here</span></span></code></pre>\n<p>If you try and loop through this data, you\u2019ll notice something undesirable:</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494373/blog/2022/08/downloading-podcast-transcripts-from-terminal/every-log-is-a-string.png" alt="Every log is a string"></p>\n<p>If the whole payload is thought of as a string, this is looping through each word. This isn\u2019t what we want. The solution is to base64-encode the data, so it\u2019s only one string, then decode it in the loop with a helper function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> row </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">$(echo &quot;</span><span style="color: #C9D1D9">${DATA}</span><span style="color: #A5D6FF">&quot; </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> jq -r &#39;.[] | @base64&#39;)</span><span style="color: #FF7B72">;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">do</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">_jq</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> ${row} </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> base64 --decode </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> jq -r ${1}</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    url=</span><span style="color: #A5D6FF">$(_jq &#39;.url&#39;)</span></span>\n<span class="line"><span style="color: #C9D1D9">    title=</span><span style="color: #A5D6FF">$(_jq &#39;.title&#39;)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> $url, $title</span></span>\n<span class="line"><span style="color: #FF7B72">done</span></span></code></pre>\n<h2 id="transcribing-each-episode">Transcribing Each Episode</h2>\n<p>Now that each podcast item is available in a loop, with both the <code is:raw>url</code> and <code is:raw>title</code> properties individually addressable, we can generate a transcript using cURL. We go through it in more detail in our <a href="https://blog.deepgram.com/saving-transcripts-from-terminal/">recent blog post</a>.</p>\n<p>Make sure you replace <code is:raw>YOUR_DEEPGRAM_API_KEY</code> with your own Deepgram API Key.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">DATA=</span><span style="color: #A5D6FF">$(curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> xq &#39;.rss.channel.item[:3] | map({ title: .title, url: .enclosure.&quot;@url&quot; })&#39;)</span></span>\n<span class="line"><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> row </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">$(echo &quot;</span><span style="color: #C9D1D9">${DATA}</span><span style="color: #A5D6FF">&quot; </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> jq -r &#39;.[] | @base64&#39;)</span><span style="color: #FF7B72">;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">do</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">_jq</span><span style="color: #C9D1D9">() {</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> ${row} </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> base64 --decode </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> jq -r ${1}</span></span>\n<span class="line"><span style="color: #C9D1D9">    }</span></span>\n<span class="line"><span style="color: #C9D1D9">    RESPONSE=</span><span style="color: #A5D6FF">$(</span></span>\n<span class="line"><span style="color: #A5D6FF">        curl -X POST &quot;https://api.deepgram.com/v1/listen?punctuate=true&amp;tier=enhanced&quot; \\</span></span>\n<span class="line"><span style="color: #A5D6FF">            -H &quot;Authorization: Token YOUR_DEEPGRAM_API_KEY&quot; \\</span></span>\n<span class="line"><span style="color: #A5D6FF">            -H &quot;Content-Type: application/json&quot; \\</span></span>\n<span class="line"><span style="color: #A5D6FF">            -d &quot;{</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">url</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">:</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">$(_jq &#39;.url&#39;)</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">}&quot;</span></span>\n<span class="line"><span style="color: #A5D6FF">   )</span></span>\n<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> $RESPONSE </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> jq </span><span style="color: #A5D6FF">&#39;.results.channels[0].alternatives[0].transcript&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;$(_jq &#39;.title&#39;).txt&quot;</span></span>\n<span class="line"><span style="color: #FF7B72">done</span></span></code></pre>\n<p>This will create one text file for each episode.</p>\n<h2 id="wrapping-up">Wrapping Up</h2>\n<p><code is:raw>jq</code> and <code is:raw>xq</code> are exceptionally powerful tools, even more so when combined with cURL requests. With minimal adjustment, you can begin to alter the podcast fetched, the number of transcripts generated, or include additional metadata about the episode in the generated file.</p>\n<p>If you have any questions, feel free to reach out - we love to help!</p>';
}
const $$Astro = createAstro("/Users/sandrarodgers/web-next/blog/src/content/blog/posts/downloading-podcast-transcripts-from-terminal/index.md", "", "file:///Users/sandrarodgers/web-next/blog/");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  new Slugger();
  return renderTemplate`<head>${renderHead($$result)}</head><p>Every true podcast has a free and publicly available RSS feed that contains information about the show and each episode. In turn, those episode items include metadata about the show and a link to a hosted audio file. In this tutorial, we will download transcripts for the latest episodes of our favorite shows and store them in text files on our computer.</p>
<h2 id="before-you-start">Before You Start</h2>
<p>You will need a Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get one here</a>. You will also need to install <a href="https://stedolan.github.io/jq/">jq</a> and  <a href="https://kislyuk.github.io/yq/">yq</a> to traverse and manipulate XML in your terminal (the data format used for RSS feeds).</p>
<p>This tutorial will be a set of building blocks, slowly growing in complexity towards our end goal. We’ll take it slow and explain each step so you can apply this knowledge in other contexts, too.</p>
<p>We’ll use the <a href="https://www.npr.org/programs/morning-edition/">NPR Morning Edition</a> Podcast Feed: <a href="https://feeds.npr.org/510318/podcast.xml">https://feeds.npr.org/510318/podcast.xml</a>, but this can be swapped out for your favorite podcast.</p>
<h2 id="getting-started">Getting Started</h2>
<p>Open up your terminal and run the following:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml</span></span></code></pre>
<p>This should display the full RSS feed - a bunch of XML (similar to HTML) containing information about the feed.</p>
<h3 id="get-just-the-episode-items">Get Just The Episode Items</h3>
<p>The structure of the XML includes an <code>rss</code> tag containing a <code>channel</code> tag. Inside of <code>channel</code> is a whole bunch of metadata tags for the show and a set of <code>item</code> tags for each episode. <code>item</code> tags are not inside of a containing list as we might expect with HTML - they are all direct children of <code>channel</code>. Try running the following command:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[]&#39;</span></span></code></pre>
<p>This pipes the curl output into the <code>xq</code> command and extracts all of the <code>item</code> tags. It also pretty prints it in the terminal, which I find quite helpful when exploring the data. What is after the <code>xq</code> command in quotes is known as the ‘expression.’</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494374/blog/2022/08/downloading-podcast-transcripts-from-terminal/extract-items.png" alt="Terminal showing pretty-printed item data"></p>
<h3 id="get-specific-items">Get Specific Items</h3>
<p>We can specify an index position in the square brackets to extract specific items. This will return only the first (latest) <code>item</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[0]&#39;</span></span></code></pre>
<p>We can also slice the results and list the items with the first <code>n</code> items. This will return only the first three items:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3]&#39;</span></span></code></pre>
<p>Important note - this returns an array (items surrounded in <code>[]</code>) while before, it was just several objects being printed to the terminal. To turn this back into a set of objects we can further manipulate, append <code>[]</code> to the command:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3][]&#39;</span></span></code></pre>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/arrays-vs-object-list.png" alt="Showing the difference between the two commands above"></p>
<h2 id="displaying-specific-properties">Displaying Specific Properties</h2>
<p>Even once you extract a list of items, we can extract just a single property by continuing to use the dot syntax:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3][].title&#39;</span></span></code></pre>
<p>If we want to extract a single property from an array of objects, we can use <code>map</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3] | map(.title)&#39;</span></span></code></pre>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494371/blog/2022/08/downloading-podcast-transcripts-from-terminal/mapped-array-one-key.png" alt="The terminal showing an array with three strings"></p>
<p>As opposed to JSON documents, XML also has attributes (like HTML). To access these, we use the following syntax:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3] | map(.enclosure.&quot;@url&quot;)&#39;</span></span></code></pre>
<p>Want to create a new data structure? Here we create an object with just the <code>title</code> and <code>url</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> xq </span><span style="color: #A5D6FF">&#39;.rss.channel.item[:3] | map({ title: .title, url: .enclosure.&quot;@url&quot; })&#39;</span></span></code></pre>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494375/blog/2022/08/downloading-podcast-transcripts-from-terminal/new-structure.png" alt="Terminal showing an array of three objects - each with a title and url"></p>
<h2 id="looping-through-objects">Looping Through Objects</h2>
<p>Objects don’t really exist in BASH - so looping through them and extracting values can be a bit tough. Thankfully, a working approach is presented by Start & Wayne’s <a href="https://www.starkandwayne.com/blog/bash-for-loop-over-json-array-using-jq/">Ruben Koster</a>. Let’s walk through it.</p>
<p>Firstly, store the output from the previous step in a variable:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">DATA=</span><span style="color: #A5D6FF">$(curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> xq &#39;.rss.channel.item[:3] | map({ title: .title, url: .enclosure.&quot;@url&quot; })&#39;)</span></span></code></pre>
<p>This can now be addressed in your terminal as <code>$DATA</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> $DATA</span></span>
<span class="line"><span style="color: #8B949E"># Array of objects with title and url will show here</span></span></code></pre>
<p>If you try and loop through this data, you’ll notice something undesirable:</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1658494373/blog/2022/08/downloading-podcast-transcripts-from-terminal/every-log-is-a-string.png" alt="Every log is a string"></p>
<p>If the whole payload is thought of as a string, this is looping through each word. This isn’t what we want. The solution is to base64-encode the data, so it’s only one string, then decode it in the loop with a helper function:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> row </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">$(echo &quot;</span><span style="color: #C9D1D9">\${DATA}</span><span style="color: #A5D6FF">&quot; </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> jq -r &#39;.[] | @base64&#39;)</span><span style="color: #FF7B72">;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">do</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">_jq</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> \${row} </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> base64 --decode </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> jq -r \${1}</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    url=</span><span style="color: #A5D6FF">$(_jq &#39;.url&#39;)</span></span>
<span class="line"><span style="color: #C9D1D9">    title=</span><span style="color: #A5D6FF">$(_jq &#39;.title&#39;)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> $url, $title</span></span>
<span class="line"><span style="color: #FF7B72">done</span></span></code></pre>
<h2 id="transcribing-each-episode">Transcribing Each Episode</h2>
<p>Now that each podcast item is available in a loop, with both the <code>url</code> and <code>title</code> properties individually addressable, we can generate a transcript using cURL. We go through it in more detail in our <a href="https://blog.deepgram.com/saving-transcripts-from-terminal/">recent blog post</a>.</p>
<p>Make sure you replace <code>YOUR_DEEPGRAM_API_KEY</code> with your own Deepgram API Key.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">DATA=</span><span style="color: #A5D6FF">$(curl https://feeds.npr.org/510318/podcast.xml </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> xq &#39;.rss.channel.item[:3] | map({ title: .title, url: .enclosure.&quot;@url&quot; })&#39;)</span></span>
<span class="line"><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> row </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">$(echo &quot;</span><span style="color: #C9D1D9">\${DATA}</span><span style="color: #A5D6FF">&quot; </span><span style="color: #FF7B72">|</span><span style="color: #A5D6FF"> jq -r &#39;.[] | @base64&#39;)</span><span style="color: #FF7B72">;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">do</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">_jq</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> \${row} </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> base64 --decode </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> jq -r \${1}</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    RESPONSE=</span><span style="color: #A5D6FF">$(</span></span>
<span class="line"><span style="color: #A5D6FF">        curl -X POST &quot;https://api.deepgram.com/v1/listen?punctuate=true&amp;tier=enhanced&quot; \\</span></span>
<span class="line"><span style="color: #A5D6FF">            -H &quot;Authorization: Token YOUR_DEEPGRAM_API_KEY&quot; \\</span></span>
<span class="line"><span style="color: #A5D6FF">            -H &quot;Content-Type: application/json&quot; \\</span></span>
<span class="line"><span style="color: #A5D6FF">            -d &quot;{</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">url</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">:</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">$(_jq &#39;.url&#39;)</span><span style="color: #79C0FF">\\&quot;</span><span style="color: #A5D6FF">}&quot;</span></span>
<span class="line"><span style="color: #A5D6FF">   )</span></span>
<span class="line"><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">echo</span><span style="color: #C9D1D9"> $RESPONSE </span><span style="color: #FF7B72">|</span><span style="color: #C9D1D9"> jq </span><span style="color: #A5D6FF">&#39;.results.channels[0].alternatives[0].transcript&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;$(_jq &#39;.title&#39;).txt&quot;</span></span>
<span class="line"><span style="color: #FF7B72">done</span></span></code></pre>
<p>This will create one text file for each episode.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p><code>jq</code> and <code>xq</code> are exceptionally powerful tools, even more so when combined with cURL requests. With minimal adjustment, you can begin to alter the podcast fetched, the number of transcripts generated, or include additional metadata about the episode in the generated file.</p>
<p>If you have any questions, feel free to reach out - we love to help!</p>`;
}, "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/downloading-podcast-transcripts-from-terminal/index.md");

export { compiledContent, $$Index as default, frontmatter, metadata, rawContent };
