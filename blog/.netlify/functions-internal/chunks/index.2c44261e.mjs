import { c as createAstro, a as createComponent, r as renderTemplate, b as renderHead } from '../entry.mjs';
import Slugger from 'github-slugger';
import '@astrojs/netlify/netlify-functions.js';
import 'preact';
import 'preact-render-to-string';
import 'vue';
import 'vue/server-renderer';
import 'html-escaper';
import 'node-html-parser';
import 'axios';
/* empty css                           *//* empty css                           *//* empty css                           */import '@storyblok/js';
/* empty css                           *//* empty css                          */import 'clone-deep';
import 'slugify';
import 'shiki';
/* empty css                           */import 'camelcase';
import '@astrojs/rss';
/* empty css                           */import 'mime';
import 'cookie';
import 'kleur/colors';
import 'string-width';
import 'path-browserify';
import 'path-to-regexp';

const metadata = { "headings": [{ "depth": 2, "slug": "python-code-web-scraper-using-a-voice-command-with-speech-to-text", "text": "Python Code Web Scraper Using a Voice Command With Speech-to-Text" }], "source": '\nVoice commands are intriguing, especially with a speech recognition API. After getting exposure to Deepgram\u2019s real-time transcription, and speech-to-text Python SDK, I thought it\u2019d be cool to scrape a website with my voice.\n\nThe way the project works is simple:\n\n1.  Speak the command **scrape** into my computer\u2019s microphone.\n2.  That will kick off the Python scraper, which extracts links from a webpage.\n\nLet\u2019s take a closer look at how I built this project using Python, FastAPI, and Deepgram speech-to-text.\n\n## Python Code Web Scraper Using a Voice Command With Speech-to-Text\n\nFor this voice command scraper, I used one of Python\u2019s newest web frameworks, FastAPI. I\u2019ve already written a blog post about how to get up and running with [FastAPI and Deepgram\u2019s live transcription](https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/) using the Python SDK.\n\nSince there\u2019s already a tutorial about FastAPI written on Deepgram\u2019s blog, I won\u2019t go into tremendous detail as my [original post](https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/) covers most of the Python code.\n\nLet\u2019s start with the installation.\n\nI installed two additional Python libraries from my terminal inside of a virtual environment:\n\n```python\npip install beautifulsoup4\n\npip install requests\n```\n\nThen, I added the import statements to the **main.py** file:\n\n```python\nfrom bs4 import BeautifulSoup\nimport requests\nimport re\n```\n\n*   `BeautifuSoup` is for web scraping.\n*   The `requests` library is to get the text from the page source.\n*   The `re` import is to get the links in a specific format.\n\nThe only new function in this file is `scrape_links`. I also defined a new list called `hold_links` which will hold all the links extracted from the webpage. I pass in a URL to scrape to `requests.get` and loop through a BeautifulSoup object. A link from the webpage gets appended to the list each time through the loop.\n\n```python\nhold_links = []\n\ndef scrape_links():\n  url = "https://xkcd.com/"\n  r = requests.get(url)\n  \n  soup = BeautifulSoup(r.text, "html.parser")\n\n  for link in soup.find_all("a", attrs={\'href\': re.compile("^https://")}):\n    hold_links.append(link.get(\'href\'))\n\n  return hold_links\n```\n\nNext, is the `get_transcript` inner function.\n\n```python\nasync def process_audio(fast_socket: WebSocket):\n  async def get_transcript(data: Dict) -> None:\n    if \'channel\' in data:\n      transcript = data[\'channel\'][\'alternatives\'][0][\'transcript\']\n      if transcript and transcript == \'scrape\':\n        scrape_links()\n        await fast_socket.send_text(transcript)\n\n  deepgram_socket = await connect_to_deepgram(get_transcript)\n\n  return deepgram_socket\n```\n\nThe only change here are these lines to check if there\u2019s a transcript and if the transcript or voice command is **scrape**, then call the `scrape_links` function:\n\n```python\nif transcript and transcript == \'scrape\':\n  scrape_links()\n```\n\nLast but not least, when rendering the template, I passed in the `hold_links` list as a context object so the HTML page could display the links using Jinja.\n\n```python\n@app.get("/", response_class=HTMLResponse)\ndef get(request: Request):\n  return templates.TemplateResponse("index.html", {"request": request, "hold_links": hold_links})\n```\n\nIn the **index.html** file, I added the following line to the `<head></head>` section to refresh the page every five seconds:\n\n```html\n<meta http-equiv="refresh" content="5" />\n```\n\nThe page needs to be refreshed after speaking the voice command **scrape** to display the extracted links.\n\nLastly, in the `<body></body>`, add these lines which loop over the extracted links from the webpage and render them to the HTML page, `index.html`:\n\n```html\n<body>\n  <p>\n    {% for link in hold_links %}\n      {{ link }}</br>\n    {% endfor %}\n  </p>\n</body>\n```\n\nFinally, to run the FastAPI Python voice-to-text web scraper, type `uvicorn main:app --reload` from the terminal and navigate to `http://127.0.0.1:8000/`.\n\nAfter speaking the word **scrape** into my computer\u2019s microphone, a list of extracted links for the specified URL appeared on the webpage.\n\n![Scrape a website using voice commands with Python](https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-scrape-with-voice_ijgh01.png "Scrape a website using voice commands with Python")\n\n![Scrape and extract links using Beautiful Soup with Python](https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-extract-links-with-voice_sc8lid.png "Scrape and extract links using Beautiful Soup with Python")\n\nIf you found my project exciting or have questions, please feel free to [Tweet me](https://twitter.com/DeepgramAI)! I\u2019m happy to help!\n\n', "html": '<p>Voice commands are intriguing, especially with a speech recognition API. After getting exposure to Deepgram\u2019s real-time transcription, and speech-to-text Python SDK, I thought it\u2019d be cool to scrape a website with my voice.</p>\n<p>The way the project works is simple:</p>\n<ol>\n<li>Speak the command <strong>scrape</strong> into my computer\u2019s microphone.</li>\n<li>That will kick off the Python scraper, which extracts links from a webpage.</li>\n</ol>\n<p>Let\u2019s take a closer look at how I built this project using Python, FastAPI, and Deepgram speech-to-text.</p>\n<h2 id="python-code-web-scraper-using-a-voice-command-with-speech-to-text">Python Code Web Scraper Using a Voice Command With Speech-to-Text</h2>\n<p>For this voice command scraper, I used one of Python\u2019s newest web frameworks, FastAPI. I\u2019ve already written a blog post about how to get up and running with <a href="https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/">FastAPI and Deepgram\u2019s live transcription</a> using the Python SDK.</p>\n<p>Since there\u2019s already a tutorial about FastAPI written on Deepgram\u2019s blog, I won\u2019t go into tremendous detail as my <a href="https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/">original post</a> covers most of the Python code.</p>\n<p>Let\u2019s start with the installation.</p>\n<p>I installed two additional Python libraries from my terminal inside of a virtual environment:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">pip install beautifulsoup4</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">pip install requests</span></span></code></pre>\n<p>Then, I added the import statements to the <strong>main.py</strong> file:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> bs4 </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> BeautifulSoup</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> requests</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> re</span></span></code></pre>\n<ul>\n<li><code is:raw>BeautifuSoup</code> is for web scraping.</li>\n<li>The <code is:raw>requests</code> library is to get the text from the page source.</li>\n<li>The <code is:raw>re</code> import is to get the links in a specific format.</li>\n</ul>\n<p>The only new function in this file is <code is:raw>scrape_links</code>. I also defined a new list called <code is:raw>hold_links</code> which will hold all the links extracted from the webpage. I pass in a URL to scrape to <code is:raw>requests.get</code> and loop through a BeautifulSoup object. A link from the webpage gets appended to the list each time through the loop.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">hold_links </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> []</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">scrape_links</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9">  url </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;https://xkcd.com/&quot;</span></span>\n<span class="line"><span style="color: #C9D1D9">  r </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> requests.get(url)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span></span>\n<span class="line"><span style="color: #C9D1D9">  soup </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BeautifulSoup(r.text, </span><span style="color: #A5D6FF">&quot;html.parser&quot;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> link </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> soup.find_all(</span><span style="color: #A5D6FF">&quot;a&quot;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">attrs</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">{</span><span style="color: #A5D6FF">&#39;href&#39;</span><span style="color: #C9D1D9">: re.compile(</span><span style="color: #A5D6FF">&quot;^https://&quot;</span><span style="color: #C9D1D9">)}):</span></span>\n<span class="line"><span style="color: #C9D1D9">    hold_links.append(link.get(</span><span style="color: #A5D6FF">&#39;href&#39;</span><span style="color: #C9D1D9">))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> hold_links</span></span></code></pre>\n<p>Next, is the <code is:raw>get_transcript</code> inner function.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">process_audio</span><span style="color: #C9D1D9">(fast_socket: WebSocket):</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">get_transcript</span><span style="color: #C9D1D9">(data: Dict) -&gt; </span><span style="color: #79C0FF">None</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> data:</span></span>\n<span class="line"><span style="color: #C9D1D9">      transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;scrape&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">        scrape_links()</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> fast_socket.send_text(transcript)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  deepgram_socket </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> connect_to_deepgram(get_transcript)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> deepgram_socket</span></span></code></pre>\n<p>The only change here are these lines to check if there\u2019s a transcript and if the transcript or voice command is <strong>scrape</strong>, then call the <code is:raw>scrape_links</code> function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;scrape&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  scrape_links()</span></span></code></pre>\n<p>Last but not least, when rendering the template, I passed in the <code is:raw>hold_links</code> list as a context object so the HTML page could display the links using Jinja.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">@app.get</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;/&quot;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">response_class</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">HTMLResponse)</span></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">get</span><span style="color: #C9D1D9">(request: Request):</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> templates.TemplateResponse(</span><span style="color: #A5D6FF">&quot;index.html&quot;</span><span style="color: #C9D1D9">, {</span><span style="color: #A5D6FF">&quot;request&quot;</span><span style="color: #C9D1D9">: request, </span><span style="color: #A5D6FF">&quot;hold_links&quot;</span><span style="color: #C9D1D9">: hold_links})</span></span></code></pre>\n<p>In the <strong>index.html</strong> file, I added the following line to the <code is:raw>&lt;head&gt;&lt;/head&gt;</code> section to refresh the page every five seconds:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">meta</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">http-equiv</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;refresh&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">content</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;5&quot;</span><span style="color: #C9D1D9"> /&gt;</span></span></code></pre>\n<p>The page needs to be refreshed after speaking the voice command <strong>scrape</strong> to display the extracted links.</p>\n<p>Lastly, in the <code is:raw>&lt;body&gt;&lt;/body&gt;</code>, add these lines which loop over the extracted links from the webpage and render them to the HTML page, <code is:raw>index.html</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">body</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    {% for link in hold_links %}</span></span>\n<span class="line"><span style="color: #C9D1D9">      {{ link }}&lt;/</span><span style="color: #FFA198">br</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    {% endfor %}</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">body</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>Finally, to run the FastAPI Python voice-to-text web scraper, type <code is:raw>uvicorn main:app --reload</code> from the terminal and navigate to <code is:raw>http://127.0.0.1:8000/</code>.</p>\n<p>After speaking the word <strong>scrape</strong> into my computer\u2019s microphone, a list of extracted links for the specified URL appeared on the webpage.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-scrape-with-voice_ijgh01.png" alt="Scrape a website using voice commands with Python" title="Scrape a website using voice commands with Python"></p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-extract-links-with-voice_sc8lid.png" alt="Scrape and extract links using Beautiful Soup with Python" title="Scrape and extract links using Beautiful Soup with Python"></p>\n<p>If you found my project exciting or have questions, please feel free to <a href="https://twitter.com/DeepgramAI">Tweet me</a>! I\u2019m happy to help!</p>' };
const frontmatter = { "title": "Build a Web Scraper With Your Voice Using Python", "description": "This tutorial will use Python, Beautiful Soup and Deepgram speech-to-text Python API to scrape a website with your voice.", "date": "2022-09-15T15:37:24.138Z", "cover": "https://res.cloudinary.com/deepgram/image/upload/v1663256104/blog/python-scrape-with-voice/2209-Scrape-a-website-with-your-voice-using-Python-blog_2x_r7cpk9.jpg", "authors": ["tonya-sims"], "category": "tutorial", "tags": ["python", "scraping", "beautifulsoup"], "shorturls": { "share": "https://dpgr.am/6af9220", "twitter": "https://dpgr.am/17235b9", "linkedin": "https://dpgr.am/b8a45f8", "reddit": "https://dpgr.am/b0903c3", "facebook": "https://dpgr.am/cc11378" }, "astro": { "headings": [{ "depth": 2, "slug": "python-code-web-scraper-using-a-voice-command-with-speech-to-text", "text": "Python Code Web Scraper Using a Voice Command With Speech-to-Text" }], "source": '\nVoice commands are intriguing, especially with a speech recognition API. After getting exposure to Deepgram\u2019s real-time transcription, and speech-to-text Python SDK, I thought it\u2019d be cool to scrape a website with my voice.\n\nThe way the project works is simple:\n\n1.  Speak the command **scrape** into my computer\u2019s microphone.\n2.  That will kick off the Python scraper, which extracts links from a webpage.\n\nLet\u2019s take a closer look at how I built this project using Python, FastAPI, and Deepgram speech-to-text.\n\n## Python Code Web Scraper Using a Voice Command With Speech-to-Text\n\nFor this voice command scraper, I used one of Python\u2019s newest web frameworks, FastAPI. I\u2019ve already written a blog post about how to get up and running with [FastAPI and Deepgram\u2019s live transcription](https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/) using the Python SDK.\n\nSince there\u2019s already a tutorial about FastAPI written on Deepgram\u2019s blog, I won\u2019t go into tremendous detail as my [original post](https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/) covers most of the Python code.\n\nLet\u2019s start with the installation.\n\nI installed two additional Python libraries from my terminal inside of a virtual environment:\n\n```python\npip install beautifulsoup4\n\npip install requests\n```\n\nThen, I added the import statements to the **main.py** file:\n\n```python\nfrom bs4 import BeautifulSoup\nimport requests\nimport re\n```\n\n*   `BeautifuSoup` is for web scraping.\n*   The `requests` library is to get the text from the page source.\n*   The `re` import is to get the links in a specific format.\n\nThe only new function in this file is `scrape_links`. I also defined a new list called `hold_links` which will hold all the links extracted from the webpage. I pass in a URL to scrape to `requests.get` and loop through a BeautifulSoup object. A link from the webpage gets appended to the list each time through the loop.\n\n```python\nhold_links = []\n\ndef scrape_links():\n  url = "https://xkcd.com/"\n  r = requests.get(url)\n  \n  soup = BeautifulSoup(r.text, "html.parser")\n\n  for link in soup.find_all("a", attrs={\'href\': re.compile("^https://")}):\n    hold_links.append(link.get(\'href\'))\n\n  return hold_links\n```\n\nNext, is the `get_transcript` inner function.\n\n```python\nasync def process_audio(fast_socket: WebSocket):\n  async def get_transcript(data: Dict) -> None:\n    if \'channel\' in data:\n      transcript = data[\'channel\'][\'alternatives\'][0][\'transcript\']\n      if transcript and transcript == \'scrape\':\n        scrape_links()\n        await fast_socket.send_text(transcript)\n\n  deepgram_socket = await connect_to_deepgram(get_transcript)\n\n  return deepgram_socket\n```\n\nThe only change here are these lines to check if there\u2019s a transcript and if the transcript or voice command is **scrape**, then call the `scrape_links` function:\n\n```python\nif transcript and transcript == \'scrape\':\n  scrape_links()\n```\n\nLast but not least, when rendering the template, I passed in the `hold_links` list as a context object so the HTML page could display the links using Jinja.\n\n```python\n@app.get("/", response_class=HTMLResponse)\ndef get(request: Request):\n  return templates.TemplateResponse("index.html", {"request": request, "hold_links": hold_links})\n```\n\nIn the **index.html** file, I added the following line to the `<head></head>` section to refresh the page every five seconds:\n\n```html\n<meta http-equiv="refresh" content="5" />\n```\n\nThe page needs to be refreshed after speaking the voice command **scrape** to display the extracted links.\n\nLastly, in the `<body></body>`, add these lines which loop over the extracted links from the webpage and render them to the HTML page, `index.html`:\n\n```html\n<body>\n  <p>\n    {% for link in hold_links %}\n      {{ link }}</br>\n    {% endfor %}\n  </p>\n</body>\n```\n\nFinally, to run the FastAPI Python voice-to-text web scraper, type `uvicorn main:app --reload` from the terminal and navigate to `http://127.0.0.1:8000/`.\n\nAfter speaking the word **scrape** into my computer\u2019s microphone, a list of extracted links for the specified URL appeared on the webpage.\n\n![Scrape a website using voice commands with Python](https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-scrape-with-voice_ijgh01.png "Scrape a website using voice commands with Python")\n\n![Scrape and extract links using Beautiful Soup with Python](https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-extract-links-with-voice_sc8lid.png "Scrape and extract links using Beautiful Soup with Python")\n\nIf you found my project exciting or have questions, please feel free to [Tweet me](https://twitter.com/DeepgramAI)! I\u2019m happy to help!\n\n', "html": '<p>Voice commands are intriguing, especially with a speech recognition API. After getting exposure to Deepgram\u2019s real-time transcription, and speech-to-text Python SDK, I thought it\u2019d be cool to scrape a website with my voice.</p>\n<p>The way the project works is simple:</p>\n<ol>\n<li>Speak the command <strong>scrape</strong> into my computer\u2019s microphone.</li>\n<li>That will kick off the Python scraper, which extracts links from a webpage.</li>\n</ol>\n<p>Let\u2019s take a closer look at how I built this project using Python, FastAPI, and Deepgram speech-to-text.</p>\n<h2 id="python-code-web-scraper-using-a-voice-command-with-speech-to-text">Python Code Web Scraper Using a Voice Command With Speech-to-Text</h2>\n<p>For this voice command scraper, I used one of Python\u2019s newest web frameworks, FastAPI. I\u2019ve already written a blog post about how to get up and running with <a href="https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/">FastAPI and Deepgram\u2019s live transcription</a> using the Python SDK.</p>\n<p>Since there\u2019s already a tutorial about FastAPI written on Deepgram\u2019s blog, I won\u2019t go into tremendous detail as my <a href="https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/">original post</a> covers most of the Python code.</p>\n<p>Let\u2019s start with the installation.</p>\n<p>I installed two additional Python libraries from my terminal inside of a virtual environment:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">pip install beautifulsoup4</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">pip install requests</span></span></code></pre>\n<p>Then, I added the import statements to the <strong>main.py</strong> file:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> bs4 </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> BeautifulSoup</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> requests</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> re</span></span></code></pre>\n<ul>\n<li><code is:raw>BeautifuSoup</code> is for web scraping.</li>\n<li>The <code is:raw>requests</code> library is to get the text from the page source.</li>\n<li>The <code is:raw>re</code> import is to get the links in a specific format.</li>\n</ul>\n<p>The only new function in this file is <code is:raw>scrape_links</code>. I also defined a new list called <code is:raw>hold_links</code> which will hold all the links extracted from the webpage. I pass in a URL to scrape to <code is:raw>requests.get</code> and loop through a BeautifulSoup object. A link from the webpage gets appended to the list each time through the loop.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">hold_links </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> []</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">scrape_links</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9">  url </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;https://xkcd.com/&quot;</span></span>\n<span class="line"><span style="color: #C9D1D9">  r </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> requests.get(url)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span></span>\n<span class="line"><span style="color: #C9D1D9">  soup </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BeautifulSoup(r.text, </span><span style="color: #A5D6FF">&quot;html.parser&quot;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> link </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> soup.find_all(</span><span style="color: #A5D6FF">&quot;a&quot;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">attrs</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">{</span><span style="color: #A5D6FF">&#39;href&#39;</span><span style="color: #C9D1D9">: re.compile(</span><span style="color: #A5D6FF">&quot;^https://&quot;</span><span style="color: #C9D1D9">)}):</span></span>\n<span class="line"><span style="color: #C9D1D9">    hold_links.append(link.get(</span><span style="color: #A5D6FF">&#39;href&#39;</span><span style="color: #C9D1D9">))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> hold_links</span></span></code></pre>\n<p>Next, is the <code is:raw>get_transcript</code> inner function.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">process_audio</span><span style="color: #C9D1D9">(fast_socket: WebSocket):</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">get_transcript</span><span style="color: #C9D1D9">(data: Dict) -&gt; </span><span style="color: #79C0FF">None</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> data:</span></span>\n<span class="line"><span style="color: #C9D1D9">      transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;scrape&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">        scrape_links()</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> fast_socket.send_text(transcript)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  deepgram_socket </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> connect_to_deepgram(get_transcript)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> deepgram_socket</span></span></code></pre>\n<p>The only change here are these lines to check if there\u2019s a transcript and if the transcript or voice command is <strong>scrape</strong>, then call the <code is:raw>scrape_links</code> function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;scrape&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  scrape_links()</span></span></code></pre>\n<p>Last but not least, when rendering the template, I passed in the <code is:raw>hold_links</code> list as a context object so the HTML page could display the links using Jinja.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">@app.get</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;/&quot;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">response_class</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">HTMLResponse)</span></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">get</span><span style="color: #C9D1D9">(request: Request):</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> templates.TemplateResponse(</span><span style="color: #A5D6FF">&quot;index.html&quot;</span><span style="color: #C9D1D9">, {</span><span style="color: #A5D6FF">&quot;request&quot;</span><span style="color: #C9D1D9">: request, </span><span style="color: #A5D6FF">&quot;hold_links&quot;</span><span style="color: #C9D1D9">: hold_links})</span></span></code></pre>\n<p>In the <strong>index.html</strong> file, I added the following line to the <code is:raw>&lt;head&gt;&lt;/head&gt;</code> section to refresh the page every five seconds:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">meta</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">http-equiv</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;refresh&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">content</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;5&quot;</span><span style="color: #C9D1D9"> /&gt;</span></span></code></pre>\n<p>The page needs to be refreshed after speaking the voice command <strong>scrape</strong> to display the extracted links.</p>\n<p>Lastly, in the <code is:raw>&lt;body&gt;&lt;/body&gt;</code>, add these lines which loop over the extracted links from the webpage and render them to the HTML page, <code is:raw>index.html</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">body</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    {% for link in hold_links %}</span></span>\n<span class="line"><span style="color: #C9D1D9">      {{ link }}&lt;/</span><span style="color: #FFA198">br</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    {% endfor %}</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">body</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>Finally, to run the FastAPI Python voice-to-text web scraper, type <code is:raw>uvicorn main:app --reload</code> from the terminal and navigate to <code is:raw>http://127.0.0.1:8000/</code>.</p>\n<p>After speaking the word <strong>scrape</strong> into my computer\u2019s microphone, a list of extracted links for the specified URL appeared on the webpage.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-scrape-with-voice_ijgh01.png" alt="Scrape a website using voice commands with Python" title="Scrape a website using voice commands with Python"></p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-extract-links-with-voice_sc8lid.png" alt="Scrape and extract links using Beautiful Soup with Python" title="Scrape and extract links using Beautiful Soup with Python"></p>\n<p>If you found my project exciting or have questions, please feel free to <a href="https://twitter.com/DeepgramAI">Tweet me</a>! I\u2019m happy to help!</p>' }, "file": "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/scrape-a-website-with-your-voice-using-python/index.md" };
function rawContent() {
  return '\nVoice commands are intriguing, especially with a speech recognition API. After getting exposure to Deepgram\u2019s real-time transcription, and speech-to-text Python SDK, I thought it\u2019d be cool to scrape a website with my voice.\n\nThe way the project works is simple:\n\n1.  Speak the command **scrape** into my computer\u2019s microphone.\n2.  That will kick off the Python scraper, which extracts links from a webpage.\n\nLet\u2019s take a closer look at how I built this project using Python, FastAPI, and Deepgram speech-to-text.\n\n## Python Code Web Scraper Using a Voice Command With Speech-to-Text\n\nFor this voice command scraper, I used one of Python\u2019s newest web frameworks, FastAPI. I\u2019ve already written a blog post about how to get up and running with [FastAPI and Deepgram\u2019s live transcription](https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/) using the Python SDK.\n\nSince there\u2019s already a tutorial about FastAPI written on Deepgram\u2019s blog, I won\u2019t go into tremendous detail as my [original post](https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/) covers most of the Python code.\n\nLet\u2019s start with the installation.\n\nI installed two additional Python libraries from my terminal inside of a virtual environment:\n\n```python\npip install beautifulsoup4\n\npip install requests\n```\n\nThen, I added the import statements to the **main.py** file:\n\n```python\nfrom bs4 import BeautifulSoup\nimport requests\nimport re\n```\n\n*   `BeautifuSoup` is for web scraping.\n*   The `requests` library is to get the text from the page source.\n*   The `re` import is to get the links in a specific format.\n\nThe only new function in this file is `scrape_links`. I also defined a new list called `hold_links` which will hold all the links extracted from the webpage. I pass in a URL to scrape to `requests.get` and loop through a BeautifulSoup object. A link from the webpage gets appended to the list each time through the loop.\n\n```python\nhold_links = []\n\ndef scrape_links():\n  url = "https://xkcd.com/"\n  r = requests.get(url)\n  \n  soup = BeautifulSoup(r.text, "html.parser")\n\n  for link in soup.find_all("a", attrs={\'href\': re.compile("^https://")}):\n    hold_links.append(link.get(\'href\'))\n\n  return hold_links\n```\n\nNext, is the `get_transcript` inner function.\n\n```python\nasync def process_audio(fast_socket: WebSocket):\n  async def get_transcript(data: Dict) -> None:\n    if \'channel\' in data:\n      transcript = data[\'channel\'][\'alternatives\'][0][\'transcript\']\n      if transcript and transcript == \'scrape\':\n        scrape_links()\n        await fast_socket.send_text(transcript)\n\n  deepgram_socket = await connect_to_deepgram(get_transcript)\n\n  return deepgram_socket\n```\n\nThe only change here are these lines to check if there\u2019s a transcript and if the transcript or voice command is **scrape**, then call the `scrape_links` function:\n\n```python\nif transcript and transcript == \'scrape\':\n  scrape_links()\n```\n\nLast but not least, when rendering the template, I passed in the `hold_links` list as a context object so the HTML page could display the links using Jinja.\n\n```python\n@app.get("/", response_class=HTMLResponse)\ndef get(request: Request):\n  return templates.TemplateResponse("index.html", {"request": request, "hold_links": hold_links})\n```\n\nIn the **index.html** file, I added the following line to the `<head></head>` section to refresh the page every five seconds:\n\n```html\n<meta http-equiv="refresh" content="5" />\n```\n\nThe page needs to be refreshed after speaking the voice command **scrape** to display the extracted links.\n\nLastly, in the `<body></body>`, add these lines which loop over the extracted links from the webpage and render them to the HTML page, `index.html`:\n\n```html\n<body>\n  <p>\n    {% for link in hold_links %}\n      {{ link }}</br>\n    {% endfor %}\n  </p>\n</body>\n```\n\nFinally, to run the FastAPI Python voice-to-text web scraper, type `uvicorn main:app --reload` from the terminal and navigate to `http://127.0.0.1:8000/`.\n\nAfter speaking the word **scrape** into my computer\u2019s microphone, a list of extracted links for the specified URL appeared on the webpage.\n\n![Scrape a website using voice commands with Python](https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-scrape-with-voice_ijgh01.png "Scrape a website using voice commands with Python")\n\n![Scrape and extract links using Beautiful Soup with Python](https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-extract-links-with-voice_sc8lid.png "Scrape and extract links using Beautiful Soup with Python")\n\nIf you found my project exciting or have questions, please feel free to [Tweet me](https://twitter.com/DeepgramAI)! I\u2019m happy to help!\n\n';
}
function compiledContent() {
  return '<p>Voice commands are intriguing, especially with a speech recognition API. After getting exposure to Deepgram\u2019s real-time transcription, and speech-to-text Python SDK, I thought it\u2019d be cool to scrape a website with my voice.</p>\n<p>The way the project works is simple:</p>\n<ol>\n<li>Speak the command <strong>scrape</strong> into my computer\u2019s microphone.</li>\n<li>That will kick off the Python scraper, which extracts links from a webpage.</li>\n</ol>\n<p>Let\u2019s take a closer look at how I built this project using Python, FastAPI, and Deepgram speech-to-text.</p>\n<h2 id="python-code-web-scraper-using-a-voice-command-with-speech-to-text">Python Code Web Scraper Using a Voice Command With Speech-to-Text</h2>\n<p>For this voice command scraper, I used one of Python\u2019s newest web frameworks, FastAPI. I\u2019ve already written a blog post about how to get up and running with <a href="https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/">FastAPI and Deepgram\u2019s live transcription</a> using the Python SDK.</p>\n<p>Since there\u2019s already a tutorial about FastAPI written on Deepgram\u2019s blog, I won\u2019t go into tremendous detail as my <a href="https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/">original post</a> covers most of the Python code.</p>\n<p>Let\u2019s start with the installation.</p>\n<p>I installed two additional Python libraries from my terminal inside of a virtual environment:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">pip install beautifulsoup4</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">pip install requests</span></span></code></pre>\n<p>Then, I added the import statements to the <strong>main.py</strong> file:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> bs4 </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> BeautifulSoup</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> requests</span></span>\n<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> re</span></span></code></pre>\n<ul>\n<li><code is:raw>BeautifuSoup</code> is for web scraping.</li>\n<li>The <code is:raw>requests</code> library is to get the text from the page source.</li>\n<li>The <code is:raw>re</code> import is to get the links in a specific format.</li>\n</ul>\n<p>The only new function in this file is <code is:raw>scrape_links</code>. I also defined a new list called <code is:raw>hold_links</code> which will hold all the links extracted from the webpage. I pass in a URL to scrape to <code is:raw>requests.get</code> and loop through a BeautifulSoup object. A link from the webpage gets appended to the list each time through the loop.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">hold_links </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> []</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">scrape_links</span><span style="color: #C9D1D9">():</span></span>\n<span class="line"><span style="color: #C9D1D9">  url </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;https://xkcd.com/&quot;</span></span>\n<span class="line"><span style="color: #C9D1D9">  r </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> requests.get(url)</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span></span>\n<span class="line"><span style="color: #C9D1D9">  soup </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BeautifulSoup(r.text, </span><span style="color: #A5D6FF">&quot;html.parser&quot;</span><span style="color: #C9D1D9">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> link </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> soup.find_all(</span><span style="color: #A5D6FF">&quot;a&quot;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">attrs</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">{</span><span style="color: #A5D6FF">&#39;href&#39;</span><span style="color: #C9D1D9">: re.compile(</span><span style="color: #A5D6FF">&quot;^https://&quot;</span><span style="color: #C9D1D9">)}):</span></span>\n<span class="line"><span style="color: #C9D1D9">    hold_links.append(link.get(</span><span style="color: #A5D6FF">&#39;href&#39;</span><span style="color: #C9D1D9">))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> hold_links</span></span></code></pre>\n<p>Next, is the <code is:raw>get_transcript</code> inner function.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">process_audio</span><span style="color: #C9D1D9">(fast_socket: WebSocket):</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">get_transcript</span><span style="color: #C9D1D9">(data: Dict) -&gt; </span><span style="color: #79C0FF">None</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> data:</span></span>\n<span class="line"><span style="color: #C9D1D9">      transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]</span></span>\n<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;scrape&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">        scrape_links()</span></span>\n<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> fast_socket.send_text(transcript)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  deepgram_socket </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> connect_to_deepgram(get_transcript)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> deepgram_socket</span></span></code></pre>\n<p>The only change here are these lines to check if there\u2019s a transcript and if the transcript or voice command is <strong>scrape</strong>, then call the <code is:raw>scrape_links</code> function:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;scrape&#39;</span><span style="color: #C9D1D9">:</span></span>\n<span class="line"><span style="color: #C9D1D9">  scrape_links()</span></span></code></pre>\n<p>Last but not least, when rendering the template, I passed in the <code is:raw>hold_links</code> list as a context object so the HTML page could display the links using Jinja.</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">@app.get</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;/&quot;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">response_class</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">HTMLResponse)</span></span>\n<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">get</span><span style="color: #C9D1D9">(request: Request):</span></span>\n<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> templates.TemplateResponse(</span><span style="color: #A5D6FF">&quot;index.html&quot;</span><span style="color: #C9D1D9">, {</span><span style="color: #A5D6FF">&quot;request&quot;</span><span style="color: #C9D1D9">: request, </span><span style="color: #A5D6FF">&quot;hold_links&quot;</span><span style="color: #C9D1D9">: hold_links})</span></span></code></pre>\n<p>In the <strong>index.html</strong> file, I added the following line to the <code is:raw>&lt;head&gt;&lt;/head&gt;</code> section to refresh the page every five seconds:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">meta</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">http-equiv</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;refresh&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">content</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;5&quot;</span><span style="color: #C9D1D9"> /&gt;</span></span></code></pre>\n<p>The page needs to be refreshed after speaking the voice command <strong>scrape</strong> to display the extracted links.</p>\n<p>Lastly, in the <code is:raw>&lt;body&gt;&lt;/body&gt;</code>, add these lines which loop over the extracted links from the webpage and render them to the HTML page, <code is:raw>index.html</code>:</p>\n<pre is:raw class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">body</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    {% for link in hold_links %}</span></span>\n<span class="line"><span style="color: #C9D1D9">      {{ link }}&lt;/</span><span style="color: #FFA198">br</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">    {% endfor %}</span></span>\n<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>\n<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">body</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>\n<p>Finally, to run the FastAPI Python voice-to-text web scraper, type <code is:raw>uvicorn main:app --reload</code> from the terminal and navigate to <code is:raw>http://127.0.0.1:8000/</code>.</p>\n<p>After speaking the word <strong>scrape</strong> into my computer\u2019s microphone, a list of extracted links for the specified URL appeared on the webpage.</p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-scrape-with-voice_ijgh01.png" alt="Scrape a website using voice commands with Python" title="Scrape a website using voice commands with Python"></p>\n<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-extract-links-with-voice_sc8lid.png" alt="Scrape and extract links using Beautiful Soup with Python" title="Scrape and extract links using Beautiful Soup with Python"></p>\n<p>If you found my project exciting or have questions, please feel free to <a href="https://twitter.com/DeepgramAI">Tweet me</a>! I\u2019m happy to help!</p>';
}
const $$Astro = createAstro("/Users/sandrarodgers/web-next/blog/src/content/blog/posts/scrape-a-website-with-your-voice-using-python/index.md", "https://blog.deepgram.com/", "file:///Users/sandrarodgers/web-next/blog/");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  new Slugger();
  return renderTemplate`<head>${renderHead($$result)}</head><p>Voice commands are intriguing, especially with a speech recognition API. After getting exposure to Deepgram’s real-time transcription, and speech-to-text Python SDK, I thought it’d be cool to scrape a website with my voice.</p>
<p>The way the project works is simple:</p>
<ol>
<li>Speak the command <strong>scrape</strong> into my computer’s microphone.</li>
<li>That will kick off the Python scraper, which extracts links from a webpage.</li>
</ol>
<p>Let’s take a closer look at how I built this project using Python, FastAPI, and Deepgram speech-to-text.</p>
<h2 id="python-code-web-scraper-using-a-voice-command-with-speech-to-text">Python Code Web Scraper Using a Voice Command With Speech-to-Text</h2>
<p>For this voice command scraper, I used one of Python’s newest web frameworks, FastAPI. I’ve already written a blog post about how to get up and running with <a href="https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/">FastAPI and Deepgram’s live transcription</a> using the Python SDK.</p>
<p>Since there’s already a tutorial about FastAPI written on Deepgram’s blog, I won’t go into tremendous detail as my <a href="https://developers.deepgram.com/blog/2022/03/live-transcription-fastapi/">original post</a> covers most of the Python code.</p>
<p>Let’s start with the installation.</p>
<p>I installed two additional Python libraries from my terminal inside of a virtual environment:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">pip install beautifulsoup4</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">pip install requests</span></span></code></pre>
<p>Then, I added the import statements to the <strong>main.py</strong> file:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">from</span><span style="color: #C9D1D9"> bs4 </span><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> BeautifulSoup</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> requests</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> re</span></span></code></pre>
<ul>
<li><code>BeautifuSoup</code> is for web scraping.</li>
<li>The <code>requests</code> library is to get the text from the page source.</li>
<li>The <code>re</code> import is to get the links in a specific format.</li>
</ul>
<p>The only new function in this file is <code>scrape_links</code>. I also defined a new list called <code>hold_links</code> which will hold all the links extracted from the webpage. I pass in a URL to scrape to <code>requests.get</code> and loop through a BeautifulSoup object. A link from the webpage gets appended to the list each time through the loop.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">hold_links </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> []</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">scrape_links</span><span style="color: #C9D1D9">():</span></span>
<span class="line"><span style="color: #C9D1D9">  url </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;https://xkcd.com/&quot;</span></span>
<span class="line"><span style="color: #C9D1D9">  r </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> requests.get(url)</span></span>
<span class="line"><span style="color: #C9D1D9">  </span></span>
<span class="line"><span style="color: #C9D1D9">  soup </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BeautifulSoup(r.text, </span><span style="color: #A5D6FF">&quot;html.parser&quot;</span><span style="color: #C9D1D9">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> link </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> soup.find_all(</span><span style="color: #A5D6FF">&quot;a&quot;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">attrs</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">{</span><span style="color: #A5D6FF">&#39;href&#39;</span><span style="color: #C9D1D9">: re.compile(</span><span style="color: #A5D6FF">&quot;^https://&quot;</span><span style="color: #C9D1D9">)}):</span></span>
<span class="line"><span style="color: #C9D1D9">    hold_links.append(link.get(</span><span style="color: #A5D6FF">&#39;href&#39;</span><span style="color: #C9D1D9">))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> hold_links</span></span></code></pre>
<p>Next, is the <code>get_transcript</code> inner function.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">process_audio</span><span style="color: #C9D1D9">(fast_socket: WebSocket):</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">async</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">get_transcript</span><span style="color: #C9D1D9">(data: Dict) -&gt; </span><span style="color: #79C0FF">None</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> data:</span></span>
<span class="line"><span style="color: #C9D1D9">      transcript </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> data[</span><span style="color: #A5D6FF">&#39;channel&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;alternatives&#39;</span><span style="color: #C9D1D9">][</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">][</span><span style="color: #A5D6FF">&#39;transcript&#39;</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">      </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;scrape&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">        scrape_links()</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> fast_socket.send_text(transcript)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  deepgram_socket </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">await</span><span style="color: #C9D1D9"> connect_to_deepgram(get_transcript)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> deepgram_socket</span></span></code></pre>
<p>The only change here are these lines to check if there’s a transcript and if the transcript or voice command is <strong>scrape</strong>, then call the <code>scrape_links</code> function:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> transcript </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#39;scrape&#39;</span><span style="color: #C9D1D9">:</span></span>
<span class="line"><span style="color: #C9D1D9">  scrape_links()</span></span></code></pre>
<p>Last but not least, when rendering the template, I passed in the <code>hold_links</code> list as a context object so the HTML page could display the links using Jinja.</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #D2A8FF">@app.get</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;/&quot;</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">response_class</span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9">HTMLResponse)</span></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">get</span><span style="color: #C9D1D9">(request: Request):</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> templates.TemplateResponse(</span><span style="color: #A5D6FF">&quot;index.html&quot;</span><span style="color: #C9D1D9">, {</span><span style="color: #A5D6FF">&quot;request&quot;</span><span style="color: #C9D1D9">: request, </span><span style="color: #A5D6FF">&quot;hold_links&quot;</span><span style="color: #C9D1D9">: hold_links})</span></span></code></pre>
<p>In the <strong>index.html</strong> file, I added the following line to the <code>&lt;head&gt;&lt;/head&gt;</code> section to refresh the page every five seconds:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">meta</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">http-equiv</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;refresh&quot;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">content</span><span style="color: #C9D1D9">=</span><span style="color: #A5D6FF">&quot;5&quot;</span><span style="color: #C9D1D9"> /&gt;</span></span></code></pre>
<p>The page needs to be refreshed after speaking the voice command <strong>scrape</strong> to display the extracted links.</p>
<p>Lastly, in the <code>&lt;body&gt;&lt;/body&gt;</code>, add these lines which loop over the extracted links from the webpage and render them to the HTML page, <code>index.html</code>:</p>
<pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">&lt;</span><span style="color: #7EE787">body</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    {% for link in hold_links %}</span></span>
<span class="line"><span style="color: #C9D1D9">      {{ link }}&lt;/</span><span style="color: #FFA198">br</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    {% endfor %}</span></span>
<span class="line"><span style="color: #C9D1D9">  &lt;/</span><span style="color: #7EE787">p</span><span style="color: #C9D1D9">&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">&lt;/</span><span style="color: #7EE787">body</span><span style="color: #C9D1D9">&gt;</span></span></code></pre>
<p>Finally, to run the FastAPI Python voice-to-text web scraper, type <code>uvicorn main:app --reload</code> from the terminal and navigate to <code>http://127.0.0.1:8000/</code>.</p>
<p>After speaking the word <strong>scrape</strong> into my computer’s microphone, a list of extracted links for the specified URL appeared on the webpage.</p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-scrape-with-voice_ijgh01.png" alt="Scrape a website using voice commands with Python" title="Scrape a website using voice commands with Python"></p>
<p><img src="https://res.cloudinary.com/deepgram/image/upload/v1663256081/blog/python-scrape-with-voice/python-extract-links-with-voice_sc8lid.png" alt="Scrape and extract links using Beautiful Soup with Python" title="Scrape and extract links using Beautiful Soup with Python"></p>
<p>If you found my project exciting or have questions, please feel free to <a href="https://twitter.com/DeepgramAI">Tweet me</a>! I’m happy to help!</p>`;
}, "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/scrape-a-website-with-your-voice-using-python/index.md");

export { compiledContent, $$Index as default, frontmatter, metadata, rawContent };
