import { c as createAstro, a as createComponent, r as renderTemplate, b as renderHead } from '../entry.mjs';
import Slugger from 'github-slugger';
import '@astrojs/netlify/netlify-functions.js';
import 'preact';
import 'preact-render-to-string';
import 'vue';
import 'vue/server-renderer';
import 'html-escaper';
import 'node-html-parser';
import 'axios';
/* empty css                           *//* empty css                           *//* empty css                           */import '@storyblok/js';
/* empty css                          *//* empty css                              */import 'clone-deep';
import 'slugify';
import 'shiki';
/* empty css                           */import 'camelcase';
/* empty css                              */import '@astrojs/rss';
/* empty css                           */import 'mime';
import 'cookie';
import 'kleur/colors';
import 'string-width';
import 'path-browserify';
import 'path-to-regexp';

const metadata = { "headings": [{ "depth": 2, "slug": "pre-requisites", "text": "Pre-requisites" }, { "depth": 2, "slug": "try-the-game", "text": "Try the Game" }, { "depth": 2, "slug": "building-the-game", "text": "Building the Game" }, { "depth": 2, "slug": "setting-up-the-project", "text": "Setting Up the Project" }, { "depth": 2, "slug": "creating-a-player", "text": "Creating a Player" }, { "depth": 2, "slug": "creating-a-fireball", "text": "Creating a Fireball" }, { "depth": 2, "slug": "triggering-the-fireball-with-keystrokes", "text": "Triggering the Fireball With Keystrokes" }, { "depth": 2, "slug": "triggering-the-fireball-with-your-voice", "text": "Triggering the Fireball With Your Voice" }, { "depth": 2, "slug": "build-new-features", "text": "Build New Features" }, { "depth": 2, "slug": "final-thoughts", "text": "Final Thoughts" }], "source": '\nIn this post, we will be making a simplified version of the 2D game "Spooky Speech Spells" (which you can play [here](https://spookyspeechspells.deepgram.com))\r\nin the Godot game engine using an integration with the Deepgram automatic speech recognition (ASR) engine. Why Godot? Because it is an\r\neasy-to-learn, open-source alternative to the popular industry-standard Unity and can export directly to Mac, Windows, Linux, iOS,\r\nAndroid, and HTML5. Why Deepgram? Because it is the fastest, most accurate, cheapest, and easiest to use ASR engine out there! And why\r\nmake a speech-enhanced game? Well, because it\'s cool, and games are fun! Beyond that, adding nontraditional input devices can help make your games more accessible.\n\nThis tutorial is focusing on adding voice input to your game, but if you want to see more tutorials, you can find plenty on the\r\n[Godot website](https://docs.godotengine.org/en/stable/community/tutorials.html).\n\n## Pre-requisites\n\nYou will need:\n\n*   Godot installed on your machine - [download Godot here](https://godotengine.org/download). This tutorial was written with version `3.4.3`.\n*   A Deepgram API Key - [get an API Key here](https://console.deepgram.com/signup?jump=keys).\n\n## Try the Game\n\nTo run the game we are going to build and browse its files:\n\n*   Download [this repository](https://github.com/deepgram/SpeechSpells), open Godot, click "Import", and browse to and select the `project.godot` file from the repo.\n*   In the Godot editor, go to the "FileSystem" tab in the lower left, and navigate to and open `Scenes/Game.gd`.\n*   Edit `line 7` of `Scenes/Game.gd` and enter your Deepgram API Key.\n*   In the top right of the Godot editor, hit the "Play" (\u25BA) button.\n*   Move your character with `WASD` and say "fire" to cast fire spells!\n\n## Building the Game\n\nIn the following sub-sections, we will walk through step-by-step how to make a game where you can move\r\na character around the screen and have the character cast fireball spells by chanting "fire!" into your\r\nmicrophone.\n\n## Setting Up the Project\n\nOpen Godot and create a "New Project" in the project manager.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/new_project.png" alt="Create a new project." style="max-width: 1037px;display: block;margin-left: auto;margin-right: auto;">\n\nNow click "Browse" and choose a directory on your filesystem to store the project, and in the "Project Name"\r\nfield, write "SpeechSpells" and hit "Create Folder." Finally, hit "Create and Edit," and we\'ll get to the Godot\r\nEditor, where we can build our game.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/set_project_name.png" alt="Set the name of the new project." style="max-width: 1038px;display: block;margin-left: auto;margin-right: auto;">\n\nThe Godot Editor consists of several panels and tabs, and we will be going over the ones we need to interact\r\nwith to build "Speech Spells".\n\nLet\'s start with the "Scene" tab in the upper left panel. In this tab, we can put together "Scenes," which,\r\ntogether with "Nodes," form the basic building blocks of Godot games. Scenes and nodes are classes\r\nin object-oriented programming terminology, but the Godot Editor offers an intuitive way to create, edit,\r\nand manage our various game objects as scenes and nodes. Scenes can be almost anything - a collection\r\nof sprite nodes, a character with animations, attacks, and hit-boxes, or just a collection of scripts\r\nthat execute algorithms and can emit signals to other nodes (we will see this pattern further on). For now,\r\nwhere it says "Create Root Node" click "2D Scene" and double click the name of the resulting node and rename\r\nit to "Game". We will create a few other scenes for this game and add instances of those scenes to our Game\r\nscene.\n\nBefore saving the scene, let\'s head over to the lower right "Filesystem" tab. Right-click in the filesystem\r\nbrowser there and click "New Folder..." to create a folder called "Scenes" and then a folder called "Assets".\r\nYou may, of course, organize your projects however you like, but this is at least one way of doing it.\n\nClick on `Scene -> Save Scene` in the upper left corner of the editor to save this scene as `Game.tscn` in the "Scenes" directory that you just created.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/create_folders.png" alt="Set up the game directory structure." style="max-width: 249px;display: block;margin-left: auto;margin-right: auto;">\n\nNow, go to `Project -> Project Settings` from the upper left bar, and we will set a couple of properties of our game.\r\nStart by navigating to `Rendering -> Environment` and change the "Default Clear Color" to black.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/default_clear_color.png" alt="Change the default clear color." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;">\n\nNext, navigate to `Display -> Window`, uncheck "Resizable", set the "Width" to 320, the "Height" to 240,\r\nthe "Test Width" to 960, the "Test Height" to 720, the "Stretch" "Mode" to "2d" and the\r\nStretch "Aspect" to "Keep". This is setting us up to build a game\r\nwith a very low resolution close to 240p (common for 8-bit pixel games), but when we run the game it will\r\ndisplay in a nice big 960x720 window, effectively tripling the size of the pixels. Godot has many options\r\nunder `Display -> Window`, and understanding these can enable you to effortlessly build games that look\r\nfantastic at multiple resolutions and multiple aspect ratios targeting different devices without ever\r\nhaving to think about anything other than your base resolution (320x240 in our case)!\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646549594/blog/2022/03/deepgram-godot-tutorial/assets/change_window_settings.png" alt="Set the window settings." style="max-width: 986px;display: block;margin-left: auto;margin-right: auto;">\n\nWe have one more setting to change - navigate to `Application -> Audio` and check "Enable Audio Input".\r\nA warning will appear saying you will need to restart the editor for this to take effect, click the button\r\nthat appears in the lower right ("Save & Restart") to do so.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/enable_audio.png" alt="Enable audio." style="max-width: 911px;display: block;margin-left: auto;margin-right: auto;">\n\nFinally, click the "Play" button in the upper right (or press "F5") to start up the game - since this is the\r\nfirst time we are playing the game, you will be asked to tell Godot which scene you want to start when the\r\ngame is first opened - we only have `Game.tscn` so select that one. We now have a blank canvas ready to be filled!\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/press_play.png" alt="Start the game." style="max-width: 310px;display: block;margin-left: auto;margin-right: auto;">\n\n## Creating a Player\n\nNow that we have a running game in a window let\'s create a player to move around. In the top left of\r\nthe Godot editor, click `Scene -> New Scene`. Like when you first opened this project, the "Scene" tab\r\nwill give you some options for the root node. Click "Other Node" and navigate to, or use the search\r\nfield to find "KinematicBody2D" and click "Create."\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/create_kinematic_body_2d.png" alt="Create a KinematicBody2D." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;">\n\n"KinematicBody2D" is one of the most reasonable types of objects to use for controllable characters.\r\nThis class/node offers convenient methods to make moving and handling collisions with various objects\r\neasy - we will discuss one of these methods shortly.\n\nNow, right-click the root node and click "Add Child Node" and create a "Sprite" node. Do this again\r\nand add a "CollisionShape2D" node. Your node structure should now look like the following:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/player_node_structure.png" alt="The node structure of the Player - the `KinematicBody2D` root node here contains a `Sprite` node and `CollisionShape2D` node as children." style="max-width: 250px;display: block;margin-left: auto;margin-right: auto;">\n\nThe "Sprite" node will contain the image to use for our player. We will use a pixel art\r\nimage of a skull for our player; you can download it [here](https://res.cloudinary.com/deepgram/image/upload/v1646849910/blog/2022/03/deepgram-godot-tutorial/assets/skull.png). Drag the\r\nfile into the "Assets" directory in the "Filesystem" tab in the lower left, then click on the "Import"\r\ntab next to the "Scene" tab, uncheck "Filter" and click "Reimport":\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/import_skull.png" alt="Import the skull image." style="max-width: 245px;display: block;margin-left: auto;margin-right: auto;">\n\nThis is importing the image into our project and telling our project not to apply interpolation\r\nwhen scaling the image should the window size change from the base window size (which is a tiny\r\n320x240 for us). Most art assets ought to have some interpolation applied when scaling to smaller\r\n(or larger) resolutions, but this looks notoriously bad for pixel art, where one would expect\r\nthe sharp and blocky sprite to remain sharp and blocky at any resolution.\n\nNow, navigate back to the "Scene" tab, click on the "Sprite" node, and drag and drop `skull.png`\r\nfrom the "Asset" directory to the "Texture" field:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/set_skull_texture.png" alt="Set the Player\'s sprite texture." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nAfter doing this, you should see an image in the scene\'s 2D view. Finally, some graphics!\r\nYou may want to play around with zooming in or out to get a better view.\n\nNow, click on the "CollisionShape2D" node, then click on the "Shape" field on the upper right\r\nand select "RectangleShape2D", and change the "Extents" "x" and "y" fields to both be 8:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/add_rectangle_shape_2d.png" alt="Setup the Player\'s CollisionShape2D." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nThis is essentially defining the hit-box of the player. We won\'t utilize hit-boxes\r\nor collision detection in this tutorial, but it is good practice to learn how to\r\nset up a player as one typically would in a more involved game.\n\nRename the root node "Player" and then save the scene as `Player.tscn` in the "Scenes" directory.\r\nNow, with the root node ("Player") selected, hit the button which looks like a script with a green\r\nplus sign on it to create a script for this node:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/attach_script.png" alt="Attach a script to a node." style="max-width: 610px;display: block;margin-left: auto;margin-right: auto;">\n\nThis will create a `Player.gd` script, that will help define how this node functions in the game.\r\n`.gd` is the file extension for GDScript source code. GDScript is one of two languages which Godot uses\r\nnatively (the other being a visual programming language which is quite fun!). GDScript is a lot\r\nlike Python, and has a comparatively easy learning curve, helped by the fact that the Godot engine does most of\r\nthe complicated stuff under the hood, leaving the scripting of game objects to be short and quick.\r\nMake the contents of `Player.gd` the following, and you may start to note how few lines of code it takes to perform some actions:\n\n    extends KinematicBody2D\r\n\r\n    export var speed = 100\r\n    var velocity = Vector2(0, 0)\r\n\r\n    func _physics_process(_delta):\r\n    	if Input.is_key_pressed(KEY_W):\r\n    		velocity.y = -speed\r\n    	elif Input.is_key_pressed(KEY_S):\r\n    		velocity.y = speed\r\n    	else:\r\n    		velocity.y = 0\r\n\r\n    	if Input.is_key_pressed(KEY_A):\r\n    		velocity.x = - speed\r\n    	elif Input.is_key_pressed(KEY_D):\r\n    		velocity.x = speed\r\n    	else:\r\n    		velocity.x = 0\r\n\r\n    	var _returned_velocity = move_and_slide(velocity, Vector2(0, 0), false, 4, 0, false)\r\n\r\n    	if position.x < 0 - 16:\r\n    		position.x = 320 + 16\r\n    	if position.x > 320 + 16:\r\n    		position.x = 0 - 16\r\n\r\n    	if position.y < 0 - 16:\r\n    		position.y = 240 + 16\r\n    	if position.y > 240 + 16:\r\n    		position.y = 0 - 16\n\nThe first line, `extends KinematicBody2D`, is telling us that our script is an extension of the "KinematicBody2D" class,\r\nmeaning we will be able to access any methods and variables that the "KinematicBody2D" class offers, plus any variables\r\nand methods that we introduce here in this file. We then define the variables `speed` and `velocity`. We will use `velocity`\r\nto mean the velocity of the player at any given time, and `speed` to mean the maximum horizontal or vertical speed of the\r\nplayer when we move the player.\n\nNext comes the method `_physics_process(_delta)`. This is a method accessible to many Godot nodes, and is executed\r\nroughly 60 times per second, allowing us to alter objects in a way that the physics engine can understand.\r\nThe "delta" argument is the amount of time that has passed since the last call to `_physics_process`, but here we\r\nare not using it, so we place an underscore in front of the argument name to avoid a warning.\n\nIn this method, we check if the `WASD` keys are pressed, and modify the player\'s velocity accordingly ("W" to move up,\r\n"A" to move left, "S" to move down, and "D" to move right). Note that to move up, we set the "y" velocity to `-speed` - this\r\nis because Godot, like many game engines, considers *down* to be the positive y-direction.\n\nAfter adjusting the player\'s velocity, we call the `move_and_slide` method, specifying the velocity as one of its arguments\r\n(the others don\'t matter for now). This method does a lot of logic internally and can handle collisions with static bodies\r\nand rigid bodies, of any shape or size, and correctly move the player along the surface of bodies instead of bouncing\r\noff of them (hence the "slide"). The method returns the resulting velocity of the player after any collisions/slides,\r\nbut since we won\'t be using this, we place an underscore to avoid a warning.\n\nLastly, we check and modify the position of the player to wrap around the window - i.e. if the player moves too far to the left,\r\nhave them wrap to the right side of the window.\n\nSave, and finally go back to the "Game" scene, and click the button at the top of the "Scene" tab to "Instance Child Scene":\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/instance_child_scene.png" alt="Instance a child scene." style="max-width: 626px;display: block;margin-left: auto;margin-right: auto;">\n\nSelect the `Player.tscn` we just created. Now our main "Game" scene has a "Player" scene as a child node! Click the "Play" button\r\nand now the game boots up with a skull in the corner - you can move the skull around with `WASD`! Feel free to reposition the skull\r\nin the "Game" scene - you can either click and drag the player in the 2D view, or you can directly enter the x and y position\r\nin `Node2D -> Transform -> Position` in the "Inspector" tab when the "Player" node is selected in the "Game" scene:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646785008/blog/2022/03/deepgram-godot-tutorial/assets/player_position_in_editor.png" alt="Setting the Player\'s position." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\n## Creating a Fireball\n\nLet\'s make a fireball scene which we will use to have the player shooting fireballs across the screen.\r\nCreate a new scene, for the root node click "Other Node" and pick "Area2D". Rename this root node "Fireball".\r\nAdd two child nodes: an "AnimatedSprite" and a "CollisionShape2D".\n\nNext, import into your "Assets" directory [fireball\\_1.png](https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_1.png)\r\nand [fireball\\_2.png](https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_2.png).\r\nThe two sprites will make up our fireball animation. For each of the imported fireball sprites, go to the "Import" tab,\r\nuncheck "Filter" and click "Reimport" - just like for our pixel art player sprite, this will ensure that these sprites\r\nmaintain their blocky pixel form even on high-resolution displays.\n\nNow, click the "AnimatedSprite" node, and on the right in the "Frames" field, click where it says "\\[empty]" and select\r\n"New SpriteFrames". Then click the field again and you should be brought to an editor view where we can add our animation.\r\nClick and drag the `fireball_1.png` and `fireball_2.png` files from the "Assets" directory into the "Animation Frames" box:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_animation.png" alt="Create the fireball animation." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nNext, click the "AnimatedSprite" node again to bring up the "Inspector" tab for this node again, check the box titled "Playing".\r\nIn the lower-left of the "Animations" tab, change the "Speed" field to "12 FPS". The fireball should now be animated in the editor:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646784180/blog/2022/03/deepgram-godot-tutorial/assets/fireball_editor_cropped_animated.gif" alt="The fireball animation in the editor." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nThere are certainly several tabs and fields to navigate through in this process, but I hope you find some of these operations intuitive!\r\nTo create animations, you drag the individual frames into the "Animation Frames"\r\nbox, you can then change the speed of the animation just left of this box, and you can set which animation plays by default\r\nin the "Animation" field of the "Inspector" tab for the "AnimatedSprite" node - here you can also set whether the animation\r\nis turned on or off with the "Playing" check box.\n\nNow, click the "CollisionShape2D" node, and in the "Inspector" tab for the "Shape" field select "New CircleShape2D". Then\r\nclick the "CicleShape2D" to edit it\'s properties and change its radius to 4:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_hitbox.png" alt="Setting the fireball\'s hit-box." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nNow, save the scene as `Fireball.tscn` in the "Scenes" directory, and then attach a script to the root node. Make the contents\r\nof the script as follows:\n\n    extends Area2D\r\n\r\n    export var speed = 220\r\n    var direction = Vector2(0, 0)\r\n\r\n    func _physics_process(delta):\r\n    	var velocity = direction.normalized() * speed\r\n\r\n    	rotation = velocity.angle()\r\n    	position += velocity * delta\r\n\r\n    	if position.x > 320 + 16:\r\n    		get_tree().queue_delete(self)\r\n    	if position.x < 0 - 16:\r\n    		get_tree().queue_delete(self)\r\n    	if position.y > 240 + 16:\r\n    		get_tree().queue_delete(self)\r\n    	if position.y < 0 - 16:\r\n    		get_tree().queue_delete(self)\n\nLike with the "Player" scene, we are extending the root node\'s class, in this case an "Area2D." We will give each fireball object\r\na speed and a direction. When `_physics_process` is called, we will update the fireball\'s position and angle according to\r\nthe fireball\'s direction and speed. If the fireball goes off-screen, we will destroy it using `get_tree().queue_delete(self)`.\n\nThat\'s all there is to the "Fireball" scene, but we haven\'t actually added any fireballs to our game. We could do this by instancing\r\na "Fireball" scene in our "Game" scene, but for these kinds of objects, there\'s a better way - we should spawn them via code!\n\n## Triggering the Fireball With Keystrokes\n\nGo to the "Game" scene and add a script to the root node, just like we did for the "Player" scene.\r\nThen edit `Game.gd` to have the following contents:\n\n    extends Node2D\r\n\r\n    var rng = RandomNumberGenerator.new()\r\n\r\n    func _ready():\r\n    	rng.randomize()\r\n\r\n    func _input(event):\r\n    	if event is InputEventKey and event.pressed:\r\n    		if event.scancode == KEY_F:\r\n    			for i in rng.randi_range(2, 5):\r\n    				spawn_fireball()\r\n\r\n    func spawn_fireball():\r\n    	var fireball = load("res://Scenes/Fireball.tscn").instance()\r\n    	add_child(fireball)\r\n\r\n    	var random_angle = rng.randf_range(0.0, 2 * PI)\r\n    	fireball.direction = Vector2(cos(random_angle), sin(random_angle))\r\n    	fireball.rotation = fireball.direction.angle()\r\n    	fireball.position = $Player.position\n\nThe first line, `extends Node2D`, is essentially saying that this object is extending the "Node2D" class.\r\nThen, we create a global variable for this object called `rng` which will be used for random number generation.\r\nNext, we define the `_ready()` method which is called when an instance of this scene gets created - in this\r\nmethod we are initializing our random number generator.\n\nThe `_input(event)` method gets called every time there was an input event such as a keystroke, a mouse click,\r\na touch, a game-pad button press, etc. In our case, we are looking to see if the "F" key was pressed, and if\r\nso, we want to spawn 2-5 fireballs!\n\nThe logic handling the spawning of fireballs occurs in the method `spawn_fireball()`. Here we create an instance\r\nof our "Fireball" scene, add it as a child of the current scene, and then initialize the fireball\'s direction,\r\nrotation, and position. We are setting the fireball to spawn exactly where the player object is located,\r\nand we are setting the fireball\'s direction to be totally random.\n\nThe syntax `$Player` is syntax sugar\r\nfor `get_node("Player")` and requires that our "Game" scene has a child node named "Player" (which it does!).\r\nHowever, since GDScript is very much like Python, the game will build and run just fine if one makes\r\na reference to a non-existent object - this will be caught only when the program reaches that line of code,\r\nand it will cause a crash. As Python developers are likely aware, this is sometimes one of the trade-offs of\r\nhaving a "quick and easy" language.\n\nYou should now be able to play the game, move the player around, and press "F" to fire off fireballs! Now\r\nthat the basic game is complete, let\'s add the juicy part by triggering the fireballs not with key presses,\r\nbut with your voice!\n\n## Triggering the Fireball With Your Voice\n\nFinally, let\'s do our Deepgram integration so that we can spawn fireballs by saying "fire" into the microphone instead\r\nof pressing a key. To do this, grab the `DeepgramIntegration` directory from `Scenes/DeepgramIntegration`\r\nfrom the [the SpeechSpells repository](https://github.com/deepgram/SpeechSpells) and place it in the `Scenes/` directory in the Godot editor.\n\nThis integration contains two Godot scenes with accompanying scripts: `MicrophoneInstance` and `DeepgramInstance`.\r\nWe won\'t go over the inner-workings of these scripts in detail, but feel free to have a look as they have\r\na fair amount of descriptive comments to help explain what is going on. In a nutshell, the `MicrophoneInstance`\r\ninterfaces with your device\'s microphone and streams the raw audio from the microphone via Godot signals\r\nto the `DeepgramInstance` which handles connecting to Deepgram via Websockets.\r\nThe `DeepgramInstance` then forwards the raw microphone audio to Deepgram, receives ASR results from Deepgram,\r\nand then forwards those results via Godot signals to some other node. In our case, this other node will be\r\nour "Game" scene\'s root node.\n\n***\n\n***Note***: A common issue which causes the microphone capture to fail on Mac is if Godot\'s audio sample rate is set to\r\nsomething different then the OS\'s audio sample rate. If you experience issues with microphone capture on Mac, you\r\ncan check your OS\'s audio sample rate under `Utilities -> Audio Midi Setup`.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646351903/blog/2022/03/deepgram-godot-tutorial/assets/mac_sample_rate_settings.png" alt="Mac audio sample rate settings." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\n***\n\n***\n\n***Note***: This integration will not work for Godot\'s HTML5 builds out-of-the-box\r\nas authenticating websockets connections with headers is not supported for these builds due to\r\nsome authentication limitations of browsers. If you plan on making an HTML5 game with the Deepgram\r\nintegration, you will have to deploy a proxy server for authentication and make some minor adjustments\r\nof the `DeepgramInstance` scene. This may be a topic of a future guide!\n\n***\n\nIn your "Game" scene, add as a child an instance of the "DeepgramInstance" scene, then modify `Game.gd` as follows:\n\n    extends Node2D\r\n\r\n    var rng = RandomNumberGenerator.new()\r\n\r\n    func _ready():\r\n    	rng.randomize()\r\n    	$DeepgramInstance.initialize("INSERT_YOUR_API_KEY_HERE")\r\n\r\n    func _on_DeepgramInstance_message_received(message):\r\n    	var message_json = JSON.parse(message)\r\n    	if message_json.error == OK:\r\n    		if typeof(message_json.result) == TYPE_DICTIONARY:\r\n    			if message_json.result.has("is_final"):\r\n    				if message_json.result["is_final"] == true:\r\n    					var message_transcript = message_json.result["channel"]["alternatives"][0]["transcript"]\r\n    					print("Transcript received: " + message_transcript)\r\n    					for _i in message.count("fire"):\r\n    						spawn_fireball()\r\n\r\n    	else:\r\n    		print("Failed to parse Deepgram message!")\r\n\r\n    func spawn_fireball():\r\n    	var fireball = load("res://Scenes/Fireball.tscn").instance()\r\n    	add_child(fireball)\r\n\r\n    	var random_angle = rng.randf_range(0.0, 2 * PI)\r\n    	fireball.direction = Vector2(cos(random_angle), sin(random_angle))\r\n    	fireball.rotation = fireball.direction.angle()\r\n    	fireball.position = $Player.position\n\nRemember to replace `INSERT_YOUR_API_KEY_HERE` with your Deepgram API Key.\n\nNow, to finish up, click your "Game" scene\'s "DeepgramInstance" node and in the right panel click the "Node" tab (it should be right next\r\nto the "Inspector" tab). You should see a `message_received()` signal listed under `DeepgramInstance.gd` - double click this,\r\nmake sure that the "Game" node is highlighted, and click "connect".\n\nWhat is this signal doing? Signals are a useful way to organize the transmission of events in game engines.\r\nIn this particular case, the "DeepgramInstance" node is signaling to its parent "Game" node that it has received a message from Deepgram.\r\nIt passes this message with the signal, the parent "Game" node can then react to the signal to trigger further logic.\n\nIn our case, the "Game" node handles this signal in the `_on_DeepgramInstance_message_received` method where tries to parse\r\nthe JSON message from Deepgram into a data structure similar to a Dictionary using `JSON.parse(message)`.\n\nAfter verifying that the message successfully parsed as a Dictionary, it checks to see whether this is a final result or an interim result.\r\nTo understand the difference between final and interim results in the Deepgram realtime streaming API, check out [this page](https://developers.deepgram.com/documentation/features/interim-results/).\r\nFor our purposes, we are only considering final results. We then grab the transcript from the first alternative in the\r\nASR result, and count how many times the word "fire" appears in the transcript, spawning one fireball for each occurrence.\n\n## Build New Features\n\nSo now you can walk around and cast fireball spells with your voice! Here are some ideas for next steps\r\nyou may want to try out to make a more fully-featured game:\n\n*   Implement more spells! Try a thunder spell, or an ice beam spell.\n*   Add enemies and implement collision detection to destroy enemies when your spells hit them.\n*   Try using [interim results](https://developers.deepgram.com/documentation/features/interim-results/) instead of just final results - this should decrease the latency of the spells substantially, but you will need to watch out for\r\n    double-counting as multiple interim results will give transcripts for the same section of audio!\n*   Play around with Deepgram\'s `keyword`, `search`, and/or `phoneme` features to implement spells for out-of-vocab words.\n*   If you are feeling ambitious, work through some Godot networking tutorials to create a multiplayer game where you and your friends cast spells at each other!\n\n## Final Thoughts\n\nSpeech-enhanced games have actually been around for quite some time, with popular titles such as "Hey You, Pikachu!" and "Seaman",\r\nbut it hasn\'t been until more recently that ASR engines have really taken off and can start to offer gameplay experiences which are deeper\r\nthan the simple command-based games of the past which only understood a few phrases. With modern ASR engines like Deepgram\'s, understanding\r\nthousands of commands has become trivial, and much more interesting and complex uses for speech in games is now possible. I encourage anyone\r\ninterested to try things out and explore with us what the future of speech in games might look like! Off the top of my head, I want to lastly\r\nshare some game ideas to get the creative juices flowing in the community:\n\n*   An RPG where warriors fight with swords, archers fight with bows, and mages fight with... speech! Take the "casting spells" approach of this\r\n    tutorial and expand it to a game about incantations! (See "In Verbis Virtus" for even more inspiration here!)\n*   Speech-enhanced mini-games: imagine playing a Zelda-esque game where you walk into a town and go to the nearest mini-game building and have\r\n    to play word games ala "Wheel of Fortune" to win your next upgrade!\n*   Games fully controllable via speech: traditional turn-based games are a great candidate to integrate speech controls, and this could greatly\r\n    increase the accessibility of such games! This type of technology does exist, but it can likely be greatly improved with new powerful ASR engines\r\n    like Deepgram.\n*   Casual social games: imagine playing word and speech-based games in an environment like VR chat!\n*   AI-based visual novels: imagine playing a visual novel where instead of picking from a list of phrases to progress, you simply say what\'s on your mind!\n*   AAA AI-enhanced experiences: take the visual novel idea to the next level and enhance AI components of AAA titles by allowing your character to\r\n    talk to NPCs with a microphone! (Check out games like "Phasmophobia" for even more inspiration here!)\n\nIf you have any questions, please feel free to reach out on Twitter - we\'re @DeepgramDevs.\n\n        ', "html": '<p>In this post, we will be making a simplified version of the 2D game \u201CSpooky Speech Spells\u201D (which you can play <a href="https://spookyspeechspells.deepgram.com">here</a>)\r\nin the Godot game engine using an integration with the Deepgram automatic speech recognition (ASR) engine. Why Godot? Because it is an\r\neasy-to-learn, open-source alternative to the popular industry-standard Unity and can export directly to Mac, Windows, Linux, iOS,\r\nAndroid, and HTML5. Why Deepgram? Because it is the fastest, most accurate, cheapest, and easiest to use ASR engine out there! And why\r\nmake a speech-enhanced game? Well, because it\u2019s cool, and games are fun! Beyond that, adding nontraditional input devices can help make your games more accessible.</p>\n<p>This tutorial is focusing on adding voice input to your game, but if you want to see more tutorials, you can find plenty on the\r\n<a href="https://docs.godotengine.org/en/stable/community/tutorials.html">Godot website</a>.</p>\n<h2 id="pre-requisites">Pre-requisites</h2>\n<p>You will need:</p>\n<ul>\n<li>Godot installed on your machine - <a href="https://godotengine.org/download">download Godot here</a>. This tutorial was written with version <code is:raw>3.4.3</code>.</li>\n<li>A Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get an API Key here</a>.</li>\n</ul>\n<h2 id="try-the-game">Try the Game</h2>\n<p>To run the game we are going to build and browse its files:</p>\n<ul>\n<li>Download <a href="https://github.com/deepgram/SpeechSpells">this repository</a>, open Godot, click \u201CImport\u201D, and browse to and select the <code is:raw>project.godot</code> file from the repo.</li>\n<li>In the Godot editor, go to the \u201CFileSystem\u201D tab in the lower left, and navigate to and open <code is:raw>Scenes/Game.gd</code>.</li>\n<li>Edit <code is:raw>line 7</code> of <code is:raw>Scenes/Game.gd</code> and enter your Deepgram API Key.</li>\n<li>In the top right of the Godot editor, hit the \u201CPlay\u201D (\u25BA) button.</li>\n<li>Move your character with <code is:raw>WASD</code> and say \u201Cfire\u201D to cast fire spells!</li>\n</ul>\n<h2 id="building-the-game">Building the Game</h2>\n<p>In the following sub-sections, we will walk through step-by-step how to make a game where you can move\r\na character around the screen and have the character cast fireball spells by chanting \u201Cfire!\u201D into your\r\nmicrophone.</p>\n<h2 id="setting-up-the-project">Setting Up the Project</h2>\n<p>Open Godot and create a \u201CNew Project\u201D in the project manager.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/new_project.png" alt="Create a new project." style="max-width: 1037px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Now click \u201CBrowse\u201D and choose a directory on your filesystem to store the project, and in the \u201CProject Name\u201D\r\nfield, write \u201CSpeechSpells\u201D and hit \u201CCreate Folder.\u201D Finally, hit \u201CCreate and Edit,\u201D and we\u2019ll get to the Godot\r\nEditor, where we can build our game.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/set_project_name.png" alt="Set the name of the new project." style="max-width: 1038px;display: block;margin-left: auto;margin-right: auto;" />\n<p>The Godot Editor consists of several panels and tabs, and we will be going over the ones we need to interact\r\nwith to build \u201CSpeech Spells\u201D.</p>\n<p>Let\u2019s start with the \u201CScene\u201D tab in the upper left panel. In this tab, we can put together \u201CScenes,\u201D which,\r\ntogether with \u201CNodes,\u201D form the basic building blocks of Godot games. Scenes and nodes are classes\r\nin object-oriented programming terminology, but the Godot Editor offers an intuitive way to create, edit,\r\nand manage our various game objects as scenes and nodes. Scenes can be almost anything - a collection\r\nof sprite nodes, a character with animations, attacks, and hit-boxes, or just a collection of scripts\r\nthat execute algorithms and can emit signals to other nodes (we will see this pattern further on). For now,\r\nwhere it says \u201CCreate Root Node\u201D click \u201C2D Scene\u201D and double click the name of the resulting node and rename\r\nit to \u201CGame\u201D. We will create a few other scenes for this game and add instances of those scenes to our Game\r\nscene.</p>\n<p>Before saving the scene, let\u2019s head over to the lower right \u201CFilesystem\u201D tab. Right-click in the filesystem\r\nbrowser there and click \u201CNew Folder\u2026\u201D to create a folder called \u201CScenes\u201D and then a folder called \u201CAssets\u201D.\r\nYou may, of course, organize your projects however you like, but this is at least one way of doing it.</p>\n<p>Click on <code is:raw>Scene -&gt; Save Scene</code> in the upper left corner of the editor to save this scene as <code is:raw>Game.tscn</code> in the \u201CScenes\u201D directory that you just created.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/create_folders.png" alt="Set up the game directory structure." style="max-width: 249px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Now, go to <code is:raw>Project -&gt; Project Settings</code> from the upper left bar, and we will set a couple of properties of our game.\r\nStart by navigating to <code is:raw>Rendering -&gt; Environment</code> and change the \u201CDefault Clear Color\u201D to black.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/default_clear_color.png" alt="Change the default clear color." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Next, navigate to <code is:raw>Display -&gt; Window</code>, uncheck \u201CResizable\u201D, set the \u201CWidth\u201D to 320, the \u201CHeight\u201D to 240,\r\nthe \u201CTest Width\u201D to 960, the \u201CTest Height\u201D to 720, the \u201CStretch\u201D \u201CMode\u201D to \u201C2d\u201D and the\r\nStretch \u201CAspect\u201D to \u201CKeep\u201D. This is setting us up to build a game\r\nwith a very low resolution close to 240p (common for 8-bit pixel games), but when we run the game it will\r\ndisplay in a nice big 960x720 window, effectively tripling the size of the pixels. Godot has many options\r\nunder <code is:raw>Display -&gt; Window</code>, and understanding these can enable you to effortlessly build games that look\r\nfantastic at multiple resolutions and multiple aspect ratios targeting different devices without ever\r\nhaving to think about anything other than your base resolution (320x240 in our case)!</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646549594/blog/2022/03/deepgram-godot-tutorial/assets/change_window_settings.png" alt="Set the window settings." style="max-width: 986px;display: block;margin-left: auto;margin-right: auto;" />\n<p>We have one more setting to change - navigate to <code is:raw>Application -&gt; Audio</code> and check \u201CEnable Audio Input\u201D.\r\nA warning will appear saying you will need to restart the editor for this to take effect, click the button\r\nthat appears in the lower right (\u201CSave & Restart\u201D) to do so.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/enable_audio.png" alt="Enable audio." style="max-width: 911px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Finally, click the \u201CPlay\u201D button in the upper right (or press \u201CF5\u201D) to start up the game - since this is the\r\nfirst time we are playing the game, you will be asked to tell Godot which scene you want to start when the\r\ngame is first opened - we only have <code is:raw>Game.tscn</code> so select that one. We now have a blank canvas ready to be filled!</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/press_play.png" alt="Start the game." style="max-width: 310px;display: block;margin-left: auto;margin-right: auto;" />\n<h2 id="creating-a-player">Creating a Player</h2>\n<p>Now that we have a running game in a window let\u2019s create a player to move around. In the top left of\r\nthe Godot editor, click <code is:raw>Scene -&gt; New Scene</code>. Like when you first opened this project, the \u201CScene\u201D tab\r\nwill give you some options for the root node. Click \u201COther Node\u201D and navigate to, or use the search\r\nfield to find \u201CKinematicBody2D\u201D and click \u201CCreate.\u201D</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/create_kinematic_body_2d.png" alt="Create a KinematicBody2D." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;" />\n<p>\u201CKinematicBody2D\u201D is one of the most reasonable types of objects to use for controllable characters.\r\nThis class/node offers convenient methods to make moving and handling collisions with various objects\r\neasy - we will discuss one of these methods shortly.</p>\n<p>Now, right-click the root node and click \u201CAdd Child Node\u201D and create a \u201CSprite\u201D node. Do this again\r\nand add a \u201CCollisionShape2D\u201D node. Your node structure should now look like the following:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/player_node_structure.png" alt="The node structure of the Player - the `KinematicBody2D` root node here contains a `Sprite` node and `CollisionShape2D` node as children." style="max-width: 250px;display: block;margin-left: auto;margin-right: auto;" />\n<p>The \u201CSprite\u201D node will contain the image to use for our player. We will use a pixel art\r\nimage of a skull for our player; you can download it <a href="https://res.cloudinary.com/deepgram/image/upload/v1646849910/blog/2022/03/deepgram-godot-tutorial/assets/skull.png">here</a>. Drag the\r\nfile into the \u201CAssets\u201D directory in the \u201CFilesystem\u201D tab in the lower left, then click on the \u201CImport\u201D\r\ntab next to the \u201CScene\u201D tab, uncheck \u201CFilter\u201D and click \u201CReimport\u201D:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/import_skull.png" alt="Import the skull image." style="max-width: 245px;display: block;margin-left: auto;margin-right: auto;" />\n<p>This is importing the image into our project and telling our project not to apply interpolation\r\nwhen scaling the image should the window size change from the base window size (which is a tiny\r\n320x240 for us). Most art assets ought to have some interpolation applied when scaling to smaller\r\n(or larger) resolutions, but this looks notoriously bad for pixel art, where one would expect\r\nthe sharp and blocky sprite to remain sharp and blocky at any resolution.</p>\n<p>Now, navigate back to the \u201CScene\u201D tab, click on the \u201CSprite\u201D node, and drag and drop <code is:raw>skull.png</code>\r\nfrom the \u201CAsset\u201D directory to the \u201CTexture\u201D field:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/set_skull_texture.png" alt="Set the Player\'s sprite texture." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>After doing this, you should see an image in the scene\u2019s 2D view. Finally, some graphics!\r\nYou may want to play around with zooming in or out to get a better view.</p>\n<p>Now, click on the \u201CCollisionShape2D\u201D node, then click on the \u201CShape\u201D field on the upper right\r\nand select \u201CRectangleShape2D\u201D, and change the \u201CExtents\u201D \u201Cx\u201D and \u201Cy\u201D fields to both be 8:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/add_rectangle_shape_2d.png" alt="Setup the Player\'s CollisionShape2D." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>This is essentially defining the hit-box of the player. We won\u2019t utilize hit-boxes\r\nor collision detection in this tutorial, but it is good practice to learn how to\r\nset up a player as one typically would in a more involved game.</p>\n<p>Rename the root node \u201CPlayer\u201D and then save the scene as <code is:raw>Player.tscn</code> in the \u201CScenes\u201D directory.\r\nNow, with the root node (\u201CPlayer\u201D) selected, hit the button which looks like a script with a green\r\nplus sign on it to create a script for this node:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/attach_script.png" alt="Attach a script to a node." style="max-width: 610px;display: block;margin-left: auto;margin-right: auto;" />\n<p>This will create a <code is:raw>Player.gd</code> script, that will help define how this node functions in the game.\r\n<code is:raw>.gd</code> is the file extension for GDScript source code. GDScript is one of two languages which Godot uses\r\nnatively (the other being a visual programming language which is quite fun!). GDScript is a lot\r\nlike Python, and has a comparatively easy learning curve, helped by the fact that the Godot engine does most of\r\nthe complicated stuff under the hood, leaving the scripting of game objects to be short and quick.\r\nMake the contents of <code is:raw>Player.gd</code> the following, and you may start to note how few lines of code it takes to perform some actions:</p>\n<p>extends KinematicBody2D</p>\n<p>export var speed = 100\r\nvar velocity = Vector2(0, 0)</p>\n<p>func _physics_process(_delta):\r\nif Input.is_key_pressed(KEY_W):\r\nvelocity.y = -speed\r\nelif Input.is_key_pressed(KEY_S):\r\nvelocity.y = speed\r\nelse:\r\nvelocity.y = 0</p>\n<p>if Input.is_key_pressed(KEY_A):\r\nvelocity.x = - speed\r\nelif Input.is_key_pressed(KEY_D):\r\nvelocity.x = speed\r\nelse:\r\nvelocity.x = 0</p>\n<p>var _returned_velocity = move_and_slide(velocity, Vector2(0, 0), false, 4, 0, false)</p>\n<p>if position.x < 0 - 16:\r\nposition.x = 320 + 16\r\nif position.x > 320 + 16:\r\nposition.x = 0 - 16</p>\n<p>if position.y < 0 - 16:\r\nposition.y = 240 + 16\r\nif position.y > 240 + 16:\r\nposition.y = 0 - 16</p>\n<p>The first line, <code is:raw>extends KinematicBody2D</code>, is telling us that our script is an extension of the \u201CKinematicBody2D\u201D class,\r\nmeaning we will be able to access any methods and variables that the \u201CKinematicBody2D\u201D class offers, plus any variables\r\nand methods that we introduce here in this file. We then define the variables <code is:raw>speed</code> and <code is:raw>velocity</code>. We will use <code is:raw>velocity</code>\r\nto mean the velocity of the player at any given time, and <code is:raw>speed</code> to mean the maximum horizontal or vertical speed of the\r\nplayer when we move the player.</p>\n<p>Next comes the method <code is:raw>_physics_process(_delta)</code>. This is a method accessible to many Godot nodes, and is executed\r\nroughly 60 times per second, allowing us to alter objects in a way that the physics engine can understand.\r\nThe \u201Cdelta\u201D argument is the amount of time that has passed since the last call to <code is:raw>_physics_process</code>, but here we\r\nare not using it, so we place an underscore in front of the argument name to avoid a warning.</p>\n<p>In this method, we check if the <code is:raw>WASD</code> keys are pressed, and modify the player\u2019s velocity accordingly (\u201CW\u201D to move up,\r\n\u201CA\u201D to move left, \u201CS\u201D to move down, and \u201CD\u201D to move right). Note that to move up, we set the \u201Cy\u201D velocity to <code is:raw>-speed</code> - this\r\nis because Godot, like many game engines, considers <em>down</em> to be the positive y-direction.</p>\n<p>After adjusting the player\u2019s velocity, we call the <code is:raw>move_and_slide</code> method, specifying the velocity as one of its arguments\r\n(the others don\u2019t matter for now). This method does a lot of logic internally and can handle collisions with static bodies\r\nand rigid bodies, of any shape or size, and correctly move the player along the surface of bodies instead of bouncing\r\noff of them (hence the \u201Cslide\u201D). The method returns the resulting velocity of the player after any collisions/slides,\r\nbut since we won\u2019t be using this, we place an underscore to avoid a warning.</p>\n<p>Lastly, we check and modify the position of the player to wrap around the window - i.e. if the player moves too far to the left,\r\nhave them wrap to the right side of the window.</p>\n<p>Save, and finally go back to the \u201CGame\u201D scene, and click the button at the top of the \u201CScene\u201D tab to \u201CInstance Child Scene\u201D:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/instance_child_scene.png" alt="Instance a child scene." style="max-width: 626px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Select the <code is:raw>Player.tscn</code> we just created. Now our main \u201CGame\u201D scene has a \u201CPlayer\u201D scene as a child node! Click the \u201CPlay\u201D button\r\nand now the game boots up with a skull in the corner - you can move the skull around with <code is:raw>WASD</code>! Feel free to reposition the skull\r\nin the \u201CGame\u201D scene - you can either click and drag the player in the 2D view, or you can directly enter the x and y position\r\nin <code is:raw>Node2D -&gt; Transform -&gt; Position</code> in the \u201CInspector\u201D tab when the \u201CPlayer\u201D node is selected in the \u201CGame\u201D scene:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646785008/blog/2022/03/deepgram-godot-tutorial/assets/player_position_in_editor.png" alt="Setting the Player\'s position." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<h2 id="creating-a-fireball">Creating a Fireball</h2>\n<p>Let\u2019s make a fireball scene which we will use to have the player shooting fireballs across the screen.\r\nCreate a new scene, for the root node click \u201COther Node\u201D and pick \u201CArea2D\u201D. Rename this root node \u201CFireball\u201D.\r\nAdd two child nodes: an \u201CAnimatedSprite\u201D and a \u201CCollisionShape2D\u201D.</p>\n<p>Next, import into your \u201CAssets\u201D directory <a href="https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_1.png">fireball_1.png</a>\r\nand <a href="https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_2.png">fireball_2.png</a>.\r\nThe two sprites will make up our fireball animation. For each of the imported fireball sprites, go to the \u201CImport\u201D tab,\r\nuncheck \u201CFilter\u201D and click \u201CReimport\u201D - just like for our pixel art player sprite, this will ensure that these sprites\r\nmaintain their blocky pixel form even on high-resolution displays.</p>\n<p>Now, click the \u201CAnimatedSprite\u201D node, and on the right in the \u201CFrames\u201D field, click where it says \u201C[empty]\u201D and select\r\n\u201CNew SpriteFrames\u201D. Then click the field again and you should be brought to an editor view where we can add our animation.\r\nClick and drag the <code is:raw>fireball_1.png</code> and <code is:raw>fireball_2.png</code> files from the \u201CAssets\u201D directory into the \u201CAnimation Frames\u201D box:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_animation.png" alt="Create the fireball animation." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Next, click the \u201CAnimatedSprite\u201D node again to bring up the \u201CInspector\u201D tab for this node again, check the box titled \u201CPlaying\u201D.\r\nIn the lower-left of the \u201CAnimations\u201D tab, change the \u201CSpeed\u201D field to \u201C12 FPS\u201D. The fireball should now be animated in the editor:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646784180/blog/2022/03/deepgram-godot-tutorial/assets/fireball_editor_cropped_animated.gif" alt="The fireball animation in the editor." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>There are certainly several tabs and fields to navigate through in this process, but I hope you find some of these operations intuitive!\r\nTo create animations, you drag the individual frames into the \u201CAnimation Frames\u201D\r\nbox, you can then change the speed of the animation just left of this box, and you can set which animation plays by default\r\nin the \u201CAnimation\u201D field of the \u201CInspector\u201D tab for the \u201CAnimatedSprite\u201D node - here you can also set whether the animation\r\nis turned on or off with the \u201CPlaying\u201D check box.</p>\n<p>Now, click the \u201CCollisionShape2D\u201D node, and in the \u201CInspector\u201D tab for the \u201CShape\u201D field select \u201CNew CircleShape2D\u201D. Then\r\nclick the \u201CCicleShape2D\u201D to edit it\u2019s properties and change its radius to 4:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_hitbox.png" alt="Setting the fireball\'s hit-box." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Now, save the scene as <code is:raw>Fireball.tscn</code> in the \u201CScenes\u201D directory, and then attach a script to the root node. Make the contents\r\nof the script as follows:</p>\n<p>extends Area2D</p>\n<p>export var speed = 220\r\nvar direction = Vector2(0, 0)</p>\n<p>func _physics_process(delta):\r\nvar velocity = direction.normalized() * speed</p>\n<p>rotation = velocity.angle()\r\nposition += velocity * delta</p>\n<p>if position.x > 320 + 16:\r\nget_tree().queue_delete(self)\r\nif position.x < 0 - 16:\r\nget_tree().queue_delete(self)\r\nif position.y > 240 + 16:\r\nget_tree().queue_delete(self)\r\nif position.y < 0 - 16:\r\nget_tree().queue_delete(self)</p>\n<p>Like with the \u201CPlayer\u201D scene, we are extending the root node\u2019s class, in this case an \u201CArea2D.\u201D We will give each fireball object\r\na speed and a direction. When <code is:raw>_physics_process</code> is called, we will update the fireball\u2019s position and angle according to\r\nthe fireball\u2019s direction and speed. If the fireball goes off-screen, we will destroy it using <code is:raw>get_tree().queue_delete(self)</code>.</p>\n<p>That\u2019s all there is to the \u201CFireball\u201D scene, but we haven\u2019t actually added any fireballs to our game. We could do this by instancing\r\na \u201CFireball\u201D scene in our \u201CGame\u201D scene, but for these kinds of objects, there\u2019s a better way - we should spawn them via code!</p>\n<h2 id="triggering-the-fireball-with-keystrokes">Triggering the Fireball With Keystrokes</h2>\n<p>Go to the \u201CGame\u201D scene and add a script to the root node, just like we did for the \u201CPlayer\u201D scene.\r\nThen edit <code is:raw>Game.gd</code> to have the following contents:</p>\n<p>extends Node2D</p>\n<p>var rng = RandomNumberGenerator.new()</p>\n<p>func _ready():\r\nrng.randomize()</p>\n<p>func _input(event):\r\nif event is InputEventKey and event.pressed:\r\nif event.scancode == KEY_F:\r\nfor i in rng.randi_range(2, 5):\r\nspawn_fireball()</p>\n<p>func spawn_fireball():\r\nvar fireball = load(\u201Cres://Scenes/Fireball.tscn\u201D).instance()\r\nadd_child(fireball)</p>\n<p>var random_angle = rng.randf_range(0.0, 2 * PI)\r\nfireball.direction = Vector2(cos(random_angle), sin(random_angle))\r\nfireball.rotation = fireball.direction.angle()\r\nfireball.position = $Player.position</p>\n<p>The first line, <code is:raw>extends Node2D</code>, is essentially saying that this object is extending the \u201CNode2D\u201D class.\r\nThen, we create a global variable for this object called <code is:raw>rng</code> which will be used for random number generation.\r\nNext, we define the <code is:raw>_ready()</code> method which is called when an instance of this scene gets created - in this\r\nmethod we are initializing our random number generator.</p>\n<p>The <code is:raw>_input(event)</code> method gets called every time there was an input event such as a keystroke, a mouse click,\r\na touch, a game-pad button press, etc. In our case, we are looking to see if the \u201CF\u201D key was pressed, and if\r\nso, we want to spawn 2-5 fireballs!</p>\n<p>The logic handling the spawning of fireballs occurs in the method <code is:raw>spawn_fireball()</code>. Here we create an instance\r\nof our \u201CFireball\u201D scene, add it as a child of the current scene, and then initialize the fireball\u2019s direction,\r\nrotation, and position. We are setting the fireball to spawn exactly where the player object is located,\r\nand we are setting the fireball\u2019s direction to be totally random.</p>\n<p>The syntax <code is:raw>$Player</code> is syntax sugar\r\nfor <code is:raw>get_node("Player")</code> and requires that our \u201CGame\u201D scene has a child node named \u201CPlayer\u201D (which it does!).\r\nHowever, since GDScript is very much like Python, the game will build and run just fine if one makes\r\na reference to a non-existent object - this will be caught only when the program reaches that line of code,\r\nand it will cause a crash. As Python developers are likely aware, this is sometimes one of the trade-offs of\r\nhaving a \u201Cquick and easy\u201D language.</p>\n<p>You should now be able to play the game, move the player around, and press \u201CF\u201D to fire off fireballs! Now\r\nthat the basic game is complete, let\u2019s add the juicy part by triggering the fireballs not with key presses,\r\nbut with your voice!</p>\n<h2 id="triggering-the-fireball-with-your-voice">Triggering the Fireball With Your Voice</h2>\n<p>Finally, let\u2019s do our Deepgram integration so that we can spawn fireballs by saying \u201Cfire\u201D into the microphone instead\r\nof pressing a key. To do this, grab the <code is:raw>DeepgramIntegration</code> directory from <code is:raw>Scenes/DeepgramIntegration</code>\r\nfrom the <a href="https://github.com/deepgram/SpeechSpells">the SpeechSpells repository</a> and place it in the <code is:raw>Scenes/</code> directory in the Godot editor.</p>\n<p>This integration contains two Godot scenes with accompanying scripts: <code is:raw>MicrophoneInstance</code> and <code is:raw>DeepgramInstance</code>.\r\nWe won\u2019t go over the inner-workings of these scripts in detail, but feel free to have a look as they have\r\na fair amount of descriptive comments to help explain what is going on. In a nutshell, the <code is:raw>MicrophoneInstance</code>\r\ninterfaces with your device\u2019s microphone and streams the raw audio from the microphone via Godot signals\r\nto the <code is:raw>DeepgramInstance</code> which handles connecting to Deepgram via Websockets.\r\nThe <code is:raw>DeepgramInstance</code> then forwards the raw microphone audio to Deepgram, receives ASR results from Deepgram,\r\nand then forwards those results via Godot signals to some other node. In our case, this other node will be\r\nour \u201CGame\u201D scene\u2019s root node.</p>\n<hr>\n<p><em><strong>Note</strong></em>: A common issue which causes the microphone capture to fail on Mac is if Godot\u2019s audio sample rate is set to\r\nsomething different then the OS\u2019s audio sample rate. If you experience issues with microphone capture on Mac, you\r\ncan check your OS\u2019s audio sample rate under <code is:raw>Utilities -&gt; Audio Midi Setup</code>.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646351903/blog/2022/03/deepgram-godot-tutorial/assets/mac_sample_rate_settings.png" alt="Mac audio sample rate settings." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<hr>\n<hr>\n<p><em><strong>Note</strong></em>: This integration will not work for Godot\u2019s HTML5 builds out-of-the-box\r\nas authenticating websockets connections with headers is not supported for these builds due to\r\nsome authentication limitations of browsers. If you plan on making an HTML5 game with the Deepgram\r\nintegration, you will have to deploy a proxy server for authentication and make some minor adjustments\r\nof the <code is:raw>DeepgramInstance</code> scene. This may be a topic of a future guide!</p>\n<hr>\n<p>In your \u201CGame\u201D scene, add as a child an instance of the \u201CDeepgramInstance\u201D scene, then modify <code is:raw>Game.gd</code> as follows:</p>\n<p>extends Node2D</p>\n<p>var rng = RandomNumberGenerator.new()</p>\n<p>func _ready():\r\nrng.randomize()\r\n$DeepgramInstance.initialize(\u201CINSERT_YOUR_API_KEY_HERE\u201D)</p>\n<p>func _on_DeepgramInstance_message_received(message):\r\nvar message_json = JSON.parse(message)\r\nif message_json.error == OK:\r\nif typeof(message_json.result) == TYPE_DICTIONARY:\r\nif message_json.result.has(\u201Cis_final\u201D):\r\nif message_json.result[\u201Cis_final\u201D] == true:\r\nvar message_transcript = message_json.result[\u201Cchannel\u201D][\u201Calternatives\u201D][0][\u201Ctranscript\u201D]\r\nprint(\u201CTranscript received: \u201D + message_transcript)\r\nfor _i in message.count(\u201Cfire\u201D):\r\nspawn_fireball()</p>\n<p>else:\r\nprint(\u201CFailed to parse Deepgram message!\u201C)</p>\n<p>func spawn_fireball():\r\nvar fireball = load(\u201Cres://Scenes/Fireball.tscn\u201D).instance()\r\nadd_child(fireball)</p>\n<p>var random_angle = rng.randf_range(0.0, 2 * PI)\r\nfireball.direction = Vector2(cos(random_angle), sin(random_angle))\r\nfireball.rotation = fireball.direction.angle()\r\nfireball.position = $Player.position</p>\n<p>Remember to replace <code is:raw>INSERT_YOUR_API_KEY_HERE</code> with your Deepgram API Key.</p>\n<p>Now, to finish up, click your \u201CGame\u201D scene\u2019s \u201CDeepgramInstance\u201D node and in the right panel click the \u201CNode\u201D tab (it should be right next\r\nto the \u201CInspector\u201D tab). You should see a <code is:raw>message_received()</code> signal listed under <code is:raw>DeepgramInstance.gd</code> - double click this,\r\nmake sure that the \u201CGame\u201D node is highlighted, and click \u201Cconnect\u201D.</p>\n<p>What is this signal doing? Signals are a useful way to organize the transmission of events in game engines.\r\nIn this particular case, the \u201CDeepgramInstance\u201D node is signaling to its parent \u201CGame\u201D node that it has received a message from Deepgram.\r\nIt passes this message with the signal, the parent \u201CGame\u201D node can then react to the signal to trigger further logic.</p>\n<p>In our case, the \u201CGame\u201D node handles this signal in the <code is:raw>_on_DeepgramInstance_message_received</code> method where tries to parse\r\nthe JSON message from Deepgram into a data structure similar to a Dictionary using <code is:raw>JSON.parse(message)</code>.</p>\n<p>After verifying that the message successfully parsed as a Dictionary, it checks to see whether this is a final result or an interim result.\r\nTo understand the difference between final and interim results in the Deepgram realtime streaming API, check out <a href="https://developers.deepgram.com/documentation/features/interim-results/">this page</a>.\r\nFor our purposes, we are only considering final results. We then grab the transcript from the first alternative in the\r\nASR result, and count how many times the word \u201Cfire\u201D appears in the transcript, spawning one fireball for each occurrence.</p>\n<h2 id="build-new-features">Build New Features</h2>\n<p>So now you can walk around and cast fireball spells with your voice! Here are some ideas for next steps\r\nyou may want to try out to make a more fully-featured game:</p>\n<ul>\n<li>Implement more spells! Try a thunder spell, or an ice beam spell.</li>\n<li>Add enemies and implement collision detection to destroy enemies when your spells hit them.</li>\n<li>Try using <a href="https://developers.deepgram.com/documentation/features/interim-results/">interim results</a> instead of just final results - this should decrease the latency of the spells substantially, but you will need to watch out for\r\ndouble-counting as multiple interim results will give transcripts for the same section of audio!</li>\n<li>Play around with Deepgram\u2019s <code is:raw>keyword</code>, <code is:raw>search</code>, and/or <code is:raw>phoneme</code> features to implement spells for out-of-vocab words.</li>\n<li>If you are feeling ambitious, work through some Godot networking tutorials to create a multiplayer game where you and your friends cast spells at each other!</li>\n</ul>\n<h2 id="final-thoughts">Final Thoughts</h2>\n<p>Speech-enhanced games have actually been around for quite some time, with popular titles such as \u201CHey You, Pikachu!\u201D and \u201CSeaman\u201D,\r\nbut it hasn\u2019t been until more recently that ASR engines have really taken off and can start to offer gameplay experiences which are deeper\r\nthan the simple command-based games of the past which only understood a few phrases. With modern ASR engines like Deepgram\u2019s, understanding\r\nthousands of commands has become trivial, and much more interesting and complex uses for speech in games is now possible. I encourage anyone\r\ninterested to try things out and explore with us what the future of speech in games might look like! Off the top of my head, I want to lastly\r\nshare some game ideas to get the creative juices flowing in the community:</p>\n<ul>\n<li>An RPG where warriors fight with swords, archers fight with bows, and mages fight with\u2026 speech! Take the \u201Ccasting spells\u201D approach of this\r\ntutorial and expand it to a game about incantations! (See \u201CIn Verbis Virtus\u201D for even more inspiration here!)</li>\n<li>Speech-enhanced mini-games: imagine playing a Zelda-esque game where you walk into a town and go to the nearest mini-game building and have\r\nto play word games ala \u201CWheel of Fortune\u201D to win your next upgrade!</li>\n<li>Games fully controllable via speech: traditional turn-based games are a great candidate to integrate speech controls, and this could greatly\r\nincrease the accessibility of such games! This type of technology does exist, but it can likely be greatly improved with new powerful ASR engines\r\nlike Deepgram.</li>\n<li>Casual social games: imagine playing word and speech-based games in an environment like VR chat!</li>\n<li>AI-based visual novels: imagine playing a visual novel where instead of picking from a list of phrases to progress, you simply say what\u2019s on your mind!</li>\n<li>AAA AI-enhanced experiences: take the visual novel idea to the next level and enhance AI components of AAA titles by allowing your character to\r\ntalk to NPCs with a microphone! (Check out games like \u201CPhasmophobia\u201D for even more inspiration here!)</li>\n</ul>\n<p>If you have any questions, please feel free to reach out on Twitter - we\u2019re @DeepgramDevs.</p>' };
const frontmatter = { "title": "How to Build a Speech-Enhanced Game with Godot and Deepgram", "description": "Learn how to build a speech-enhanced game with Deepgram's ASR engine and the open-source Godot game engine.", "date": "2022-03-09T00:00:00.000Z", "cover": "https://res.cloudinary.com/deepgram/image/upload/v1646783141/blog/2022/03/deepgram-godot-tutorial/assets/Building-a-Game-w-Godot-Deepgram%402x.jpg", "authors": ["nikola-whallon"], "category": "tutorial", "tags": ["game-dev", "godot"], "seo": { "title": "How to Build a Speech-Enhanced Game with Godot and Deepgram", "description": "Learn how to build a speech-enhanced game with Deepgram's ASR engine and the open-source Godot game engine." }, "shorturls": { "share": "https://dpgr.am/daeaf14", "twitter": "https://dpgr.am/8870f2b", "linkedin": "https://dpgr.am/220032e", "reddit": "https://dpgr.am/79c753a", "facebook": "https://dpgr.am/1794969" }, "og": { "image": "https://res.cloudinary.com/deepgram/image/upload/v1661454020/blog/deepgram-godot-tutorial/ograph.png" }, "astro": { "headings": [{ "depth": 2, "slug": "pre-requisites", "text": "Pre-requisites" }, { "depth": 2, "slug": "try-the-game", "text": "Try the Game" }, { "depth": 2, "slug": "building-the-game", "text": "Building the Game" }, { "depth": 2, "slug": "setting-up-the-project", "text": "Setting Up the Project" }, { "depth": 2, "slug": "creating-a-player", "text": "Creating a Player" }, { "depth": 2, "slug": "creating-a-fireball", "text": "Creating a Fireball" }, { "depth": 2, "slug": "triggering-the-fireball-with-keystrokes", "text": "Triggering the Fireball With Keystrokes" }, { "depth": 2, "slug": "triggering-the-fireball-with-your-voice", "text": "Triggering the Fireball With Your Voice" }, { "depth": 2, "slug": "build-new-features", "text": "Build New Features" }, { "depth": 2, "slug": "final-thoughts", "text": "Final Thoughts" }], "source": '\nIn this post, we will be making a simplified version of the 2D game "Spooky Speech Spells" (which you can play [here](https://spookyspeechspells.deepgram.com))\r\nin the Godot game engine using an integration with the Deepgram automatic speech recognition (ASR) engine. Why Godot? Because it is an\r\neasy-to-learn, open-source alternative to the popular industry-standard Unity and can export directly to Mac, Windows, Linux, iOS,\r\nAndroid, and HTML5. Why Deepgram? Because it is the fastest, most accurate, cheapest, and easiest to use ASR engine out there! And why\r\nmake a speech-enhanced game? Well, because it\'s cool, and games are fun! Beyond that, adding nontraditional input devices can help make your games more accessible.\n\nThis tutorial is focusing on adding voice input to your game, but if you want to see more tutorials, you can find plenty on the\r\n[Godot website](https://docs.godotengine.org/en/stable/community/tutorials.html).\n\n## Pre-requisites\n\nYou will need:\n\n*   Godot installed on your machine - [download Godot here](https://godotengine.org/download). This tutorial was written with version `3.4.3`.\n*   A Deepgram API Key - [get an API Key here](https://console.deepgram.com/signup?jump=keys).\n\n## Try the Game\n\nTo run the game we are going to build and browse its files:\n\n*   Download [this repository](https://github.com/deepgram/SpeechSpells), open Godot, click "Import", and browse to and select the `project.godot` file from the repo.\n*   In the Godot editor, go to the "FileSystem" tab in the lower left, and navigate to and open `Scenes/Game.gd`.\n*   Edit `line 7` of `Scenes/Game.gd` and enter your Deepgram API Key.\n*   In the top right of the Godot editor, hit the "Play" (\u25BA) button.\n*   Move your character with `WASD` and say "fire" to cast fire spells!\n\n## Building the Game\n\nIn the following sub-sections, we will walk through step-by-step how to make a game where you can move\r\na character around the screen and have the character cast fireball spells by chanting "fire!" into your\r\nmicrophone.\n\n## Setting Up the Project\n\nOpen Godot and create a "New Project" in the project manager.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/new_project.png" alt="Create a new project." style="max-width: 1037px;display: block;margin-left: auto;margin-right: auto;">\n\nNow click "Browse" and choose a directory on your filesystem to store the project, and in the "Project Name"\r\nfield, write "SpeechSpells" and hit "Create Folder." Finally, hit "Create and Edit," and we\'ll get to the Godot\r\nEditor, where we can build our game.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/set_project_name.png" alt="Set the name of the new project." style="max-width: 1038px;display: block;margin-left: auto;margin-right: auto;">\n\nThe Godot Editor consists of several panels and tabs, and we will be going over the ones we need to interact\r\nwith to build "Speech Spells".\n\nLet\'s start with the "Scene" tab in the upper left panel. In this tab, we can put together "Scenes," which,\r\ntogether with "Nodes," form the basic building blocks of Godot games. Scenes and nodes are classes\r\nin object-oriented programming terminology, but the Godot Editor offers an intuitive way to create, edit,\r\nand manage our various game objects as scenes and nodes. Scenes can be almost anything - a collection\r\nof sprite nodes, a character with animations, attacks, and hit-boxes, or just a collection of scripts\r\nthat execute algorithms and can emit signals to other nodes (we will see this pattern further on). For now,\r\nwhere it says "Create Root Node" click "2D Scene" and double click the name of the resulting node and rename\r\nit to "Game". We will create a few other scenes for this game and add instances of those scenes to our Game\r\nscene.\n\nBefore saving the scene, let\'s head over to the lower right "Filesystem" tab. Right-click in the filesystem\r\nbrowser there and click "New Folder..." to create a folder called "Scenes" and then a folder called "Assets".\r\nYou may, of course, organize your projects however you like, but this is at least one way of doing it.\n\nClick on `Scene -> Save Scene` in the upper left corner of the editor to save this scene as `Game.tscn` in the "Scenes" directory that you just created.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/create_folders.png" alt="Set up the game directory structure." style="max-width: 249px;display: block;margin-left: auto;margin-right: auto;">\n\nNow, go to `Project -> Project Settings` from the upper left bar, and we will set a couple of properties of our game.\r\nStart by navigating to `Rendering -> Environment` and change the "Default Clear Color" to black.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/default_clear_color.png" alt="Change the default clear color." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;">\n\nNext, navigate to `Display -> Window`, uncheck "Resizable", set the "Width" to 320, the "Height" to 240,\r\nthe "Test Width" to 960, the "Test Height" to 720, the "Stretch" "Mode" to "2d" and the\r\nStretch "Aspect" to "Keep". This is setting us up to build a game\r\nwith a very low resolution close to 240p (common for 8-bit pixel games), but when we run the game it will\r\ndisplay in a nice big 960x720 window, effectively tripling the size of the pixels. Godot has many options\r\nunder `Display -> Window`, and understanding these can enable you to effortlessly build games that look\r\nfantastic at multiple resolutions and multiple aspect ratios targeting different devices without ever\r\nhaving to think about anything other than your base resolution (320x240 in our case)!\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646549594/blog/2022/03/deepgram-godot-tutorial/assets/change_window_settings.png" alt="Set the window settings." style="max-width: 986px;display: block;margin-left: auto;margin-right: auto;">\n\nWe have one more setting to change - navigate to `Application -> Audio` and check "Enable Audio Input".\r\nA warning will appear saying you will need to restart the editor for this to take effect, click the button\r\nthat appears in the lower right ("Save & Restart") to do so.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/enable_audio.png" alt="Enable audio." style="max-width: 911px;display: block;margin-left: auto;margin-right: auto;">\n\nFinally, click the "Play" button in the upper right (or press "F5") to start up the game - since this is the\r\nfirst time we are playing the game, you will be asked to tell Godot which scene you want to start when the\r\ngame is first opened - we only have `Game.tscn` so select that one. We now have a blank canvas ready to be filled!\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/press_play.png" alt="Start the game." style="max-width: 310px;display: block;margin-left: auto;margin-right: auto;">\n\n## Creating a Player\n\nNow that we have a running game in a window let\'s create a player to move around. In the top left of\r\nthe Godot editor, click `Scene -> New Scene`. Like when you first opened this project, the "Scene" tab\r\nwill give you some options for the root node. Click "Other Node" and navigate to, or use the search\r\nfield to find "KinematicBody2D" and click "Create."\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/create_kinematic_body_2d.png" alt="Create a KinematicBody2D." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;">\n\n"KinematicBody2D" is one of the most reasonable types of objects to use for controllable characters.\r\nThis class/node offers convenient methods to make moving and handling collisions with various objects\r\neasy - we will discuss one of these methods shortly.\n\nNow, right-click the root node and click "Add Child Node" and create a "Sprite" node. Do this again\r\nand add a "CollisionShape2D" node. Your node structure should now look like the following:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/player_node_structure.png" alt="The node structure of the Player - the `KinematicBody2D` root node here contains a `Sprite` node and `CollisionShape2D` node as children." style="max-width: 250px;display: block;margin-left: auto;margin-right: auto;">\n\nThe "Sprite" node will contain the image to use for our player. We will use a pixel art\r\nimage of a skull for our player; you can download it [here](https://res.cloudinary.com/deepgram/image/upload/v1646849910/blog/2022/03/deepgram-godot-tutorial/assets/skull.png). Drag the\r\nfile into the "Assets" directory in the "Filesystem" tab in the lower left, then click on the "Import"\r\ntab next to the "Scene" tab, uncheck "Filter" and click "Reimport":\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/import_skull.png" alt="Import the skull image." style="max-width: 245px;display: block;margin-left: auto;margin-right: auto;">\n\nThis is importing the image into our project and telling our project not to apply interpolation\r\nwhen scaling the image should the window size change from the base window size (which is a tiny\r\n320x240 for us). Most art assets ought to have some interpolation applied when scaling to smaller\r\n(or larger) resolutions, but this looks notoriously bad for pixel art, where one would expect\r\nthe sharp and blocky sprite to remain sharp and blocky at any resolution.\n\nNow, navigate back to the "Scene" tab, click on the "Sprite" node, and drag and drop `skull.png`\r\nfrom the "Asset" directory to the "Texture" field:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/set_skull_texture.png" alt="Set the Player\'s sprite texture." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nAfter doing this, you should see an image in the scene\'s 2D view. Finally, some graphics!\r\nYou may want to play around with zooming in or out to get a better view.\n\nNow, click on the "CollisionShape2D" node, then click on the "Shape" field on the upper right\r\nand select "RectangleShape2D", and change the "Extents" "x" and "y" fields to both be 8:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/add_rectangle_shape_2d.png" alt="Setup the Player\'s CollisionShape2D." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nThis is essentially defining the hit-box of the player. We won\'t utilize hit-boxes\r\nor collision detection in this tutorial, but it is good practice to learn how to\r\nset up a player as one typically would in a more involved game.\n\nRename the root node "Player" and then save the scene as `Player.tscn` in the "Scenes" directory.\r\nNow, with the root node ("Player") selected, hit the button which looks like a script with a green\r\nplus sign on it to create a script for this node:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/attach_script.png" alt="Attach a script to a node." style="max-width: 610px;display: block;margin-left: auto;margin-right: auto;">\n\nThis will create a `Player.gd` script, that will help define how this node functions in the game.\r\n`.gd` is the file extension for GDScript source code. GDScript is one of two languages which Godot uses\r\nnatively (the other being a visual programming language which is quite fun!). GDScript is a lot\r\nlike Python, and has a comparatively easy learning curve, helped by the fact that the Godot engine does most of\r\nthe complicated stuff under the hood, leaving the scripting of game objects to be short and quick.\r\nMake the contents of `Player.gd` the following, and you may start to note how few lines of code it takes to perform some actions:\n\n    extends KinematicBody2D\r\n\r\n    export var speed = 100\r\n    var velocity = Vector2(0, 0)\r\n\r\n    func _physics_process(_delta):\r\n    	if Input.is_key_pressed(KEY_W):\r\n    		velocity.y = -speed\r\n    	elif Input.is_key_pressed(KEY_S):\r\n    		velocity.y = speed\r\n    	else:\r\n    		velocity.y = 0\r\n\r\n    	if Input.is_key_pressed(KEY_A):\r\n    		velocity.x = - speed\r\n    	elif Input.is_key_pressed(KEY_D):\r\n    		velocity.x = speed\r\n    	else:\r\n    		velocity.x = 0\r\n\r\n    	var _returned_velocity = move_and_slide(velocity, Vector2(0, 0), false, 4, 0, false)\r\n\r\n    	if position.x < 0 - 16:\r\n    		position.x = 320 + 16\r\n    	if position.x > 320 + 16:\r\n    		position.x = 0 - 16\r\n\r\n    	if position.y < 0 - 16:\r\n    		position.y = 240 + 16\r\n    	if position.y > 240 + 16:\r\n    		position.y = 0 - 16\n\nThe first line, `extends KinematicBody2D`, is telling us that our script is an extension of the "KinematicBody2D" class,\r\nmeaning we will be able to access any methods and variables that the "KinematicBody2D" class offers, plus any variables\r\nand methods that we introduce here in this file. We then define the variables `speed` and `velocity`. We will use `velocity`\r\nto mean the velocity of the player at any given time, and `speed` to mean the maximum horizontal or vertical speed of the\r\nplayer when we move the player.\n\nNext comes the method `_physics_process(_delta)`. This is a method accessible to many Godot nodes, and is executed\r\nroughly 60 times per second, allowing us to alter objects in a way that the physics engine can understand.\r\nThe "delta" argument is the amount of time that has passed since the last call to `_physics_process`, but here we\r\nare not using it, so we place an underscore in front of the argument name to avoid a warning.\n\nIn this method, we check if the `WASD` keys are pressed, and modify the player\'s velocity accordingly ("W" to move up,\r\n"A" to move left, "S" to move down, and "D" to move right). Note that to move up, we set the "y" velocity to `-speed` - this\r\nis because Godot, like many game engines, considers *down* to be the positive y-direction.\n\nAfter adjusting the player\'s velocity, we call the `move_and_slide` method, specifying the velocity as one of its arguments\r\n(the others don\'t matter for now). This method does a lot of logic internally and can handle collisions with static bodies\r\nand rigid bodies, of any shape or size, and correctly move the player along the surface of bodies instead of bouncing\r\noff of them (hence the "slide"). The method returns the resulting velocity of the player after any collisions/slides,\r\nbut since we won\'t be using this, we place an underscore to avoid a warning.\n\nLastly, we check and modify the position of the player to wrap around the window - i.e. if the player moves too far to the left,\r\nhave them wrap to the right side of the window.\n\nSave, and finally go back to the "Game" scene, and click the button at the top of the "Scene" tab to "Instance Child Scene":\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/instance_child_scene.png" alt="Instance a child scene." style="max-width: 626px;display: block;margin-left: auto;margin-right: auto;">\n\nSelect the `Player.tscn` we just created. Now our main "Game" scene has a "Player" scene as a child node! Click the "Play" button\r\nand now the game boots up with a skull in the corner - you can move the skull around with `WASD`! Feel free to reposition the skull\r\nin the "Game" scene - you can either click and drag the player in the 2D view, or you can directly enter the x and y position\r\nin `Node2D -> Transform -> Position` in the "Inspector" tab when the "Player" node is selected in the "Game" scene:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646785008/blog/2022/03/deepgram-godot-tutorial/assets/player_position_in_editor.png" alt="Setting the Player\'s position." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\n## Creating a Fireball\n\nLet\'s make a fireball scene which we will use to have the player shooting fireballs across the screen.\r\nCreate a new scene, for the root node click "Other Node" and pick "Area2D". Rename this root node "Fireball".\r\nAdd two child nodes: an "AnimatedSprite" and a "CollisionShape2D".\n\nNext, import into your "Assets" directory [fireball\\_1.png](https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_1.png)\r\nand [fireball\\_2.png](https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_2.png).\r\nThe two sprites will make up our fireball animation. For each of the imported fireball sprites, go to the "Import" tab,\r\nuncheck "Filter" and click "Reimport" - just like for our pixel art player sprite, this will ensure that these sprites\r\nmaintain their blocky pixel form even on high-resolution displays.\n\nNow, click the "AnimatedSprite" node, and on the right in the "Frames" field, click where it says "\\[empty]" and select\r\n"New SpriteFrames". Then click the field again and you should be brought to an editor view where we can add our animation.\r\nClick and drag the `fireball_1.png` and `fireball_2.png` files from the "Assets" directory into the "Animation Frames" box:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_animation.png" alt="Create the fireball animation." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nNext, click the "AnimatedSprite" node again to bring up the "Inspector" tab for this node again, check the box titled "Playing".\r\nIn the lower-left of the "Animations" tab, change the "Speed" field to "12 FPS". The fireball should now be animated in the editor:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646784180/blog/2022/03/deepgram-godot-tutorial/assets/fireball_editor_cropped_animated.gif" alt="The fireball animation in the editor." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nThere are certainly several tabs and fields to navigate through in this process, but I hope you find some of these operations intuitive!\r\nTo create animations, you drag the individual frames into the "Animation Frames"\r\nbox, you can then change the speed of the animation just left of this box, and you can set which animation plays by default\r\nin the "Animation" field of the "Inspector" tab for the "AnimatedSprite" node - here you can also set whether the animation\r\nis turned on or off with the "Playing" check box.\n\nNow, click the "CollisionShape2D" node, and in the "Inspector" tab for the "Shape" field select "New CircleShape2D". Then\r\nclick the "CicleShape2D" to edit it\'s properties and change its radius to 4:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_hitbox.png" alt="Setting the fireball\'s hit-box." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nNow, save the scene as `Fireball.tscn` in the "Scenes" directory, and then attach a script to the root node. Make the contents\r\nof the script as follows:\n\n    extends Area2D\r\n\r\n    export var speed = 220\r\n    var direction = Vector2(0, 0)\r\n\r\n    func _physics_process(delta):\r\n    	var velocity = direction.normalized() * speed\r\n\r\n    	rotation = velocity.angle()\r\n    	position += velocity * delta\r\n\r\n    	if position.x > 320 + 16:\r\n    		get_tree().queue_delete(self)\r\n    	if position.x < 0 - 16:\r\n    		get_tree().queue_delete(self)\r\n    	if position.y > 240 + 16:\r\n    		get_tree().queue_delete(self)\r\n    	if position.y < 0 - 16:\r\n    		get_tree().queue_delete(self)\n\nLike with the "Player" scene, we are extending the root node\'s class, in this case an "Area2D." We will give each fireball object\r\na speed and a direction. When `_physics_process` is called, we will update the fireball\'s position and angle according to\r\nthe fireball\'s direction and speed. If the fireball goes off-screen, we will destroy it using `get_tree().queue_delete(self)`.\n\nThat\'s all there is to the "Fireball" scene, but we haven\'t actually added any fireballs to our game. We could do this by instancing\r\na "Fireball" scene in our "Game" scene, but for these kinds of objects, there\'s a better way - we should spawn them via code!\n\n## Triggering the Fireball With Keystrokes\n\nGo to the "Game" scene and add a script to the root node, just like we did for the "Player" scene.\r\nThen edit `Game.gd` to have the following contents:\n\n    extends Node2D\r\n\r\n    var rng = RandomNumberGenerator.new()\r\n\r\n    func _ready():\r\n    	rng.randomize()\r\n\r\n    func _input(event):\r\n    	if event is InputEventKey and event.pressed:\r\n    		if event.scancode == KEY_F:\r\n    			for i in rng.randi_range(2, 5):\r\n    				spawn_fireball()\r\n\r\n    func spawn_fireball():\r\n    	var fireball = load("res://Scenes/Fireball.tscn").instance()\r\n    	add_child(fireball)\r\n\r\n    	var random_angle = rng.randf_range(0.0, 2 * PI)\r\n    	fireball.direction = Vector2(cos(random_angle), sin(random_angle))\r\n    	fireball.rotation = fireball.direction.angle()\r\n    	fireball.position = $Player.position\n\nThe first line, `extends Node2D`, is essentially saying that this object is extending the "Node2D" class.\r\nThen, we create a global variable for this object called `rng` which will be used for random number generation.\r\nNext, we define the `_ready()` method which is called when an instance of this scene gets created - in this\r\nmethod we are initializing our random number generator.\n\nThe `_input(event)` method gets called every time there was an input event such as a keystroke, a mouse click,\r\na touch, a game-pad button press, etc. In our case, we are looking to see if the "F" key was pressed, and if\r\nso, we want to spawn 2-5 fireballs!\n\nThe logic handling the spawning of fireballs occurs in the method `spawn_fireball()`. Here we create an instance\r\nof our "Fireball" scene, add it as a child of the current scene, and then initialize the fireball\'s direction,\r\nrotation, and position. We are setting the fireball to spawn exactly where the player object is located,\r\nand we are setting the fireball\'s direction to be totally random.\n\nThe syntax `$Player` is syntax sugar\r\nfor `get_node("Player")` and requires that our "Game" scene has a child node named "Player" (which it does!).\r\nHowever, since GDScript is very much like Python, the game will build and run just fine if one makes\r\na reference to a non-existent object - this will be caught only when the program reaches that line of code,\r\nand it will cause a crash. As Python developers are likely aware, this is sometimes one of the trade-offs of\r\nhaving a "quick and easy" language.\n\nYou should now be able to play the game, move the player around, and press "F" to fire off fireballs! Now\r\nthat the basic game is complete, let\'s add the juicy part by triggering the fireballs not with key presses,\r\nbut with your voice!\n\n## Triggering the Fireball With Your Voice\n\nFinally, let\'s do our Deepgram integration so that we can spawn fireballs by saying "fire" into the microphone instead\r\nof pressing a key. To do this, grab the `DeepgramIntegration` directory from `Scenes/DeepgramIntegration`\r\nfrom the [the SpeechSpells repository](https://github.com/deepgram/SpeechSpells) and place it in the `Scenes/` directory in the Godot editor.\n\nThis integration contains two Godot scenes with accompanying scripts: `MicrophoneInstance` and `DeepgramInstance`.\r\nWe won\'t go over the inner-workings of these scripts in detail, but feel free to have a look as they have\r\na fair amount of descriptive comments to help explain what is going on. In a nutshell, the `MicrophoneInstance`\r\ninterfaces with your device\'s microphone and streams the raw audio from the microphone via Godot signals\r\nto the `DeepgramInstance` which handles connecting to Deepgram via Websockets.\r\nThe `DeepgramInstance` then forwards the raw microphone audio to Deepgram, receives ASR results from Deepgram,\r\nand then forwards those results via Godot signals to some other node. In our case, this other node will be\r\nour "Game" scene\'s root node.\n\n***\n\n***Note***: A common issue which causes the microphone capture to fail on Mac is if Godot\'s audio sample rate is set to\r\nsomething different then the OS\'s audio sample rate. If you experience issues with microphone capture on Mac, you\r\ncan check your OS\'s audio sample rate under `Utilities -> Audio Midi Setup`.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646351903/blog/2022/03/deepgram-godot-tutorial/assets/mac_sample_rate_settings.png" alt="Mac audio sample rate settings." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\n***\n\n***\n\n***Note***: This integration will not work for Godot\'s HTML5 builds out-of-the-box\r\nas authenticating websockets connections with headers is not supported for these builds due to\r\nsome authentication limitations of browsers. If you plan on making an HTML5 game with the Deepgram\r\nintegration, you will have to deploy a proxy server for authentication and make some minor adjustments\r\nof the `DeepgramInstance` scene. This may be a topic of a future guide!\n\n***\n\nIn your "Game" scene, add as a child an instance of the "DeepgramInstance" scene, then modify `Game.gd` as follows:\n\n    extends Node2D\r\n\r\n    var rng = RandomNumberGenerator.new()\r\n\r\n    func _ready():\r\n    	rng.randomize()\r\n    	$DeepgramInstance.initialize("INSERT_YOUR_API_KEY_HERE")\r\n\r\n    func _on_DeepgramInstance_message_received(message):\r\n    	var message_json = JSON.parse(message)\r\n    	if message_json.error == OK:\r\n    		if typeof(message_json.result) == TYPE_DICTIONARY:\r\n    			if message_json.result.has("is_final"):\r\n    				if message_json.result["is_final"] == true:\r\n    					var message_transcript = message_json.result["channel"]["alternatives"][0]["transcript"]\r\n    					print("Transcript received: " + message_transcript)\r\n    					for _i in message.count("fire"):\r\n    						spawn_fireball()\r\n\r\n    	else:\r\n    		print("Failed to parse Deepgram message!")\r\n\r\n    func spawn_fireball():\r\n    	var fireball = load("res://Scenes/Fireball.tscn").instance()\r\n    	add_child(fireball)\r\n\r\n    	var random_angle = rng.randf_range(0.0, 2 * PI)\r\n    	fireball.direction = Vector2(cos(random_angle), sin(random_angle))\r\n    	fireball.rotation = fireball.direction.angle()\r\n    	fireball.position = $Player.position\n\nRemember to replace `INSERT_YOUR_API_KEY_HERE` with your Deepgram API Key.\n\nNow, to finish up, click your "Game" scene\'s "DeepgramInstance" node and in the right panel click the "Node" tab (it should be right next\r\nto the "Inspector" tab). You should see a `message_received()` signal listed under `DeepgramInstance.gd` - double click this,\r\nmake sure that the "Game" node is highlighted, and click "connect".\n\nWhat is this signal doing? Signals are a useful way to organize the transmission of events in game engines.\r\nIn this particular case, the "DeepgramInstance" node is signaling to its parent "Game" node that it has received a message from Deepgram.\r\nIt passes this message with the signal, the parent "Game" node can then react to the signal to trigger further logic.\n\nIn our case, the "Game" node handles this signal in the `_on_DeepgramInstance_message_received` method where tries to parse\r\nthe JSON message from Deepgram into a data structure similar to a Dictionary using `JSON.parse(message)`.\n\nAfter verifying that the message successfully parsed as a Dictionary, it checks to see whether this is a final result or an interim result.\r\nTo understand the difference between final and interim results in the Deepgram realtime streaming API, check out [this page](https://developers.deepgram.com/documentation/features/interim-results/).\r\nFor our purposes, we are only considering final results. We then grab the transcript from the first alternative in the\r\nASR result, and count how many times the word "fire" appears in the transcript, spawning one fireball for each occurrence.\n\n## Build New Features\n\nSo now you can walk around and cast fireball spells with your voice! Here are some ideas for next steps\r\nyou may want to try out to make a more fully-featured game:\n\n*   Implement more spells! Try a thunder spell, or an ice beam spell.\n*   Add enemies and implement collision detection to destroy enemies when your spells hit them.\n*   Try using [interim results](https://developers.deepgram.com/documentation/features/interim-results/) instead of just final results - this should decrease the latency of the spells substantially, but you will need to watch out for\r\n    double-counting as multiple interim results will give transcripts for the same section of audio!\n*   Play around with Deepgram\'s `keyword`, `search`, and/or `phoneme` features to implement spells for out-of-vocab words.\n*   If you are feeling ambitious, work through some Godot networking tutorials to create a multiplayer game where you and your friends cast spells at each other!\n\n## Final Thoughts\n\nSpeech-enhanced games have actually been around for quite some time, with popular titles such as "Hey You, Pikachu!" and "Seaman",\r\nbut it hasn\'t been until more recently that ASR engines have really taken off and can start to offer gameplay experiences which are deeper\r\nthan the simple command-based games of the past which only understood a few phrases. With modern ASR engines like Deepgram\'s, understanding\r\nthousands of commands has become trivial, and much more interesting and complex uses for speech in games is now possible. I encourage anyone\r\ninterested to try things out and explore with us what the future of speech in games might look like! Off the top of my head, I want to lastly\r\nshare some game ideas to get the creative juices flowing in the community:\n\n*   An RPG where warriors fight with swords, archers fight with bows, and mages fight with... speech! Take the "casting spells" approach of this\r\n    tutorial and expand it to a game about incantations! (See "In Verbis Virtus" for even more inspiration here!)\n*   Speech-enhanced mini-games: imagine playing a Zelda-esque game where you walk into a town and go to the nearest mini-game building and have\r\n    to play word games ala "Wheel of Fortune" to win your next upgrade!\n*   Games fully controllable via speech: traditional turn-based games are a great candidate to integrate speech controls, and this could greatly\r\n    increase the accessibility of such games! This type of technology does exist, but it can likely be greatly improved with new powerful ASR engines\r\n    like Deepgram.\n*   Casual social games: imagine playing word and speech-based games in an environment like VR chat!\n*   AI-based visual novels: imagine playing a visual novel where instead of picking from a list of phrases to progress, you simply say what\'s on your mind!\n*   AAA AI-enhanced experiences: take the visual novel idea to the next level and enhance AI components of AAA titles by allowing your character to\r\n    talk to NPCs with a microphone! (Check out games like "Phasmophobia" for even more inspiration here!)\n\nIf you have any questions, please feel free to reach out on Twitter - we\'re @DeepgramDevs.\n\n        ', "html": '<p>In this post, we will be making a simplified version of the 2D game \u201CSpooky Speech Spells\u201D (which you can play <a href="https://spookyspeechspells.deepgram.com">here</a>)\r\nin the Godot game engine using an integration with the Deepgram automatic speech recognition (ASR) engine. Why Godot? Because it is an\r\neasy-to-learn, open-source alternative to the popular industry-standard Unity and can export directly to Mac, Windows, Linux, iOS,\r\nAndroid, and HTML5. Why Deepgram? Because it is the fastest, most accurate, cheapest, and easiest to use ASR engine out there! And why\r\nmake a speech-enhanced game? Well, because it\u2019s cool, and games are fun! Beyond that, adding nontraditional input devices can help make your games more accessible.</p>\n<p>This tutorial is focusing on adding voice input to your game, but if you want to see more tutorials, you can find plenty on the\r\n<a href="https://docs.godotengine.org/en/stable/community/tutorials.html">Godot website</a>.</p>\n<h2 id="pre-requisites">Pre-requisites</h2>\n<p>You will need:</p>\n<ul>\n<li>Godot installed on your machine - <a href="https://godotengine.org/download">download Godot here</a>. This tutorial was written with version <code is:raw>3.4.3</code>.</li>\n<li>A Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get an API Key here</a>.</li>\n</ul>\n<h2 id="try-the-game">Try the Game</h2>\n<p>To run the game we are going to build and browse its files:</p>\n<ul>\n<li>Download <a href="https://github.com/deepgram/SpeechSpells">this repository</a>, open Godot, click \u201CImport\u201D, and browse to and select the <code is:raw>project.godot</code> file from the repo.</li>\n<li>In the Godot editor, go to the \u201CFileSystem\u201D tab in the lower left, and navigate to and open <code is:raw>Scenes/Game.gd</code>.</li>\n<li>Edit <code is:raw>line 7</code> of <code is:raw>Scenes/Game.gd</code> and enter your Deepgram API Key.</li>\n<li>In the top right of the Godot editor, hit the \u201CPlay\u201D (\u25BA) button.</li>\n<li>Move your character with <code is:raw>WASD</code> and say \u201Cfire\u201D to cast fire spells!</li>\n</ul>\n<h2 id="building-the-game">Building the Game</h2>\n<p>In the following sub-sections, we will walk through step-by-step how to make a game where you can move\r\na character around the screen and have the character cast fireball spells by chanting \u201Cfire!\u201D into your\r\nmicrophone.</p>\n<h2 id="setting-up-the-project">Setting Up the Project</h2>\n<p>Open Godot and create a \u201CNew Project\u201D in the project manager.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/new_project.png" alt="Create a new project." style="max-width: 1037px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Now click \u201CBrowse\u201D and choose a directory on your filesystem to store the project, and in the \u201CProject Name\u201D\r\nfield, write \u201CSpeechSpells\u201D and hit \u201CCreate Folder.\u201D Finally, hit \u201CCreate and Edit,\u201D and we\u2019ll get to the Godot\r\nEditor, where we can build our game.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/set_project_name.png" alt="Set the name of the new project." style="max-width: 1038px;display: block;margin-left: auto;margin-right: auto;" />\n<p>The Godot Editor consists of several panels and tabs, and we will be going over the ones we need to interact\r\nwith to build \u201CSpeech Spells\u201D.</p>\n<p>Let\u2019s start with the \u201CScene\u201D tab in the upper left panel. In this tab, we can put together \u201CScenes,\u201D which,\r\ntogether with \u201CNodes,\u201D form the basic building blocks of Godot games. Scenes and nodes are classes\r\nin object-oriented programming terminology, but the Godot Editor offers an intuitive way to create, edit,\r\nand manage our various game objects as scenes and nodes. Scenes can be almost anything - a collection\r\nof sprite nodes, a character with animations, attacks, and hit-boxes, or just a collection of scripts\r\nthat execute algorithms and can emit signals to other nodes (we will see this pattern further on). For now,\r\nwhere it says \u201CCreate Root Node\u201D click \u201C2D Scene\u201D and double click the name of the resulting node and rename\r\nit to \u201CGame\u201D. We will create a few other scenes for this game and add instances of those scenes to our Game\r\nscene.</p>\n<p>Before saving the scene, let\u2019s head over to the lower right \u201CFilesystem\u201D tab. Right-click in the filesystem\r\nbrowser there and click \u201CNew Folder\u2026\u201D to create a folder called \u201CScenes\u201D and then a folder called \u201CAssets\u201D.\r\nYou may, of course, organize your projects however you like, but this is at least one way of doing it.</p>\n<p>Click on <code is:raw>Scene -&gt; Save Scene</code> in the upper left corner of the editor to save this scene as <code is:raw>Game.tscn</code> in the \u201CScenes\u201D directory that you just created.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/create_folders.png" alt="Set up the game directory structure." style="max-width: 249px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Now, go to <code is:raw>Project -&gt; Project Settings</code> from the upper left bar, and we will set a couple of properties of our game.\r\nStart by navigating to <code is:raw>Rendering -&gt; Environment</code> and change the \u201CDefault Clear Color\u201D to black.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/default_clear_color.png" alt="Change the default clear color." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Next, navigate to <code is:raw>Display -&gt; Window</code>, uncheck \u201CResizable\u201D, set the \u201CWidth\u201D to 320, the \u201CHeight\u201D to 240,\r\nthe \u201CTest Width\u201D to 960, the \u201CTest Height\u201D to 720, the \u201CStretch\u201D \u201CMode\u201D to \u201C2d\u201D and the\r\nStretch \u201CAspect\u201D to \u201CKeep\u201D. This is setting us up to build a game\r\nwith a very low resolution close to 240p (common for 8-bit pixel games), but when we run the game it will\r\ndisplay in a nice big 960x720 window, effectively tripling the size of the pixels. Godot has many options\r\nunder <code is:raw>Display -&gt; Window</code>, and understanding these can enable you to effortlessly build games that look\r\nfantastic at multiple resolutions and multiple aspect ratios targeting different devices without ever\r\nhaving to think about anything other than your base resolution (320x240 in our case)!</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646549594/blog/2022/03/deepgram-godot-tutorial/assets/change_window_settings.png" alt="Set the window settings." style="max-width: 986px;display: block;margin-left: auto;margin-right: auto;" />\n<p>We have one more setting to change - navigate to <code is:raw>Application -&gt; Audio</code> and check \u201CEnable Audio Input\u201D.\r\nA warning will appear saying you will need to restart the editor for this to take effect, click the button\r\nthat appears in the lower right (\u201CSave & Restart\u201D) to do so.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/enable_audio.png" alt="Enable audio." style="max-width: 911px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Finally, click the \u201CPlay\u201D button in the upper right (or press \u201CF5\u201D) to start up the game - since this is the\r\nfirst time we are playing the game, you will be asked to tell Godot which scene you want to start when the\r\ngame is first opened - we only have <code is:raw>Game.tscn</code> so select that one. We now have a blank canvas ready to be filled!</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/press_play.png" alt="Start the game." style="max-width: 310px;display: block;margin-left: auto;margin-right: auto;" />\n<h2 id="creating-a-player">Creating a Player</h2>\n<p>Now that we have a running game in a window let\u2019s create a player to move around. In the top left of\r\nthe Godot editor, click <code is:raw>Scene -&gt; New Scene</code>. Like when you first opened this project, the \u201CScene\u201D tab\r\nwill give you some options for the root node. Click \u201COther Node\u201D and navigate to, or use the search\r\nfield to find \u201CKinematicBody2D\u201D and click \u201CCreate.\u201D</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/create_kinematic_body_2d.png" alt="Create a KinematicBody2D." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;" />\n<p>\u201CKinematicBody2D\u201D is one of the most reasonable types of objects to use for controllable characters.\r\nThis class/node offers convenient methods to make moving and handling collisions with various objects\r\neasy - we will discuss one of these methods shortly.</p>\n<p>Now, right-click the root node and click \u201CAdd Child Node\u201D and create a \u201CSprite\u201D node. Do this again\r\nand add a \u201CCollisionShape2D\u201D node. Your node structure should now look like the following:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/player_node_structure.png" alt="The node structure of the Player - the `KinematicBody2D` root node here contains a `Sprite` node and `CollisionShape2D` node as children." style="max-width: 250px;display: block;margin-left: auto;margin-right: auto;" />\n<p>The \u201CSprite\u201D node will contain the image to use for our player. We will use a pixel art\r\nimage of a skull for our player; you can download it <a href="https://res.cloudinary.com/deepgram/image/upload/v1646849910/blog/2022/03/deepgram-godot-tutorial/assets/skull.png">here</a>. Drag the\r\nfile into the \u201CAssets\u201D directory in the \u201CFilesystem\u201D tab in the lower left, then click on the \u201CImport\u201D\r\ntab next to the \u201CScene\u201D tab, uncheck \u201CFilter\u201D and click \u201CReimport\u201D:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/import_skull.png" alt="Import the skull image." style="max-width: 245px;display: block;margin-left: auto;margin-right: auto;" />\n<p>This is importing the image into our project and telling our project not to apply interpolation\r\nwhen scaling the image should the window size change from the base window size (which is a tiny\r\n320x240 for us). Most art assets ought to have some interpolation applied when scaling to smaller\r\n(or larger) resolutions, but this looks notoriously bad for pixel art, where one would expect\r\nthe sharp and blocky sprite to remain sharp and blocky at any resolution.</p>\n<p>Now, navigate back to the \u201CScene\u201D tab, click on the \u201CSprite\u201D node, and drag and drop <code is:raw>skull.png</code>\r\nfrom the \u201CAsset\u201D directory to the \u201CTexture\u201D field:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/set_skull_texture.png" alt="Set the Player\'s sprite texture." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>After doing this, you should see an image in the scene\u2019s 2D view. Finally, some graphics!\r\nYou may want to play around with zooming in or out to get a better view.</p>\n<p>Now, click on the \u201CCollisionShape2D\u201D node, then click on the \u201CShape\u201D field on the upper right\r\nand select \u201CRectangleShape2D\u201D, and change the \u201CExtents\u201D \u201Cx\u201D and \u201Cy\u201D fields to both be 8:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/add_rectangle_shape_2d.png" alt="Setup the Player\'s CollisionShape2D." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>This is essentially defining the hit-box of the player. We won\u2019t utilize hit-boxes\r\nor collision detection in this tutorial, but it is good practice to learn how to\r\nset up a player as one typically would in a more involved game.</p>\n<p>Rename the root node \u201CPlayer\u201D and then save the scene as <code is:raw>Player.tscn</code> in the \u201CScenes\u201D directory.\r\nNow, with the root node (\u201CPlayer\u201D) selected, hit the button which looks like a script with a green\r\nplus sign on it to create a script for this node:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/attach_script.png" alt="Attach a script to a node." style="max-width: 610px;display: block;margin-left: auto;margin-right: auto;" />\n<p>This will create a <code is:raw>Player.gd</code> script, that will help define how this node functions in the game.\r\n<code is:raw>.gd</code> is the file extension for GDScript source code. GDScript is one of two languages which Godot uses\r\nnatively (the other being a visual programming language which is quite fun!). GDScript is a lot\r\nlike Python, and has a comparatively easy learning curve, helped by the fact that the Godot engine does most of\r\nthe complicated stuff under the hood, leaving the scripting of game objects to be short and quick.\r\nMake the contents of <code is:raw>Player.gd</code> the following, and you may start to note how few lines of code it takes to perform some actions:</p>\n<p>extends KinematicBody2D</p>\n<p>export var speed = 100\r\nvar velocity = Vector2(0, 0)</p>\n<p>func _physics_process(_delta):\r\nif Input.is_key_pressed(KEY_W):\r\nvelocity.y = -speed\r\nelif Input.is_key_pressed(KEY_S):\r\nvelocity.y = speed\r\nelse:\r\nvelocity.y = 0</p>\n<p>if Input.is_key_pressed(KEY_A):\r\nvelocity.x = - speed\r\nelif Input.is_key_pressed(KEY_D):\r\nvelocity.x = speed\r\nelse:\r\nvelocity.x = 0</p>\n<p>var _returned_velocity = move_and_slide(velocity, Vector2(0, 0), false, 4, 0, false)</p>\n<p>if position.x < 0 - 16:\r\nposition.x = 320 + 16\r\nif position.x > 320 + 16:\r\nposition.x = 0 - 16</p>\n<p>if position.y < 0 - 16:\r\nposition.y = 240 + 16\r\nif position.y > 240 + 16:\r\nposition.y = 0 - 16</p>\n<p>The first line, <code is:raw>extends KinematicBody2D</code>, is telling us that our script is an extension of the \u201CKinematicBody2D\u201D class,\r\nmeaning we will be able to access any methods and variables that the \u201CKinematicBody2D\u201D class offers, plus any variables\r\nand methods that we introduce here in this file. We then define the variables <code is:raw>speed</code> and <code is:raw>velocity</code>. We will use <code is:raw>velocity</code>\r\nto mean the velocity of the player at any given time, and <code is:raw>speed</code> to mean the maximum horizontal or vertical speed of the\r\nplayer when we move the player.</p>\n<p>Next comes the method <code is:raw>_physics_process(_delta)</code>. This is a method accessible to many Godot nodes, and is executed\r\nroughly 60 times per second, allowing us to alter objects in a way that the physics engine can understand.\r\nThe \u201Cdelta\u201D argument is the amount of time that has passed since the last call to <code is:raw>_physics_process</code>, but here we\r\nare not using it, so we place an underscore in front of the argument name to avoid a warning.</p>\n<p>In this method, we check if the <code is:raw>WASD</code> keys are pressed, and modify the player\u2019s velocity accordingly (\u201CW\u201D to move up,\r\n\u201CA\u201D to move left, \u201CS\u201D to move down, and \u201CD\u201D to move right). Note that to move up, we set the \u201Cy\u201D velocity to <code is:raw>-speed</code> - this\r\nis because Godot, like many game engines, considers <em>down</em> to be the positive y-direction.</p>\n<p>After adjusting the player\u2019s velocity, we call the <code is:raw>move_and_slide</code> method, specifying the velocity as one of its arguments\r\n(the others don\u2019t matter for now). This method does a lot of logic internally and can handle collisions with static bodies\r\nand rigid bodies, of any shape or size, and correctly move the player along the surface of bodies instead of bouncing\r\noff of them (hence the \u201Cslide\u201D). The method returns the resulting velocity of the player after any collisions/slides,\r\nbut since we won\u2019t be using this, we place an underscore to avoid a warning.</p>\n<p>Lastly, we check and modify the position of the player to wrap around the window - i.e. if the player moves too far to the left,\r\nhave them wrap to the right side of the window.</p>\n<p>Save, and finally go back to the \u201CGame\u201D scene, and click the button at the top of the \u201CScene\u201D tab to \u201CInstance Child Scene\u201D:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/instance_child_scene.png" alt="Instance a child scene." style="max-width: 626px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Select the <code is:raw>Player.tscn</code> we just created. Now our main \u201CGame\u201D scene has a \u201CPlayer\u201D scene as a child node! Click the \u201CPlay\u201D button\r\nand now the game boots up with a skull in the corner - you can move the skull around with <code is:raw>WASD</code>! Feel free to reposition the skull\r\nin the \u201CGame\u201D scene - you can either click and drag the player in the 2D view, or you can directly enter the x and y position\r\nin <code is:raw>Node2D -&gt; Transform -&gt; Position</code> in the \u201CInspector\u201D tab when the \u201CPlayer\u201D node is selected in the \u201CGame\u201D scene:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646785008/blog/2022/03/deepgram-godot-tutorial/assets/player_position_in_editor.png" alt="Setting the Player\'s position." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<h2 id="creating-a-fireball">Creating a Fireball</h2>\n<p>Let\u2019s make a fireball scene which we will use to have the player shooting fireballs across the screen.\r\nCreate a new scene, for the root node click \u201COther Node\u201D and pick \u201CArea2D\u201D. Rename this root node \u201CFireball\u201D.\r\nAdd two child nodes: an \u201CAnimatedSprite\u201D and a \u201CCollisionShape2D\u201D.</p>\n<p>Next, import into your \u201CAssets\u201D directory <a href="https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_1.png">fireball_1.png</a>\r\nand <a href="https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_2.png">fireball_2.png</a>.\r\nThe two sprites will make up our fireball animation. For each of the imported fireball sprites, go to the \u201CImport\u201D tab,\r\nuncheck \u201CFilter\u201D and click \u201CReimport\u201D - just like for our pixel art player sprite, this will ensure that these sprites\r\nmaintain their blocky pixel form even on high-resolution displays.</p>\n<p>Now, click the \u201CAnimatedSprite\u201D node, and on the right in the \u201CFrames\u201D field, click where it says \u201C[empty]\u201D and select\r\n\u201CNew SpriteFrames\u201D. Then click the field again and you should be brought to an editor view where we can add our animation.\r\nClick and drag the <code is:raw>fireball_1.png</code> and <code is:raw>fireball_2.png</code> files from the \u201CAssets\u201D directory into the \u201CAnimation Frames\u201D box:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_animation.png" alt="Create the fireball animation." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Next, click the \u201CAnimatedSprite\u201D node again to bring up the \u201CInspector\u201D tab for this node again, check the box titled \u201CPlaying\u201D.\r\nIn the lower-left of the \u201CAnimations\u201D tab, change the \u201CSpeed\u201D field to \u201C12 FPS\u201D. The fireball should now be animated in the editor:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646784180/blog/2022/03/deepgram-godot-tutorial/assets/fireball_editor_cropped_animated.gif" alt="The fireball animation in the editor." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>There are certainly several tabs and fields to navigate through in this process, but I hope you find some of these operations intuitive!\r\nTo create animations, you drag the individual frames into the \u201CAnimation Frames\u201D\r\nbox, you can then change the speed of the animation just left of this box, and you can set which animation plays by default\r\nin the \u201CAnimation\u201D field of the \u201CInspector\u201D tab for the \u201CAnimatedSprite\u201D node - here you can also set whether the animation\r\nis turned on or off with the \u201CPlaying\u201D check box.</p>\n<p>Now, click the \u201CCollisionShape2D\u201D node, and in the \u201CInspector\u201D tab for the \u201CShape\u201D field select \u201CNew CircleShape2D\u201D. Then\r\nclick the \u201CCicleShape2D\u201D to edit it\u2019s properties and change its radius to 4:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_hitbox.png" alt="Setting the fireball\'s hit-box." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Now, save the scene as <code is:raw>Fireball.tscn</code> in the \u201CScenes\u201D directory, and then attach a script to the root node. Make the contents\r\nof the script as follows:</p>\n<p>extends Area2D</p>\n<p>export var speed = 220\r\nvar direction = Vector2(0, 0)</p>\n<p>func _physics_process(delta):\r\nvar velocity = direction.normalized() * speed</p>\n<p>rotation = velocity.angle()\r\nposition += velocity * delta</p>\n<p>if position.x > 320 + 16:\r\nget_tree().queue_delete(self)\r\nif position.x < 0 - 16:\r\nget_tree().queue_delete(self)\r\nif position.y > 240 + 16:\r\nget_tree().queue_delete(self)\r\nif position.y < 0 - 16:\r\nget_tree().queue_delete(self)</p>\n<p>Like with the \u201CPlayer\u201D scene, we are extending the root node\u2019s class, in this case an \u201CArea2D.\u201D We will give each fireball object\r\na speed and a direction. When <code is:raw>_physics_process</code> is called, we will update the fireball\u2019s position and angle according to\r\nthe fireball\u2019s direction and speed. If the fireball goes off-screen, we will destroy it using <code is:raw>get_tree().queue_delete(self)</code>.</p>\n<p>That\u2019s all there is to the \u201CFireball\u201D scene, but we haven\u2019t actually added any fireballs to our game. We could do this by instancing\r\na \u201CFireball\u201D scene in our \u201CGame\u201D scene, but for these kinds of objects, there\u2019s a better way - we should spawn them via code!</p>\n<h2 id="triggering-the-fireball-with-keystrokes">Triggering the Fireball With Keystrokes</h2>\n<p>Go to the \u201CGame\u201D scene and add a script to the root node, just like we did for the \u201CPlayer\u201D scene.\r\nThen edit <code is:raw>Game.gd</code> to have the following contents:</p>\n<p>extends Node2D</p>\n<p>var rng = RandomNumberGenerator.new()</p>\n<p>func _ready():\r\nrng.randomize()</p>\n<p>func _input(event):\r\nif event is InputEventKey and event.pressed:\r\nif event.scancode == KEY_F:\r\nfor i in rng.randi_range(2, 5):\r\nspawn_fireball()</p>\n<p>func spawn_fireball():\r\nvar fireball = load(\u201Cres://Scenes/Fireball.tscn\u201D).instance()\r\nadd_child(fireball)</p>\n<p>var random_angle = rng.randf_range(0.0, 2 * PI)\r\nfireball.direction = Vector2(cos(random_angle), sin(random_angle))\r\nfireball.rotation = fireball.direction.angle()\r\nfireball.position = $Player.position</p>\n<p>The first line, <code is:raw>extends Node2D</code>, is essentially saying that this object is extending the \u201CNode2D\u201D class.\r\nThen, we create a global variable for this object called <code is:raw>rng</code> which will be used for random number generation.\r\nNext, we define the <code is:raw>_ready()</code> method which is called when an instance of this scene gets created - in this\r\nmethod we are initializing our random number generator.</p>\n<p>The <code is:raw>_input(event)</code> method gets called every time there was an input event such as a keystroke, a mouse click,\r\na touch, a game-pad button press, etc. In our case, we are looking to see if the \u201CF\u201D key was pressed, and if\r\nso, we want to spawn 2-5 fireballs!</p>\n<p>The logic handling the spawning of fireballs occurs in the method <code is:raw>spawn_fireball()</code>. Here we create an instance\r\nof our \u201CFireball\u201D scene, add it as a child of the current scene, and then initialize the fireball\u2019s direction,\r\nrotation, and position. We are setting the fireball to spawn exactly where the player object is located,\r\nand we are setting the fireball\u2019s direction to be totally random.</p>\n<p>The syntax <code is:raw>$Player</code> is syntax sugar\r\nfor <code is:raw>get_node("Player")</code> and requires that our \u201CGame\u201D scene has a child node named \u201CPlayer\u201D (which it does!).\r\nHowever, since GDScript is very much like Python, the game will build and run just fine if one makes\r\na reference to a non-existent object - this will be caught only when the program reaches that line of code,\r\nand it will cause a crash. As Python developers are likely aware, this is sometimes one of the trade-offs of\r\nhaving a \u201Cquick and easy\u201D language.</p>\n<p>You should now be able to play the game, move the player around, and press \u201CF\u201D to fire off fireballs! Now\r\nthat the basic game is complete, let\u2019s add the juicy part by triggering the fireballs not with key presses,\r\nbut with your voice!</p>\n<h2 id="triggering-the-fireball-with-your-voice">Triggering the Fireball With Your Voice</h2>\n<p>Finally, let\u2019s do our Deepgram integration so that we can spawn fireballs by saying \u201Cfire\u201D into the microphone instead\r\nof pressing a key. To do this, grab the <code is:raw>DeepgramIntegration</code> directory from <code is:raw>Scenes/DeepgramIntegration</code>\r\nfrom the <a href="https://github.com/deepgram/SpeechSpells">the SpeechSpells repository</a> and place it in the <code is:raw>Scenes/</code> directory in the Godot editor.</p>\n<p>This integration contains two Godot scenes with accompanying scripts: <code is:raw>MicrophoneInstance</code> and <code is:raw>DeepgramInstance</code>.\r\nWe won\u2019t go over the inner-workings of these scripts in detail, but feel free to have a look as they have\r\na fair amount of descriptive comments to help explain what is going on. In a nutshell, the <code is:raw>MicrophoneInstance</code>\r\ninterfaces with your device\u2019s microphone and streams the raw audio from the microphone via Godot signals\r\nto the <code is:raw>DeepgramInstance</code> which handles connecting to Deepgram via Websockets.\r\nThe <code is:raw>DeepgramInstance</code> then forwards the raw microphone audio to Deepgram, receives ASR results from Deepgram,\r\nand then forwards those results via Godot signals to some other node. In our case, this other node will be\r\nour \u201CGame\u201D scene\u2019s root node.</p>\n<hr>\n<p><em><strong>Note</strong></em>: A common issue which causes the microphone capture to fail on Mac is if Godot\u2019s audio sample rate is set to\r\nsomething different then the OS\u2019s audio sample rate. If you experience issues with microphone capture on Mac, you\r\ncan check your OS\u2019s audio sample rate under <code is:raw>Utilities -&gt; Audio Midi Setup</code>.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646351903/blog/2022/03/deepgram-godot-tutorial/assets/mac_sample_rate_settings.png" alt="Mac audio sample rate settings." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<hr>\n<hr>\n<p><em><strong>Note</strong></em>: This integration will not work for Godot\u2019s HTML5 builds out-of-the-box\r\nas authenticating websockets connections with headers is not supported for these builds due to\r\nsome authentication limitations of browsers. If you plan on making an HTML5 game with the Deepgram\r\nintegration, you will have to deploy a proxy server for authentication and make some minor adjustments\r\nof the <code is:raw>DeepgramInstance</code> scene. This may be a topic of a future guide!</p>\n<hr>\n<p>In your \u201CGame\u201D scene, add as a child an instance of the \u201CDeepgramInstance\u201D scene, then modify <code is:raw>Game.gd</code> as follows:</p>\n<p>extends Node2D</p>\n<p>var rng = RandomNumberGenerator.new()</p>\n<p>func _ready():\r\nrng.randomize()\r\n$DeepgramInstance.initialize(\u201CINSERT_YOUR_API_KEY_HERE\u201D)</p>\n<p>func _on_DeepgramInstance_message_received(message):\r\nvar message_json = JSON.parse(message)\r\nif message_json.error == OK:\r\nif typeof(message_json.result) == TYPE_DICTIONARY:\r\nif message_json.result.has(\u201Cis_final\u201D):\r\nif message_json.result[\u201Cis_final\u201D] == true:\r\nvar message_transcript = message_json.result[\u201Cchannel\u201D][\u201Calternatives\u201D][0][\u201Ctranscript\u201D]\r\nprint(\u201CTranscript received: \u201D + message_transcript)\r\nfor _i in message.count(\u201Cfire\u201D):\r\nspawn_fireball()</p>\n<p>else:\r\nprint(\u201CFailed to parse Deepgram message!\u201C)</p>\n<p>func spawn_fireball():\r\nvar fireball = load(\u201Cres://Scenes/Fireball.tscn\u201D).instance()\r\nadd_child(fireball)</p>\n<p>var random_angle = rng.randf_range(0.0, 2 * PI)\r\nfireball.direction = Vector2(cos(random_angle), sin(random_angle))\r\nfireball.rotation = fireball.direction.angle()\r\nfireball.position = $Player.position</p>\n<p>Remember to replace <code is:raw>INSERT_YOUR_API_KEY_HERE</code> with your Deepgram API Key.</p>\n<p>Now, to finish up, click your \u201CGame\u201D scene\u2019s \u201CDeepgramInstance\u201D node and in the right panel click the \u201CNode\u201D tab (it should be right next\r\nto the \u201CInspector\u201D tab). You should see a <code is:raw>message_received()</code> signal listed under <code is:raw>DeepgramInstance.gd</code> - double click this,\r\nmake sure that the \u201CGame\u201D node is highlighted, and click \u201Cconnect\u201D.</p>\n<p>What is this signal doing? Signals are a useful way to organize the transmission of events in game engines.\r\nIn this particular case, the \u201CDeepgramInstance\u201D node is signaling to its parent \u201CGame\u201D node that it has received a message from Deepgram.\r\nIt passes this message with the signal, the parent \u201CGame\u201D node can then react to the signal to trigger further logic.</p>\n<p>In our case, the \u201CGame\u201D node handles this signal in the <code is:raw>_on_DeepgramInstance_message_received</code> method where tries to parse\r\nthe JSON message from Deepgram into a data structure similar to a Dictionary using <code is:raw>JSON.parse(message)</code>.</p>\n<p>After verifying that the message successfully parsed as a Dictionary, it checks to see whether this is a final result or an interim result.\r\nTo understand the difference between final and interim results in the Deepgram realtime streaming API, check out <a href="https://developers.deepgram.com/documentation/features/interim-results/">this page</a>.\r\nFor our purposes, we are only considering final results. We then grab the transcript from the first alternative in the\r\nASR result, and count how many times the word \u201Cfire\u201D appears in the transcript, spawning one fireball for each occurrence.</p>\n<h2 id="build-new-features">Build New Features</h2>\n<p>So now you can walk around and cast fireball spells with your voice! Here are some ideas for next steps\r\nyou may want to try out to make a more fully-featured game:</p>\n<ul>\n<li>Implement more spells! Try a thunder spell, or an ice beam spell.</li>\n<li>Add enemies and implement collision detection to destroy enemies when your spells hit them.</li>\n<li>Try using <a href="https://developers.deepgram.com/documentation/features/interim-results/">interim results</a> instead of just final results - this should decrease the latency of the spells substantially, but you will need to watch out for\r\ndouble-counting as multiple interim results will give transcripts for the same section of audio!</li>\n<li>Play around with Deepgram\u2019s <code is:raw>keyword</code>, <code is:raw>search</code>, and/or <code is:raw>phoneme</code> features to implement spells for out-of-vocab words.</li>\n<li>If you are feeling ambitious, work through some Godot networking tutorials to create a multiplayer game where you and your friends cast spells at each other!</li>\n</ul>\n<h2 id="final-thoughts">Final Thoughts</h2>\n<p>Speech-enhanced games have actually been around for quite some time, with popular titles such as \u201CHey You, Pikachu!\u201D and \u201CSeaman\u201D,\r\nbut it hasn\u2019t been until more recently that ASR engines have really taken off and can start to offer gameplay experiences which are deeper\r\nthan the simple command-based games of the past which only understood a few phrases. With modern ASR engines like Deepgram\u2019s, understanding\r\nthousands of commands has become trivial, and much more interesting and complex uses for speech in games is now possible. I encourage anyone\r\ninterested to try things out and explore with us what the future of speech in games might look like! Off the top of my head, I want to lastly\r\nshare some game ideas to get the creative juices flowing in the community:</p>\n<ul>\n<li>An RPG where warriors fight with swords, archers fight with bows, and mages fight with\u2026 speech! Take the \u201Ccasting spells\u201D approach of this\r\ntutorial and expand it to a game about incantations! (See \u201CIn Verbis Virtus\u201D for even more inspiration here!)</li>\n<li>Speech-enhanced mini-games: imagine playing a Zelda-esque game where you walk into a town and go to the nearest mini-game building and have\r\nto play word games ala \u201CWheel of Fortune\u201D to win your next upgrade!</li>\n<li>Games fully controllable via speech: traditional turn-based games are a great candidate to integrate speech controls, and this could greatly\r\nincrease the accessibility of such games! This type of technology does exist, but it can likely be greatly improved with new powerful ASR engines\r\nlike Deepgram.</li>\n<li>Casual social games: imagine playing word and speech-based games in an environment like VR chat!</li>\n<li>AI-based visual novels: imagine playing a visual novel where instead of picking from a list of phrases to progress, you simply say what\u2019s on your mind!</li>\n<li>AAA AI-enhanced experiences: take the visual novel idea to the next level and enhance AI components of AAA titles by allowing your character to\r\ntalk to NPCs with a microphone! (Check out games like \u201CPhasmophobia\u201D for even more inspiration here!)</li>\n</ul>\n<p>If you have any questions, please feel free to reach out on Twitter - we\u2019re @DeepgramDevs.</p>' }, "file": "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/deepgram-godot-tutorial/index.md" };
function rawContent() {
  return '\nIn this post, we will be making a simplified version of the 2D game "Spooky Speech Spells" (which you can play [here](https://spookyspeechspells.deepgram.com))\r\nin the Godot game engine using an integration with the Deepgram automatic speech recognition (ASR) engine. Why Godot? Because it is an\r\neasy-to-learn, open-source alternative to the popular industry-standard Unity and can export directly to Mac, Windows, Linux, iOS,\r\nAndroid, and HTML5. Why Deepgram? Because it is the fastest, most accurate, cheapest, and easiest to use ASR engine out there! And why\r\nmake a speech-enhanced game? Well, because it\'s cool, and games are fun! Beyond that, adding nontraditional input devices can help make your games more accessible.\n\nThis tutorial is focusing on adding voice input to your game, but if you want to see more tutorials, you can find plenty on the\r\n[Godot website](https://docs.godotengine.org/en/stable/community/tutorials.html).\n\n## Pre-requisites\n\nYou will need:\n\n*   Godot installed on your machine - [download Godot here](https://godotengine.org/download). This tutorial was written with version `3.4.3`.\n*   A Deepgram API Key - [get an API Key here](https://console.deepgram.com/signup?jump=keys).\n\n## Try the Game\n\nTo run the game we are going to build and browse its files:\n\n*   Download [this repository](https://github.com/deepgram/SpeechSpells), open Godot, click "Import", and browse to and select the `project.godot` file from the repo.\n*   In the Godot editor, go to the "FileSystem" tab in the lower left, and navigate to and open `Scenes/Game.gd`.\n*   Edit `line 7` of `Scenes/Game.gd` and enter your Deepgram API Key.\n*   In the top right of the Godot editor, hit the "Play" (\u25BA) button.\n*   Move your character with `WASD` and say "fire" to cast fire spells!\n\n## Building the Game\n\nIn the following sub-sections, we will walk through step-by-step how to make a game where you can move\r\na character around the screen and have the character cast fireball spells by chanting "fire!" into your\r\nmicrophone.\n\n## Setting Up the Project\n\nOpen Godot and create a "New Project" in the project manager.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/new_project.png" alt="Create a new project." style="max-width: 1037px;display: block;margin-left: auto;margin-right: auto;">\n\nNow click "Browse" and choose a directory on your filesystem to store the project, and in the "Project Name"\r\nfield, write "SpeechSpells" and hit "Create Folder." Finally, hit "Create and Edit," and we\'ll get to the Godot\r\nEditor, where we can build our game.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/set_project_name.png" alt="Set the name of the new project." style="max-width: 1038px;display: block;margin-left: auto;margin-right: auto;">\n\nThe Godot Editor consists of several panels and tabs, and we will be going over the ones we need to interact\r\nwith to build "Speech Spells".\n\nLet\'s start with the "Scene" tab in the upper left panel. In this tab, we can put together "Scenes," which,\r\ntogether with "Nodes," form the basic building blocks of Godot games. Scenes and nodes are classes\r\nin object-oriented programming terminology, but the Godot Editor offers an intuitive way to create, edit,\r\nand manage our various game objects as scenes and nodes. Scenes can be almost anything - a collection\r\nof sprite nodes, a character with animations, attacks, and hit-boxes, or just a collection of scripts\r\nthat execute algorithms and can emit signals to other nodes (we will see this pattern further on). For now,\r\nwhere it says "Create Root Node" click "2D Scene" and double click the name of the resulting node and rename\r\nit to "Game". We will create a few other scenes for this game and add instances of those scenes to our Game\r\nscene.\n\nBefore saving the scene, let\'s head over to the lower right "Filesystem" tab. Right-click in the filesystem\r\nbrowser there and click "New Folder..." to create a folder called "Scenes" and then a folder called "Assets".\r\nYou may, of course, organize your projects however you like, but this is at least one way of doing it.\n\nClick on `Scene -> Save Scene` in the upper left corner of the editor to save this scene as `Game.tscn` in the "Scenes" directory that you just created.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/create_folders.png" alt="Set up the game directory structure." style="max-width: 249px;display: block;margin-left: auto;margin-right: auto;">\n\nNow, go to `Project -> Project Settings` from the upper left bar, and we will set a couple of properties of our game.\r\nStart by navigating to `Rendering -> Environment` and change the "Default Clear Color" to black.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/default_clear_color.png" alt="Change the default clear color." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;">\n\nNext, navigate to `Display -> Window`, uncheck "Resizable", set the "Width" to 320, the "Height" to 240,\r\nthe "Test Width" to 960, the "Test Height" to 720, the "Stretch" "Mode" to "2d" and the\r\nStretch "Aspect" to "Keep". This is setting us up to build a game\r\nwith a very low resolution close to 240p (common for 8-bit pixel games), but when we run the game it will\r\ndisplay in a nice big 960x720 window, effectively tripling the size of the pixels. Godot has many options\r\nunder `Display -> Window`, and understanding these can enable you to effortlessly build games that look\r\nfantastic at multiple resolutions and multiple aspect ratios targeting different devices without ever\r\nhaving to think about anything other than your base resolution (320x240 in our case)!\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646549594/blog/2022/03/deepgram-godot-tutorial/assets/change_window_settings.png" alt="Set the window settings." style="max-width: 986px;display: block;margin-left: auto;margin-right: auto;">\n\nWe have one more setting to change - navigate to `Application -> Audio` and check "Enable Audio Input".\r\nA warning will appear saying you will need to restart the editor for this to take effect, click the button\r\nthat appears in the lower right ("Save & Restart") to do so.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/enable_audio.png" alt="Enable audio." style="max-width: 911px;display: block;margin-left: auto;margin-right: auto;">\n\nFinally, click the "Play" button in the upper right (or press "F5") to start up the game - since this is the\r\nfirst time we are playing the game, you will be asked to tell Godot which scene you want to start when the\r\ngame is first opened - we only have `Game.tscn` so select that one. We now have a blank canvas ready to be filled!\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/press_play.png" alt="Start the game." style="max-width: 310px;display: block;margin-left: auto;margin-right: auto;">\n\n## Creating a Player\n\nNow that we have a running game in a window let\'s create a player to move around. In the top left of\r\nthe Godot editor, click `Scene -> New Scene`. Like when you first opened this project, the "Scene" tab\r\nwill give you some options for the root node. Click "Other Node" and navigate to, or use the search\r\nfield to find "KinematicBody2D" and click "Create."\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/create_kinematic_body_2d.png" alt="Create a KinematicBody2D." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;">\n\n"KinematicBody2D" is one of the most reasonable types of objects to use for controllable characters.\r\nThis class/node offers convenient methods to make moving and handling collisions with various objects\r\neasy - we will discuss one of these methods shortly.\n\nNow, right-click the root node and click "Add Child Node" and create a "Sprite" node. Do this again\r\nand add a "CollisionShape2D" node. Your node structure should now look like the following:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/player_node_structure.png" alt="The node structure of the Player - the `KinematicBody2D` root node here contains a `Sprite` node and `CollisionShape2D` node as children." style="max-width: 250px;display: block;margin-left: auto;margin-right: auto;">\n\nThe "Sprite" node will contain the image to use for our player. We will use a pixel art\r\nimage of a skull for our player; you can download it [here](https://res.cloudinary.com/deepgram/image/upload/v1646849910/blog/2022/03/deepgram-godot-tutorial/assets/skull.png). Drag the\r\nfile into the "Assets" directory in the "Filesystem" tab in the lower left, then click on the "Import"\r\ntab next to the "Scene" tab, uncheck "Filter" and click "Reimport":\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/import_skull.png" alt="Import the skull image." style="max-width: 245px;display: block;margin-left: auto;margin-right: auto;">\n\nThis is importing the image into our project and telling our project not to apply interpolation\r\nwhen scaling the image should the window size change from the base window size (which is a tiny\r\n320x240 for us). Most art assets ought to have some interpolation applied when scaling to smaller\r\n(or larger) resolutions, but this looks notoriously bad for pixel art, where one would expect\r\nthe sharp and blocky sprite to remain sharp and blocky at any resolution.\n\nNow, navigate back to the "Scene" tab, click on the "Sprite" node, and drag and drop `skull.png`\r\nfrom the "Asset" directory to the "Texture" field:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/set_skull_texture.png" alt="Set the Player\'s sprite texture." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nAfter doing this, you should see an image in the scene\'s 2D view. Finally, some graphics!\r\nYou may want to play around with zooming in or out to get a better view.\n\nNow, click on the "CollisionShape2D" node, then click on the "Shape" field on the upper right\r\nand select "RectangleShape2D", and change the "Extents" "x" and "y" fields to both be 8:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/add_rectangle_shape_2d.png" alt="Setup the Player\'s CollisionShape2D." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nThis is essentially defining the hit-box of the player. We won\'t utilize hit-boxes\r\nor collision detection in this tutorial, but it is good practice to learn how to\r\nset up a player as one typically would in a more involved game.\n\nRename the root node "Player" and then save the scene as `Player.tscn` in the "Scenes" directory.\r\nNow, with the root node ("Player") selected, hit the button which looks like a script with a green\r\nplus sign on it to create a script for this node:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/attach_script.png" alt="Attach a script to a node." style="max-width: 610px;display: block;margin-left: auto;margin-right: auto;">\n\nThis will create a `Player.gd` script, that will help define how this node functions in the game.\r\n`.gd` is the file extension for GDScript source code. GDScript is one of two languages which Godot uses\r\nnatively (the other being a visual programming language which is quite fun!). GDScript is a lot\r\nlike Python, and has a comparatively easy learning curve, helped by the fact that the Godot engine does most of\r\nthe complicated stuff under the hood, leaving the scripting of game objects to be short and quick.\r\nMake the contents of `Player.gd` the following, and you may start to note how few lines of code it takes to perform some actions:\n\n    extends KinematicBody2D\r\n\r\n    export var speed = 100\r\n    var velocity = Vector2(0, 0)\r\n\r\n    func _physics_process(_delta):\r\n    	if Input.is_key_pressed(KEY_W):\r\n    		velocity.y = -speed\r\n    	elif Input.is_key_pressed(KEY_S):\r\n    		velocity.y = speed\r\n    	else:\r\n    		velocity.y = 0\r\n\r\n    	if Input.is_key_pressed(KEY_A):\r\n    		velocity.x = - speed\r\n    	elif Input.is_key_pressed(KEY_D):\r\n    		velocity.x = speed\r\n    	else:\r\n    		velocity.x = 0\r\n\r\n    	var _returned_velocity = move_and_slide(velocity, Vector2(0, 0), false, 4, 0, false)\r\n\r\n    	if position.x < 0 - 16:\r\n    		position.x = 320 + 16\r\n    	if position.x > 320 + 16:\r\n    		position.x = 0 - 16\r\n\r\n    	if position.y < 0 - 16:\r\n    		position.y = 240 + 16\r\n    	if position.y > 240 + 16:\r\n    		position.y = 0 - 16\n\nThe first line, `extends KinematicBody2D`, is telling us that our script is an extension of the "KinematicBody2D" class,\r\nmeaning we will be able to access any methods and variables that the "KinematicBody2D" class offers, plus any variables\r\nand methods that we introduce here in this file. We then define the variables `speed` and `velocity`. We will use `velocity`\r\nto mean the velocity of the player at any given time, and `speed` to mean the maximum horizontal or vertical speed of the\r\nplayer when we move the player.\n\nNext comes the method `_physics_process(_delta)`. This is a method accessible to many Godot nodes, and is executed\r\nroughly 60 times per second, allowing us to alter objects in a way that the physics engine can understand.\r\nThe "delta" argument is the amount of time that has passed since the last call to `_physics_process`, but here we\r\nare not using it, so we place an underscore in front of the argument name to avoid a warning.\n\nIn this method, we check if the `WASD` keys are pressed, and modify the player\'s velocity accordingly ("W" to move up,\r\n"A" to move left, "S" to move down, and "D" to move right). Note that to move up, we set the "y" velocity to `-speed` - this\r\nis because Godot, like many game engines, considers *down* to be the positive y-direction.\n\nAfter adjusting the player\'s velocity, we call the `move_and_slide` method, specifying the velocity as one of its arguments\r\n(the others don\'t matter for now). This method does a lot of logic internally and can handle collisions with static bodies\r\nand rigid bodies, of any shape or size, and correctly move the player along the surface of bodies instead of bouncing\r\noff of them (hence the "slide"). The method returns the resulting velocity of the player after any collisions/slides,\r\nbut since we won\'t be using this, we place an underscore to avoid a warning.\n\nLastly, we check and modify the position of the player to wrap around the window - i.e. if the player moves too far to the left,\r\nhave them wrap to the right side of the window.\n\nSave, and finally go back to the "Game" scene, and click the button at the top of the "Scene" tab to "Instance Child Scene":\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/instance_child_scene.png" alt="Instance a child scene." style="max-width: 626px;display: block;margin-left: auto;margin-right: auto;">\n\nSelect the `Player.tscn` we just created. Now our main "Game" scene has a "Player" scene as a child node! Click the "Play" button\r\nand now the game boots up with a skull in the corner - you can move the skull around with `WASD`! Feel free to reposition the skull\r\nin the "Game" scene - you can either click and drag the player in the 2D view, or you can directly enter the x and y position\r\nin `Node2D -> Transform -> Position` in the "Inspector" tab when the "Player" node is selected in the "Game" scene:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646785008/blog/2022/03/deepgram-godot-tutorial/assets/player_position_in_editor.png" alt="Setting the Player\'s position." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\n## Creating a Fireball\n\nLet\'s make a fireball scene which we will use to have the player shooting fireballs across the screen.\r\nCreate a new scene, for the root node click "Other Node" and pick "Area2D". Rename this root node "Fireball".\r\nAdd two child nodes: an "AnimatedSprite" and a "CollisionShape2D".\n\nNext, import into your "Assets" directory [fireball\\_1.png](https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_1.png)\r\nand [fireball\\_2.png](https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_2.png).\r\nThe two sprites will make up our fireball animation. For each of the imported fireball sprites, go to the "Import" tab,\r\nuncheck "Filter" and click "Reimport" - just like for our pixel art player sprite, this will ensure that these sprites\r\nmaintain their blocky pixel form even on high-resolution displays.\n\nNow, click the "AnimatedSprite" node, and on the right in the "Frames" field, click where it says "\\[empty]" and select\r\n"New SpriteFrames". Then click the field again and you should be brought to an editor view where we can add our animation.\r\nClick and drag the `fireball_1.png` and `fireball_2.png` files from the "Assets" directory into the "Animation Frames" box:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_animation.png" alt="Create the fireball animation." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nNext, click the "AnimatedSprite" node again to bring up the "Inspector" tab for this node again, check the box titled "Playing".\r\nIn the lower-left of the "Animations" tab, change the "Speed" field to "12 FPS". The fireball should now be animated in the editor:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646784180/blog/2022/03/deepgram-godot-tutorial/assets/fireball_editor_cropped_animated.gif" alt="The fireball animation in the editor." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nThere are certainly several tabs and fields to navigate through in this process, but I hope you find some of these operations intuitive!\r\nTo create animations, you drag the individual frames into the "Animation Frames"\r\nbox, you can then change the speed of the animation just left of this box, and you can set which animation plays by default\r\nin the "Animation" field of the "Inspector" tab for the "AnimatedSprite" node - here you can also set whether the animation\r\nis turned on or off with the "Playing" check box.\n\nNow, click the "CollisionShape2D" node, and in the "Inspector" tab for the "Shape" field select "New CircleShape2D". Then\r\nclick the "CicleShape2D" to edit it\'s properties and change its radius to 4:\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_hitbox.png" alt="Setting the fireball\'s hit-box." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\nNow, save the scene as `Fireball.tscn` in the "Scenes" directory, and then attach a script to the root node. Make the contents\r\nof the script as follows:\n\n    extends Area2D\r\n\r\n    export var speed = 220\r\n    var direction = Vector2(0, 0)\r\n\r\n    func _physics_process(delta):\r\n    	var velocity = direction.normalized() * speed\r\n\r\n    	rotation = velocity.angle()\r\n    	position += velocity * delta\r\n\r\n    	if position.x > 320 + 16:\r\n    		get_tree().queue_delete(self)\r\n    	if position.x < 0 - 16:\r\n    		get_tree().queue_delete(self)\r\n    	if position.y > 240 + 16:\r\n    		get_tree().queue_delete(self)\r\n    	if position.y < 0 - 16:\r\n    		get_tree().queue_delete(self)\n\nLike with the "Player" scene, we are extending the root node\'s class, in this case an "Area2D." We will give each fireball object\r\na speed and a direction. When `_physics_process` is called, we will update the fireball\'s position and angle according to\r\nthe fireball\'s direction and speed. If the fireball goes off-screen, we will destroy it using `get_tree().queue_delete(self)`.\n\nThat\'s all there is to the "Fireball" scene, but we haven\'t actually added any fireballs to our game. We could do this by instancing\r\na "Fireball" scene in our "Game" scene, but for these kinds of objects, there\'s a better way - we should spawn them via code!\n\n## Triggering the Fireball With Keystrokes\n\nGo to the "Game" scene and add a script to the root node, just like we did for the "Player" scene.\r\nThen edit `Game.gd` to have the following contents:\n\n    extends Node2D\r\n\r\n    var rng = RandomNumberGenerator.new()\r\n\r\n    func _ready():\r\n    	rng.randomize()\r\n\r\n    func _input(event):\r\n    	if event is InputEventKey and event.pressed:\r\n    		if event.scancode == KEY_F:\r\n    			for i in rng.randi_range(2, 5):\r\n    				spawn_fireball()\r\n\r\n    func spawn_fireball():\r\n    	var fireball = load("res://Scenes/Fireball.tscn").instance()\r\n    	add_child(fireball)\r\n\r\n    	var random_angle = rng.randf_range(0.0, 2 * PI)\r\n    	fireball.direction = Vector2(cos(random_angle), sin(random_angle))\r\n    	fireball.rotation = fireball.direction.angle()\r\n    	fireball.position = $Player.position\n\nThe first line, `extends Node2D`, is essentially saying that this object is extending the "Node2D" class.\r\nThen, we create a global variable for this object called `rng` which will be used for random number generation.\r\nNext, we define the `_ready()` method which is called when an instance of this scene gets created - in this\r\nmethod we are initializing our random number generator.\n\nThe `_input(event)` method gets called every time there was an input event such as a keystroke, a mouse click,\r\na touch, a game-pad button press, etc. In our case, we are looking to see if the "F" key was pressed, and if\r\nso, we want to spawn 2-5 fireballs!\n\nThe logic handling the spawning of fireballs occurs in the method `spawn_fireball()`. Here we create an instance\r\nof our "Fireball" scene, add it as a child of the current scene, and then initialize the fireball\'s direction,\r\nrotation, and position. We are setting the fireball to spawn exactly where the player object is located,\r\nand we are setting the fireball\'s direction to be totally random.\n\nThe syntax `$Player` is syntax sugar\r\nfor `get_node("Player")` and requires that our "Game" scene has a child node named "Player" (which it does!).\r\nHowever, since GDScript is very much like Python, the game will build and run just fine if one makes\r\na reference to a non-existent object - this will be caught only when the program reaches that line of code,\r\nand it will cause a crash. As Python developers are likely aware, this is sometimes one of the trade-offs of\r\nhaving a "quick and easy" language.\n\nYou should now be able to play the game, move the player around, and press "F" to fire off fireballs! Now\r\nthat the basic game is complete, let\'s add the juicy part by triggering the fireballs not with key presses,\r\nbut with your voice!\n\n## Triggering the Fireball With Your Voice\n\nFinally, let\'s do our Deepgram integration so that we can spawn fireballs by saying "fire" into the microphone instead\r\nof pressing a key. To do this, grab the `DeepgramIntegration` directory from `Scenes/DeepgramIntegration`\r\nfrom the [the SpeechSpells repository](https://github.com/deepgram/SpeechSpells) and place it in the `Scenes/` directory in the Godot editor.\n\nThis integration contains two Godot scenes with accompanying scripts: `MicrophoneInstance` and `DeepgramInstance`.\r\nWe won\'t go over the inner-workings of these scripts in detail, but feel free to have a look as they have\r\na fair amount of descriptive comments to help explain what is going on. In a nutshell, the `MicrophoneInstance`\r\ninterfaces with your device\'s microphone and streams the raw audio from the microphone via Godot signals\r\nto the `DeepgramInstance` which handles connecting to Deepgram via Websockets.\r\nThe `DeepgramInstance` then forwards the raw microphone audio to Deepgram, receives ASR results from Deepgram,\r\nand then forwards those results via Godot signals to some other node. In our case, this other node will be\r\nour "Game" scene\'s root node.\n\n***\n\n***Note***: A common issue which causes the microphone capture to fail on Mac is if Godot\'s audio sample rate is set to\r\nsomething different then the OS\'s audio sample rate. If you experience issues with microphone capture on Mac, you\r\ncan check your OS\'s audio sample rate under `Utilities -> Audio Midi Setup`.\n\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646351903/blog/2022/03/deepgram-godot-tutorial/assets/mac_sample_rate_settings.png" alt="Mac audio sample rate settings." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">\n\n***\n\n***\n\n***Note***: This integration will not work for Godot\'s HTML5 builds out-of-the-box\r\nas authenticating websockets connections with headers is not supported for these builds due to\r\nsome authentication limitations of browsers. If you plan on making an HTML5 game with the Deepgram\r\nintegration, you will have to deploy a proxy server for authentication and make some minor adjustments\r\nof the `DeepgramInstance` scene. This may be a topic of a future guide!\n\n***\n\nIn your "Game" scene, add as a child an instance of the "DeepgramInstance" scene, then modify `Game.gd` as follows:\n\n    extends Node2D\r\n\r\n    var rng = RandomNumberGenerator.new()\r\n\r\n    func _ready():\r\n    	rng.randomize()\r\n    	$DeepgramInstance.initialize("INSERT_YOUR_API_KEY_HERE")\r\n\r\n    func _on_DeepgramInstance_message_received(message):\r\n    	var message_json = JSON.parse(message)\r\n    	if message_json.error == OK:\r\n    		if typeof(message_json.result) == TYPE_DICTIONARY:\r\n    			if message_json.result.has("is_final"):\r\n    				if message_json.result["is_final"] == true:\r\n    					var message_transcript = message_json.result["channel"]["alternatives"][0]["transcript"]\r\n    					print("Transcript received: " + message_transcript)\r\n    					for _i in message.count("fire"):\r\n    						spawn_fireball()\r\n\r\n    	else:\r\n    		print("Failed to parse Deepgram message!")\r\n\r\n    func spawn_fireball():\r\n    	var fireball = load("res://Scenes/Fireball.tscn").instance()\r\n    	add_child(fireball)\r\n\r\n    	var random_angle = rng.randf_range(0.0, 2 * PI)\r\n    	fireball.direction = Vector2(cos(random_angle), sin(random_angle))\r\n    	fireball.rotation = fireball.direction.angle()\r\n    	fireball.position = $Player.position\n\nRemember to replace `INSERT_YOUR_API_KEY_HERE` with your Deepgram API Key.\n\nNow, to finish up, click your "Game" scene\'s "DeepgramInstance" node and in the right panel click the "Node" tab (it should be right next\r\nto the "Inspector" tab). You should see a `message_received()` signal listed under `DeepgramInstance.gd` - double click this,\r\nmake sure that the "Game" node is highlighted, and click "connect".\n\nWhat is this signal doing? Signals are a useful way to organize the transmission of events in game engines.\r\nIn this particular case, the "DeepgramInstance" node is signaling to its parent "Game" node that it has received a message from Deepgram.\r\nIt passes this message with the signal, the parent "Game" node can then react to the signal to trigger further logic.\n\nIn our case, the "Game" node handles this signal in the `_on_DeepgramInstance_message_received` method where tries to parse\r\nthe JSON message from Deepgram into a data structure similar to a Dictionary using `JSON.parse(message)`.\n\nAfter verifying that the message successfully parsed as a Dictionary, it checks to see whether this is a final result or an interim result.\r\nTo understand the difference between final and interim results in the Deepgram realtime streaming API, check out [this page](https://developers.deepgram.com/documentation/features/interim-results/).\r\nFor our purposes, we are only considering final results. We then grab the transcript from the first alternative in the\r\nASR result, and count how many times the word "fire" appears in the transcript, spawning one fireball for each occurrence.\n\n## Build New Features\n\nSo now you can walk around and cast fireball spells with your voice! Here are some ideas for next steps\r\nyou may want to try out to make a more fully-featured game:\n\n*   Implement more spells! Try a thunder spell, or an ice beam spell.\n*   Add enemies and implement collision detection to destroy enemies when your spells hit them.\n*   Try using [interim results](https://developers.deepgram.com/documentation/features/interim-results/) instead of just final results - this should decrease the latency of the spells substantially, but you will need to watch out for\r\n    double-counting as multiple interim results will give transcripts for the same section of audio!\n*   Play around with Deepgram\'s `keyword`, `search`, and/or `phoneme` features to implement spells for out-of-vocab words.\n*   If you are feeling ambitious, work through some Godot networking tutorials to create a multiplayer game where you and your friends cast spells at each other!\n\n## Final Thoughts\n\nSpeech-enhanced games have actually been around for quite some time, with popular titles such as "Hey You, Pikachu!" and "Seaman",\r\nbut it hasn\'t been until more recently that ASR engines have really taken off and can start to offer gameplay experiences which are deeper\r\nthan the simple command-based games of the past which only understood a few phrases. With modern ASR engines like Deepgram\'s, understanding\r\nthousands of commands has become trivial, and much more interesting and complex uses for speech in games is now possible. I encourage anyone\r\ninterested to try things out and explore with us what the future of speech in games might look like! Off the top of my head, I want to lastly\r\nshare some game ideas to get the creative juices flowing in the community:\n\n*   An RPG where warriors fight with swords, archers fight with bows, and mages fight with... speech! Take the "casting spells" approach of this\r\n    tutorial and expand it to a game about incantations! (See "In Verbis Virtus" for even more inspiration here!)\n*   Speech-enhanced mini-games: imagine playing a Zelda-esque game where you walk into a town and go to the nearest mini-game building and have\r\n    to play word games ala "Wheel of Fortune" to win your next upgrade!\n*   Games fully controllable via speech: traditional turn-based games are a great candidate to integrate speech controls, and this could greatly\r\n    increase the accessibility of such games! This type of technology does exist, but it can likely be greatly improved with new powerful ASR engines\r\n    like Deepgram.\n*   Casual social games: imagine playing word and speech-based games in an environment like VR chat!\n*   AI-based visual novels: imagine playing a visual novel where instead of picking from a list of phrases to progress, you simply say what\'s on your mind!\n*   AAA AI-enhanced experiences: take the visual novel idea to the next level and enhance AI components of AAA titles by allowing your character to\r\n    talk to NPCs with a microphone! (Check out games like "Phasmophobia" for even more inspiration here!)\n\nIf you have any questions, please feel free to reach out on Twitter - we\'re @DeepgramDevs.\n\n        ';
}
function compiledContent() {
  return '<p>In this post, we will be making a simplified version of the 2D game \u201CSpooky Speech Spells\u201D (which you can play <a href="https://spookyspeechspells.deepgram.com">here</a>)\r\nin the Godot game engine using an integration with the Deepgram automatic speech recognition (ASR) engine. Why Godot? Because it is an\r\neasy-to-learn, open-source alternative to the popular industry-standard Unity and can export directly to Mac, Windows, Linux, iOS,\r\nAndroid, and HTML5. Why Deepgram? Because it is the fastest, most accurate, cheapest, and easiest to use ASR engine out there! And why\r\nmake a speech-enhanced game? Well, because it\u2019s cool, and games are fun! Beyond that, adding nontraditional input devices can help make your games more accessible.</p>\n<p>This tutorial is focusing on adding voice input to your game, but if you want to see more tutorials, you can find plenty on the\r\n<a href="https://docs.godotengine.org/en/stable/community/tutorials.html">Godot website</a>.</p>\n<h2 id="pre-requisites">Pre-requisites</h2>\n<p>You will need:</p>\n<ul>\n<li>Godot installed on your machine - <a href="https://godotengine.org/download">download Godot here</a>. This tutorial was written with version <code is:raw>3.4.3</code>.</li>\n<li>A Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get an API Key here</a>.</li>\n</ul>\n<h2 id="try-the-game">Try the Game</h2>\n<p>To run the game we are going to build and browse its files:</p>\n<ul>\n<li>Download <a href="https://github.com/deepgram/SpeechSpells">this repository</a>, open Godot, click \u201CImport\u201D, and browse to and select the <code is:raw>project.godot</code> file from the repo.</li>\n<li>In the Godot editor, go to the \u201CFileSystem\u201D tab in the lower left, and navigate to and open <code is:raw>Scenes/Game.gd</code>.</li>\n<li>Edit <code is:raw>line 7</code> of <code is:raw>Scenes/Game.gd</code> and enter your Deepgram API Key.</li>\n<li>In the top right of the Godot editor, hit the \u201CPlay\u201D (\u25BA) button.</li>\n<li>Move your character with <code is:raw>WASD</code> and say \u201Cfire\u201D to cast fire spells!</li>\n</ul>\n<h2 id="building-the-game">Building the Game</h2>\n<p>In the following sub-sections, we will walk through step-by-step how to make a game where you can move\r\na character around the screen and have the character cast fireball spells by chanting \u201Cfire!\u201D into your\r\nmicrophone.</p>\n<h2 id="setting-up-the-project">Setting Up the Project</h2>\n<p>Open Godot and create a \u201CNew Project\u201D in the project manager.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/new_project.png" alt="Create a new project." style="max-width: 1037px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Now click \u201CBrowse\u201D and choose a directory on your filesystem to store the project, and in the \u201CProject Name\u201D\r\nfield, write \u201CSpeechSpells\u201D and hit \u201CCreate Folder.\u201D Finally, hit \u201CCreate and Edit,\u201D and we\u2019ll get to the Godot\r\nEditor, where we can build our game.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/set_project_name.png" alt="Set the name of the new project." style="max-width: 1038px;display: block;margin-left: auto;margin-right: auto;" />\n<p>The Godot Editor consists of several panels and tabs, and we will be going over the ones we need to interact\r\nwith to build \u201CSpeech Spells\u201D.</p>\n<p>Let\u2019s start with the \u201CScene\u201D tab in the upper left panel. In this tab, we can put together \u201CScenes,\u201D which,\r\ntogether with \u201CNodes,\u201D form the basic building blocks of Godot games. Scenes and nodes are classes\r\nin object-oriented programming terminology, but the Godot Editor offers an intuitive way to create, edit,\r\nand manage our various game objects as scenes and nodes. Scenes can be almost anything - a collection\r\nof sprite nodes, a character with animations, attacks, and hit-boxes, or just a collection of scripts\r\nthat execute algorithms and can emit signals to other nodes (we will see this pattern further on). For now,\r\nwhere it says \u201CCreate Root Node\u201D click \u201C2D Scene\u201D and double click the name of the resulting node and rename\r\nit to \u201CGame\u201D. We will create a few other scenes for this game and add instances of those scenes to our Game\r\nscene.</p>\n<p>Before saving the scene, let\u2019s head over to the lower right \u201CFilesystem\u201D tab. Right-click in the filesystem\r\nbrowser there and click \u201CNew Folder\u2026\u201D to create a folder called \u201CScenes\u201D and then a folder called \u201CAssets\u201D.\r\nYou may, of course, organize your projects however you like, but this is at least one way of doing it.</p>\n<p>Click on <code is:raw>Scene -&gt; Save Scene</code> in the upper left corner of the editor to save this scene as <code is:raw>Game.tscn</code> in the \u201CScenes\u201D directory that you just created.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/create_folders.png" alt="Set up the game directory structure." style="max-width: 249px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Now, go to <code is:raw>Project -&gt; Project Settings</code> from the upper left bar, and we will set a couple of properties of our game.\r\nStart by navigating to <code is:raw>Rendering -&gt; Environment</code> and change the \u201CDefault Clear Color\u201D to black.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/default_clear_color.png" alt="Change the default clear color." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Next, navigate to <code is:raw>Display -&gt; Window</code>, uncheck \u201CResizable\u201D, set the \u201CWidth\u201D to 320, the \u201CHeight\u201D to 240,\r\nthe \u201CTest Width\u201D to 960, the \u201CTest Height\u201D to 720, the \u201CStretch\u201D \u201CMode\u201D to \u201C2d\u201D and the\r\nStretch \u201CAspect\u201D to \u201CKeep\u201D. This is setting us up to build a game\r\nwith a very low resolution close to 240p (common for 8-bit pixel games), but when we run the game it will\r\ndisplay in a nice big 960x720 window, effectively tripling the size of the pixels. Godot has many options\r\nunder <code is:raw>Display -&gt; Window</code>, and understanding these can enable you to effortlessly build games that look\r\nfantastic at multiple resolutions and multiple aspect ratios targeting different devices without ever\r\nhaving to think about anything other than your base resolution (320x240 in our case)!</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646549594/blog/2022/03/deepgram-godot-tutorial/assets/change_window_settings.png" alt="Set the window settings." style="max-width: 986px;display: block;margin-left: auto;margin-right: auto;" />\n<p>We have one more setting to change - navigate to <code is:raw>Application -&gt; Audio</code> and check \u201CEnable Audio Input\u201D.\r\nA warning will appear saying you will need to restart the editor for this to take effect, click the button\r\nthat appears in the lower right (\u201CSave & Restart\u201D) to do so.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/enable_audio.png" alt="Enable audio." style="max-width: 911px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Finally, click the \u201CPlay\u201D button in the upper right (or press \u201CF5\u201D) to start up the game - since this is the\r\nfirst time we are playing the game, you will be asked to tell Godot which scene you want to start when the\r\ngame is first opened - we only have <code is:raw>Game.tscn</code> so select that one. We now have a blank canvas ready to be filled!</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/press_play.png" alt="Start the game." style="max-width: 310px;display: block;margin-left: auto;margin-right: auto;" />\n<h2 id="creating-a-player">Creating a Player</h2>\n<p>Now that we have a running game in a window let\u2019s create a player to move around. In the top left of\r\nthe Godot editor, click <code is:raw>Scene -&gt; New Scene</code>. Like when you first opened this project, the \u201CScene\u201D tab\r\nwill give you some options for the root node. Click \u201COther Node\u201D and navigate to, or use the search\r\nfield to find \u201CKinematicBody2D\u201D and click \u201CCreate.\u201D</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/create_kinematic_body_2d.png" alt="Create a KinematicBody2D." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;" />\n<p>\u201CKinematicBody2D\u201D is one of the most reasonable types of objects to use for controllable characters.\r\nThis class/node offers convenient methods to make moving and handling collisions with various objects\r\neasy - we will discuss one of these methods shortly.</p>\n<p>Now, right-click the root node and click \u201CAdd Child Node\u201D and create a \u201CSprite\u201D node. Do this again\r\nand add a \u201CCollisionShape2D\u201D node. Your node structure should now look like the following:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/player_node_structure.png" alt="The node structure of the Player - the `KinematicBody2D` root node here contains a `Sprite` node and `CollisionShape2D` node as children." style="max-width: 250px;display: block;margin-left: auto;margin-right: auto;" />\n<p>The \u201CSprite\u201D node will contain the image to use for our player. We will use a pixel art\r\nimage of a skull for our player; you can download it <a href="https://res.cloudinary.com/deepgram/image/upload/v1646849910/blog/2022/03/deepgram-godot-tutorial/assets/skull.png">here</a>. Drag the\r\nfile into the \u201CAssets\u201D directory in the \u201CFilesystem\u201D tab in the lower left, then click on the \u201CImport\u201D\r\ntab next to the \u201CScene\u201D tab, uncheck \u201CFilter\u201D and click \u201CReimport\u201D:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/import_skull.png" alt="Import the skull image." style="max-width: 245px;display: block;margin-left: auto;margin-right: auto;" />\n<p>This is importing the image into our project and telling our project not to apply interpolation\r\nwhen scaling the image should the window size change from the base window size (which is a tiny\r\n320x240 for us). Most art assets ought to have some interpolation applied when scaling to smaller\r\n(or larger) resolutions, but this looks notoriously bad for pixel art, where one would expect\r\nthe sharp and blocky sprite to remain sharp and blocky at any resolution.</p>\n<p>Now, navigate back to the \u201CScene\u201D tab, click on the \u201CSprite\u201D node, and drag and drop <code is:raw>skull.png</code>\r\nfrom the \u201CAsset\u201D directory to the \u201CTexture\u201D field:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/set_skull_texture.png" alt="Set the Player\'s sprite texture." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>After doing this, you should see an image in the scene\u2019s 2D view. Finally, some graphics!\r\nYou may want to play around with zooming in or out to get a better view.</p>\n<p>Now, click on the \u201CCollisionShape2D\u201D node, then click on the \u201CShape\u201D field on the upper right\r\nand select \u201CRectangleShape2D\u201D, and change the \u201CExtents\u201D \u201Cx\u201D and \u201Cy\u201D fields to both be 8:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/add_rectangle_shape_2d.png" alt="Setup the Player\'s CollisionShape2D." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>This is essentially defining the hit-box of the player. We won\u2019t utilize hit-boxes\r\nor collision detection in this tutorial, but it is good practice to learn how to\r\nset up a player as one typically would in a more involved game.</p>\n<p>Rename the root node \u201CPlayer\u201D and then save the scene as <code is:raw>Player.tscn</code> in the \u201CScenes\u201D directory.\r\nNow, with the root node (\u201CPlayer\u201D) selected, hit the button which looks like a script with a green\r\nplus sign on it to create a script for this node:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/attach_script.png" alt="Attach a script to a node." style="max-width: 610px;display: block;margin-left: auto;margin-right: auto;" />\n<p>This will create a <code is:raw>Player.gd</code> script, that will help define how this node functions in the game.\r\n<code is:raw>.gd</code> is the file extension for GDScript source code. GDScript is one of two languages which Godot uses\r\nnatively (the other being a visual programming language which is quite fun!). GDScript is a lot\r\nlike Python, and has a comparatively easy learning curve, helped by the fact that the Godot engine does most of\r\nthe complicated stuff under the hood, leaving the scripting of game objects to be short and quick.\r\nMake the contents of <code is:raw>Player.gd</code> the following, and you may start to note how few lines of code it takes to perform some actions:</p>\n<p>extends KinematicBody2D</p>\n<p>export var speed = 100\r\nvar velocity = Vector2(0, 0)</p>\n<p>func _physics_process(_delta):\r\nif Input.is_key_pressed(KEY_W):\r\nvelocity.y = -speed\r\nelif Input.is_key_pressed(KEY_S):\r\nvelocity.y = speed\r\nelse:\r\nvelocity.y = 0</p>\n<p>if Input.is_key_pressed(KEY_A):\r\nvelocity.x = - speed\r\nelif Input.is_key_pressed(KEY_D):\r\nvelocity.x = speed\r\nelse:\r\nvelocity.x = 0</p>\n<p>var _returned_velocity = move_and_slide(velocity, Vector2(0, 0), false, 4, 0, false)</p>\n<p>if position.x < 0 - 16:\r\nposition.x = 320 + 16\r\nif position.x > 320 + 16:\r\nposition.x = 0 - 16</p>\n<p>if position.y < 0 - 16:\r\nposition.y = 240 + 16\r\nif position.y > 240 + 16:\r\nposition.y = 0 - 16</p>\n<p>The first line, <code is:raw>extends KinematicBody2D</code>, is telling us that our script is an extension of the \u201CKinematicBody2D\u201D class,\r\nmeaning we will be able to access any methods and variables that the \u201CKinematicBody2D\u201D class offers, plus any variables\r\nand methods that we introduce here in this file. We then define the variables <code is:raw>speed</code> and <code is:raw>velocity</code>. We will use <code is:raw>velocity</code>\r\nto mean the velocity of the player at any given time, and <code is:raw>speed</code> to mean the maximum horizontal or vertical speed of the\r\nplayer when we move the player.</p>\n<p>Next comes the method <code is:raw>_physics_process(_delta)</code>. This is a method accessible to many Godot nodes, and is executed\r\nroughly 60 times per second, allowing us to alter objects in a way that the physics engine can understand.\r\nThe \u201Cdelta\u201D argument is the amount of time that has passed since the last call to <code is:raw>_physics_process</code>, but here we\r\nare not using it, so we place an underscore in front of the argument name to avoid a warning.</p>\n<p>In this method, we check if the <code is:raw>WASD</code> keys are pressed, and modify the player\u2019s velocity accordingly (\u201CW\u201D to move up,\r\n\u201CA\u201D to move left, \u201CS\u201D to move down, and \u201CD\u201D to move right). Note that to move up, we set the \u201Cy\u201D velocity to <code is:raw>-speed</code> - this\r\nis because Godot, like many game engines, considers <em>down</em> to be the positive y-direction.</p>\n<p>After adjusting the player\u2019s velocity, we call the <code is:raw>move_and_slide</code> method, specifying the velocity as one of its arguments\r\n(the others don\u2019t matter for now). This method does a lot of logic internally and can handle collisions with static bodies\r\nand rigid bodies, of any shape or size, and correctly move the player along the surface of bodies instead of bouncing\r\noff of them (hence the \u201Cslide\u201D). The method returns the resulting velocity of the player after any collisions/slides,\r\nbut since we won\u2019t be using this, we place an underscore to avoid a warning.</p>\n<p>Lastly, we check and modify the position of the player to wrap around the window - i.e. if the player moves too far to the left,\r\nhave them wrap to the right side of the window.</p>\n<p>Save, and finally go back to the \u201CGame\u201D scene, and click the button at the top of the \u201CScene\u201D tab to \u201CInstance Child Scene\u201D:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/instance_child_scene.png" alt="Instance a child scene." style="max-width: 626px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Select the <code is:raw>Player.tscn</code> we just created. Now our main \u201CGame\u201D scene has a \u201CPlayer\u201D scene as a child node! Click the \u201CPlay\u201D button\r\nand now the game boots up with a skull in the corner - you can move the skull around with <code is:raw>WASD</code>! Feel free to reposition the skull\r\nin the \u201CGame\u201D scene - you can either click and drag the player in the 2D view, or you can directly enter the x and y position\r\nin <code is:raw>Node2D -&gt; Transform -&gt; Position</code> in the \u201CInspector\u201D tab when the \u201CPlayer\u201D node is selected in the \u201CGame\u201D scene:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646785008/blog/2022/03/deepgram-godot-tutorial/assets/player_position_in_editor.png" alt="Setting the Player\'s position." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<h2 id="creating-a-fireball">Creating a Fireball</h2>\n<p>Let\u2019s make a fireball scene which we will use to have the player shooting fireballs across the screen.\r\nCreate a new scene, for the root node click \u201COther Node\u201D and pick \u201CArea2D\u201D. Rename this root node \u201CFireball\u201D.\r\nAdd two child nodes: an \u201CAnimatedSprite\u201D and a \u201CCollisionShape2D\u201D.</p>\n<p>Next, import into your \u201CAssets\u201D directory <a href="https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_1.png">fireball_1.png</a>\r\nand <a href="https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_2.png">fireball_2.png</a>.\r\nThe two sprites will make up our fireball animation. For each of the imported fireball sprites, go to the \u201CImport\u201D tab,\r\nuncheck \u201CFilter\u201D and click \u201CReimport\u201D - just like for our pixel art player sprite, this will ensure that these sprites\r\nmaintain their blocky pixel form even on high-resolution displays.</p>\n<p>Now, click the \u201CAnimatedSprite\u201D node, and on the right in the \u201CFrames\u201D field, click where it says \u201C[empty]\u201D and select\r\n\u201CNew SpriteFrames\u201D. Then click the field again and you should be brought to an editor view where we can add our animation.\r\nClick and drag the <code is:raw>fireball_1.png</code> and <code is:raw>fireball_2.png</code> files from the \u201CAssets\u201D directory into the \u201CAnimation Frames\u201D box:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_animation.png" alt="Create the fireball animation." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Next, click the \u201CAnimatedSprite\u201D node again to bring up the \u201CInspector\u201D tab for this node again, check the box titled \u201CPlaying\u201D.\r\nIn the lower-left of the \u201CAnimations\u201D tab, change the \u201CSpeed\u201D field to \u201C12 FPS\u201D. The fireball should now be animated in the editor:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646784180/blog/2022/03/deepgram-godot-tutorial/assets/fireball_editor_cropped_animated.gif" alt="The fireball animation in the editor." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>There are certainly several tabs and fields to navigate through in this process, but I hope you find some of these operations intuitive!\r\nTo create animations, you drag the individual frames into the \u201CAnimation Frames\u201D\r\nbox, you can then change the speed of the animation just left of this box, and you can set which animation plays by default\r\nin the \u201CAnimation\u201D field of the \u201CInspector\u201D tab for the \u201CAnimatedSprite\u201D node - here you can also set whether the animation\r\nis turned on or off with the \u201CPlaying\u201D check box.</p>\n<p>Now, click the \u201CCollisionShape2D\u201D node, and in the \u201CInspector\u201D tab for the \u201CShape\u201D field select \u201CNew CircleShape2D\u201D. Then\r\nclick the \u201CCicleShape2D\u201D to edit it\u2019s properties and change its radius to 4:</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_hitbox.png" alt="Setting the fireball\'s hit-box." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<p>Now, save the scene as <code is:raw>Fireball.tscn</code> in the \u201CScenes\u201D directory, and then attach a script to the root node. Make the contents\r\nof the script as follows:</p>\n<p>extends Area2D</p>\n<p>export var speed = 220\r\nvar direction = Vector2(0, 0)</p>\n<p>func _physics_process(delta):\r\nvar velocity = direction.normalized() * speed</p>\n<p>rotation = velocity.angle()\r\nposition += velocity * delta</p>\n<p>if position.x > 320 + 16:\r\nget_tree().queue_delete(self)\r\nif position.x < 0 - 16:\r\nget_tree().queue_delete(self)\r\nif position.y > 240 + 16:\r\nget_tree().queue_delete(self)\r\nif position.y < 0 - 16:\r\nget_tree().queue_delete(self)</p>\n<p>Like with the \u201CPlayer\u201D scene, we are extending the root node\u2019s class, in this case an \u201CArea2D.\u201D We will give each fireball object\r\na speed and a direction. When <code is:raw>_physics_process</code> is called, we will update the fireball\u2019s position and angle according to\r\nthe fireball\u2019s direction and speed. If the fireball goes off-screen, we will destroy it using <code is:raw>get_tree().queue_delete(self)</code>.</p>\n<p>That\u2019s all there is to the \u201CFireball\u201D scene, but we haven\u2019t actually added any fireballs to our game. We could do this by instancing\r\na \u201CFireball\u201D scene in our \u201CGame\u201D scene, but for these kinds of objects, there\u2019s a better way - we should spawn them via code!</p>\n<h2 id="triggering-the-fireball-with-keystrokes">Triggering the Fireball With Keystrokes</h2>\n<p>Go to the \u201CGame\u201D scene and add a script to the root node, just like we did for the \u201CPlayer\u201D scene.\r\nThen edit <code is:raw>Game.gd</code> to have the following contents:</p>\n<p>extends Node2D</p>\n<p>var rng = RandomNumberGenerator.new()</p>\n<p>func _ready():\r\nrng.randomize()</p>\n<p>func _input(event):\r\nif event is InputEventKey and event.pressed:\r\nif event.scancode == KEY_F:\r\nfor i in rng.randi_range(2, 5):\r\nspawn_fireball()</p>\n<p>func spawn_fireball():\r\nvar fireball = load(\u201Cres://Scenes/Fireball.tscn\u201D).instance()\r\nadd_child(fireball)</p>\n<p>var random_angle = rng.randf_range(0.0, 2 * PI)\r\nfireball.direction = Vector2(cos(random_angle), sin(random_angle))\r\nfireball.rotation = fireball.direction.angle()\r\nfireball.position = $Player.position</p>\n<p>The first line, <code is:raw>extends Node2D</code>, is essentially saying that this object is extending the \u201CNode2D\u201D class.\r\nThen, we create a global variable for this object called <code is:raw>rng</code> which will be used for random number generation.\r\nNext, we define the <code is:raw>_ready()</code> method which is called when an instance of this scene gets created - in this\r\nmethod we are initializing our random number generator.</p>\n<p>The <code is:raw>_input(event)</code> method gets called every time there was an input event such as a keystroke, a mouse click,\r\na touch, a game-pad button press, etc. In our case, we are looking to see if the \u201CF\u201D key was pressed, and if\r\nso, we want to spawn 2-5 fireballs!</p>\n<p>The logic handling the spawning of fireballs occurs in the method <code is:raw>spawn_fireball()</code>. Here we create an instance\r\nof our \u201CFireball\u201D scene, add it as a child of the current scene, and then initialize the fireball\u2019s direction,\r\nrotation, and position. We are setting the fireball to spawn exactly where the player object is located,\r\nand we are setting the fireball\u2019s direction to be totally random.</p>\n<p>The syntax <code is:raw>$Player</code> is syntax sugar\r\nfor <code is:raw>get_node("Player")</code> and requires that our \u201CGame\u201D scene has a child node named \u201CPlayer\u201D (which it does!).\r\nHowever, since GDScript is very much like Python, the game will build and run just fine if one makes\r\na reference to a non-existent object - this will be caught only when the program reaches that line of code,\r\nand it will cause a crash. As Python developers are likely aware, this is sometimes one of the trade-offs of\r\nhaving a \u201Cquick and easy\u201D language.</p>\n<p>You should now be able to play the game, move the player around, and press \u201CF\u201D to fire off fireballs! Now\r\nthat the basic game is complete, let\u2019s add the juicy part by triggering the fireballs not with key presses,\r\nbut with your voice!</p>\n<h2 id="triggering-the-fireball-with-your-voice">Triggering the Fireball With Your Voice</h2>\n<p>Finally, let\u2019s do our Deepgram integration so that we can spawn fireballs by saying \u201Cfire\u201D into the microphone instead\r\nof pressing a key. To do this, grab the <code is:raw>DeepgramIntegration</code> directory from <code is:raw>Scenes/DeepgramIntegration</code>\r\nfrom the <a href="https://github.com/deepgram/SpeechSpells">the SpeechSpells repository</a> and place it in the <code is:raw>Scenes/</code> directory in the Godot editor.</p>\n<p>This integration contains two Godot scenes with accompanying scripts: <code is:raw>MicrophoneInstance</code> and <code is:raw>DeepgramInstance</code>.\r\nWe won\u2019t go over the inner-workings of these scripts in detail, but feel free to have a look as they have\r\na fair amount of descriptive comments to help explain what is going on. In a nutshell, the <code is:raw>MicrophoneInstance</code>\r\ninterfaces with your device\u2019s microphone and streams the raw audio from the microphone via Godot signals\r\nto the <code is:raw>DeepgramInstance</code> which handles connecting to Deepgram via Websockets.\r\nThe <code is:raw>DeepgramInstance</code> then forwards the raw microphone audio to Deepgram, receives ASR results from Deepgram,\r\nand then forwards those results via Godot signals to some other node. In our case, this other node will be\r\nour \u201CGame\u201D scene\u2019s root node.</p>\n<hr>\n<p><em><strong>Note</strong></em>: A common issue which causes the microphone capture to fail on Mac is if Godot\u2019s audio sample rate is set to\r\nsomething different then the OS\u2019s audio sample rate. If you experience issues with microphone capture on Mac, you\r\ncan check your OS\u2019s audio sample rate under <code is:raw>Utilities -&gt; Audio Midi Setup</code>.</p>\n<img src="https://res.cloudinary.com/deepgram/image/upload/v1646351903/blog/2022/03/deepgram-godot-tutorial/assets/mac_sample_rate_settings.png" alt="Mac audio sample rate settings." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;" />\n<hr>\n<hr>\n<p><em><strong>Note</strong></em>: This integration will not work for Godot\u2019s HTML5 builds out-of-the-box\r\nas authenticating websockets connections with headers is not supported for these builds due to\r\nsome authentication limitations of browsers. If you plan on making an HTML5 game with the Deepgram\r\nintegration, you will have to deploy a proxy server for authentication and make some minor adjustments\r\nof the <code is:raw>DeepgramInstance</code> scene. This may be a topic of a future guide!</p>\n<hr>\n<p>In your \u201CGame\u201D scene, add as a child an instance of the \u201CDeepgramInstance\u201D scene, then modify <code is:raw>Game.gd</code> as follows:</p>\n<p>extends Node2D</p>\n<p>var rng = RandomNumberGenerator.new()</p>\n<p>func _ready():\r\nrng.randomize()\r\n$DeepgramInstance.initialize(\u201CINSERT_YOUR_API_KEY_HERE\u201D)</p>\n<p>func _on_DeepgramInstance_message_received(message):\r\nvar message_json = JSON.parse(message)\r\nif message_json.error == OK:\r\nif typeof(message_json.result) == TYPE_DICTIONARY:\r\nif message_json.result.has(\u201Cis_final\u201D):\r\nif message_json.result[\u201Cis_final\u201D] == true:\r\nvar message_transcript = message_json.result[\u201Cchannel\u201D][\u201Calternatives\u201D][0][\u201Ctranscript\u201D]\r\nprint(\u201CTranscript received: \u201D + message_transcript)\r\nfor _i in message.count(\u201Cfire\u201D):\r\nspawn_fireball()</p>\n<p>else:\r\nprint(\u201CFailed to parse Deepgram message!\u201C)</p>\n<p>func spawn_fireball():\r\nvar fireball = load(\u201Cres://Scenes/Fireball.tscn\u201D).instance()\r\nadd_child(fireball)</p>\n<p>var random_angle = rng.randf_range(0.0, 2 * PI)\r\nfireball.direction = Vector2(cos(random_angle), sin(random_angle))\r\nfireball.rotation = fireball.direction.angle()\r\nfireball.position = $Player.position</p>\n<p>Remember to replace <code is:raw>INSERT_YOUR_API_KEY_HERE</code> with your Deepgram API Key.</p>\n<p>Now, to finish up, click your \u201CGame\u201D scene\u2019s \u201CDeepgramInstance\u201D node and in the right panel click the \u201CNode\u201D tab (it should be right next\r\nto the \u201CInspector\u201D tab). You should see a <code is:raw>message_received()</code> signal listed under <code is:raw>DeepgramInstance.gd</code> - double click this,\r\nmake sure that the \u201CGame\u201D node is highlighted, and click \u201Cconnect\u201D.</p>\n<p>What is this signal doing? Signals are a useful way to organize the transmission of events in game engines.\r\nIn this particular case, the \u201CDeepgramInstance\u201D node is signaling to its parent \u201CGame\u201D node that it has received a message from Deepgram.\r\nIt passes this message with the signal, the parent \u201CGame\u201D node can then react to the signal to trigger further logic.</p>\n<p>In our case, the \u201CGame\u201D node handles this signal in the <code is:raw>_on_DeepgramInstance_message_received</code> method where tries to parse\r\nthe JSON message from Deepgram into a data structure similar to a Dictionary using <code is:raw>JSON.parse(message)</code>.</p>\n<p>After verifying that the message successfully parsed as a Dictionary, it checks to see whether this is a final result or an interim result.\r\nTo understand the difference between final and interim results in the Deepgram realtime streaming API, check out <a href="https://developers.deepgram.com/documentation/features/interim-results/">this page</a>.\r\nFor our purposes, we are only considering final results. We then grab the transcript from the first alternative in the\r\nASR result, and count how many times the word \u201Cfire\u201D appears in the transcript, spawning one fireball for each occurrence.</p>\n<h2 id="build-new-features">Build New Features</h2>\n<p>So now you can walk around and cast fireball spells with your voice! Here are some ideas for next steps\r\nyou may want to try out to make a more fully-featured game:</p>\n<ul>\n<li>Implement more spells! Try a thunder spell, or an ice beam spell.</li>\n<li>Add enemies and implement collision detection to destroy enemies when your spells hit them.</li>\n<li>Try using <a href="https://developers.deepgram.com/documentation/features/interim-results/">interim results</a> instead of just final results - this should decrease the latency of the spells substantially, but you will need to watch out for\r\ndouble-counting as multiple interim results will give transcripts for the same section of audio!</li>\n<li>Play around with Deepgram\u2019s <code is:raw>keyword</code>, <code is:raw>search</code>, and/or <code is:raw>phoneme</code> features to implement spells for out-of-vocab words.</li>\n<li>If you are feeling ambitious, work through some Godot networking tutorials to create a multiplayer game where you and your friends cast spells at each other!</li>\n</ul>\n<h2 id="final-thoughts">Final Thoughts</h2>\n<p>Speech-enhanced games have actually been around for quite some time, with popular titles such as \u201CHey You, Pikachu!\u201D and \u201CSeaman\u201D,\r\nbut it hasn\u2019t been until more recently that ASR engines have really taken off and can start to offer gameplay experiences which are deeper\r\nthan the simple command-based games of the past which only understood a few phrases. With modern ASR engines like Deepgram\u2019s, understanding\r\nthousands of commands has become trivial, and much more interesting and complex uses for speech in games is now possible. I encourage anyone\r\ninterested to try things out and explore with us what the future of speech in games might look like! Off the top of my head, I want to lastly\r\nshare some game ideas to get the creative juices flowing in the community:</p>\n<ul>\n<li>An RPG where warriors fight with swords, archers fight with bows, and mages fight with\u2026 speech! Take the \u201Ccasting spells\u201D approach of this\r\ntutorial and expand it to a game about incantations! (See \u201CIn Verbis Virtus\u201D for even more inspiration here!)</li>\n<li>Speech-enhanced mini-games: imagine playing a Zelda-esque game where you walk into a town and go to the nearest mini-game building and have\r\nto play word games ala \u201CWheel of Fortune\u201D to win your next upgrade!</li>\n<li>Games fully controllable via speech: traditional turn-based games are a great candidate to integrate speech controls, and this could greatly\r\nincrease the accessibility of such games! This type of technology does exist, but it can likely be greatly improved with new powerful ASR engines\r\nlike Deepgram.</li>\n<li>Casual social games: imagine playing word and speech-based games in an environment like VR chat!</li>\n<li>AI-based visual novels: imagine playing a visual novel where instead of picking from a list of phrases to progress, you simply say what\u2019s on your mind!</li>\n<li>AAA AI-enhanced experiences: take the visual novel idea to the next level and enhance AI components of AAA titles by allowing your character to\r\ntalk to NPCs with a microphone! (Check out games like \u201CPhasmophobia\u201D for even more inspiration here!)</li>\n</ul>\n<p>If you have any questions, please feel free to reach out on Twitter - we\u2019re @DeepgramDevs.</p>';
}
const $$Astro = createAstro("/Users/sandrarodgers/web-next/blog/src/content/blog/posts/deepgram-godot-tutorial/index.md", "", "file:///Users/sandrarodgers/web-next/blog/");
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  new Slugger();
  return renderTemplate`<head>${renderHead($$result)}</head><p>In this post, we will be making a simplified version of the 2D game “Spooky Speech Spells” (which you can play <a href="https://spookyspeechspells.deepgram.com">here</a>)
in the Godot game engine using an integration with the Deepgram automatic speech recognition (ASR) engine. Why Godot? Because it is an
easy-to-learn, open-source alternative to the popular industry-standard Unity and can export directly to Mac, Windows, Linux, iOS,
Android, and HTML5. Why Deepgram? Because it is the fastest, most accurate, cheapest, and easiest to use ASR engine out there! And why
make a speech-enhanced game? Well, because it’s cool, and games are fun! Beyond that, adding nontraditional input devices can help make your games more accessible.</p>
<p>This tutorial is focusing on adding voice input to your game, but if you want to see more tutorials, you can find plenty on the
<a href="https://docs.godotengine.org/en/stable/community/tutorials.html">Godot website</a>.</p>
<h2 id="pre-requisites">Pre-requisites</h2>
<p>You will need:</p>
<ul>
<li>Godot installed on your machine - <a href="https://godotengine.org/download">download Godot here</a>. This tutorial was written with version <code>3.4.3</code>.</li>
<li>A Deepgram API Key - <a href="https://console.deepgram.com/signup?jump=keys">get an API Key here</a>.</li>
</ul>
<h2 id="try-the-game">Try the Game</h2>
<p>To run the game we are going to build and browse its files:</p>
<ul>
<li>Download <a href="https://github.com/deepgram/SpeechSpells">this repository</a>, open Godot, click “Import”, and browse to and select the <code>project.godot</code> file from the repo.</li>
<li>In the Godot editor, go to the “FileSystem” tab in the lower left, and navigate to and open <code>Scenes/Game.gd</code>.</li>
<li>Edit <code>line 7</code> of <code>Scenes/Game.gd</code> and enter your Deepgram API Key.</li>
<li>In the top right of the Godot editor, hit the “Play” (►) button.</li>
<li>Move your character with <code>WASD</code> and say “fire” to cast fire spells!</li>
</ul>
<h2 id="building-the-game">Building the Game</h2>
<p>In the following sub-sections, we will walk through step-by-step how to make a game where you can move
a character around the screen and have the character cast fireball spells by chanting “fire!” into your
microphone.</p>
<h2 id="setting-up-the-project">Setting Up the Project</h2>
<p>Open Godot and create a “New Project” in the project manager.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/new_project.png" alt="Create a new project." style="max-width: 1037px;display: block;margin-left: auto;margin-right: auto;">
<p>Now click “Browse” and choose a directory on your filesystem to store the project, and in the “Project Name”
field, write “SpeechSpells” and hit “Create Folder.” Finally, hit “Create and Edit,” and we’ll get to the Godot
Editor, where we can build our game.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/set_project_name.png" alt="Set the name of the new project." style="max-width: 1038px;display: block;margin-left: auto;margin-right: auto;">
<p>The Godot Editor consists of several panels and tabs, and we will be going over the ones we need to interact
with to build “Speech Spells”.</p>
<p>Let’s start with the “Scene” tab in the upper left panel. In this tab, we can put together “Scenes,” which,
together with “Nodes,” form the basic building blocks of Godot games. Scenes and nodes are classes
in object-oriented programming terminology, but the Godot Editor offers an intuitive way to create, edit,
and manage our various game objects as scenes and nodes. Scenes can be almost anything - a collection
of sprite nodes, a character with animations, attacks, and hit-boxes, or just a collection of scripts
that execute algorithms and can emit signals to other nodes (we will see this pattern further on). For now,
where it says “Create Root Node” click “2D Scene” and double click the name of the resulting node and rename
it to “Game”. We will create a few other scenes for this game and add instances of those scenes to our Game
scene.</p>
<p>Before saving the scene, let’s head over to the lower right “Filesystem” tab. Right-click in the filesystem
browser there and click “New Folder…” to create a folder called “Scenes” and then a folder called “Assets”.
You may, of course, organize your projects however you like, but this is at least one way of doing it.</p>
<p>Click on <code>Scene -&gt; Save Scene</code> in the upper left corner of the editor to save this scene as <code>Game.tscn</code> in the “Scenes” directory that you just created.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/create_folders.png" alt="Set up the game directory structure." style="max-width: 249px;display: block;margin-left: auto;margin-right: auto;">
<p>Now, go to <code>Project -&gt; Project Settings</code> from the upper left bar, and we will set a couple of properties of our game.
Start by navigating to <code>Rendering -&gt; Environment</code> and change the “Default Clear Color” to black.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/default_clear_color.png" alt="Change the default clear color." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;">
<p>Next, navigate to <code>Display -&gt; Window</code>, uncheck “Resizable”, set the “Width” to 320, the “Height” to 240,
the “Test Width” to 960, the “Test Height” to 720, the “Stretch” “Mode” to “2d” and the
Stretch “Aspect” to “Keep”. This is setting us up to build a game
with a very low resolution close to 240p (common for 8-bit pixel games), but when we run the game it will
display in a nice big 960x720 window, effectively tripling the size of the pixels. Godot has many options
under <code>Display -&gt; Window</code>, and understanding these can enable you to effortlessly build games that look
fantastic at multiple resolutions and multiple aspect ratios targeting different devices without ever
having to think about anything other than your base resolution (320x240 in our case)!</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646549594/blog/2022/03/deepgram-godot-tutorial/assets/change_window_settings.png" alt="Set the window settings." style="max-width: 986px;display: block;margin-left: auto;margin-right: auto;">
<p>We have one more setting to change - navigate to <code>Application -&gt; Audio</code> and check “Enable Audio Input”.
A warning will appear saying you will need to restart the editor for this to take effect, click the button
that appears in the lower right (“Save & Restart”) to do so.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/enable_audio.png" alt="Enable audio." style="max-width: 911px;display: block;margin-left: auto;margin-right: auto;">
<p>Finally, click the “Play” button in the upper right (or press “F5”) to start up the game - since this is the
first time we are playing the game, you will be asked to tell Godot which scene you want to start when the
game is first opened - we only have <code>Game.tscn</code> so select that one. We now have a blank canvas ready to be filled!</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646455688/blog/2022/03/deepgram-godot-tutorial/assets/press_play.png" alt="Start the game." style="max-width: 310px;display: block;margin-left: auto;margin-right: auto;">
<h2 id="creating-a-player">Creating a Player</h2>
<p>Now that we have a running game in a window let’s create a player to move around. In the top left of
the Godot editor, click <code>Scene -&gt; New Scene</code>. Like when you first opened this project, the “Scene” tab
will give you some options for the root node. Click “Other Node” and navigate to, or use the search
field to find “KinematicBody2D” and click “Create.”</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/create_kinematic_body_2d.png" alt="Create a KinematicBody2D." style="max-width: 913px;display: block;margin-left: auto;margin-right: auto;">
<p>“KinematicBody2D” is one of the most reasonable types of objects to use for controllable characters.
This class/node offers convenient methods to make moving and handling collisions with various objects
easy - we will discuss one of these methods shortly.</p>
<p>Now, right-click the root node and click “Add Child Node” and create a “Sprite” node. Do this again
and add a “CollisionShape2D” node. Your node structure should now look like the following:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/player_node_structure.png" alt="The node structure of the Player - the \`KinematicBody2D\` root node here contains a \`Sprite\` node and \`CollisionShape2D\` node as children." style="max-width: 250px;display: block;margin-left: auto;margin-right: auto;">
<p>The “Sprite” node will contain the image to use for our player. We will use a pixel art
image of a skull for our player; you can download it <a href="https://res.cloudinary.com/deepgram/image/upload/v1646849910/blog/2022/03/deepgram-godot-tutorial/assets/skull.png">here</a>. Drag the
file into the “Assets” directory in the “Filesystem” tab in the lower left, then click on the “Import”
tab next to the “Scene” tab, uncheck “Filter” and click “Reimport”:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/import_skull.png" alt="Import the skull image." style="max-width: 245px;display: block;margin-left: auto;margin-right: auto;">
<p>This is importing the image into our project and telling our project not to apply interpolation
when scaling the image should the window size change from the base window size (which is a tiny
320x240 for us). Most art assets ought to have some interpolation applied when scaling to smaller
(or larger) resolutions, but this looks notoriously bad for pixel art, where one would expect
the sharp and blocky sprite to remain sharp and blocky at any resolution.</p>
<p>Now, navigate back to the “Scene” tab, click on the “Sprite” node, and drag and drop <code>skull.png</code>
from the “Asset” directory to the “Texture” field:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/set_skull_texture.png" alt="Set the Player's sprite texture." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">
<p>After doing this, you should see an image in the scene’s 2D view. Finally, some graphics!
You may want to play around with zooming in or out to get a better view.</p>
<p>Now, click on the “CollisionShape2D” node, then click on the “Shape” field on the upper right
and select “RectangleShape2D”, and change the “Extents” “x” and “y” fields to both be 8:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548729/blog/2022/03/deepgram-godot-tutorial/assets/add_rectangle_shape_2d.png" alt="Setup the Player's CollisionShape2D." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">
<p>This is essentially defining the hit-box of the player. We won’t utilize hit-boxes
or collision detection in this tutorial, but it is good practice to learn how to
set up a player as one typically would in a more involved game.</p>
<p>Rename the root node “Player” and then save the scene as <code>Player.tscn</code> in the “Scenes” directory.
Now, with the root node (“Player”) selected, hit the button which looks like a script with a green
plus sign on it to create a script for this node:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/attach_script.png" alt="Attach a script to a node." style="max-width: 610px;display: block;margin-left: auto;margin-right: auto;">
<p>This will create a <code>Player.gd</code> script, that will help define how this node functions in the game.
<code>.gd</code> is the file extension for GDScript source code. GDScript is one of two languages which Godot uses
natively (the other being a visual programming language which is quite fun!). GDScript is a lot
like Python, and has a comparatively easy learning curve, helped by the fact that the Godot engine does most of
the complicated stuff under the hood, leaving the scripting of game objects to be short and quick.
Make the contents of <code>Player.gd</code> the following, and you may start to note how few lines of code it takes to perform some actions:</p>
<p>extends KinematicBody2D</p>
<p>export var speed = 100
var velocity = Vector2(0, 0)</p>
<p>func _physics_process(_delta):
if Input.is_key_pressed(KEY_W):
velocity.y = -speed
elif Input.is_key_pressed(KEY_S):
velocity.y = speed
else:
velocity.y = 0</p>
<p>if Input.is_key_pressed(KEY_A):
velocity.x = - speed
elif Input.is_key_pressed(KEY_D):
velocity.x = speed
else:
velocity.x = 0</p>
<p>var _returned_velocity = move_and_slide(velocity, Vector2(0, 0), false, 4, 0, false)</p>
<p>if position.x < 0 - 16:
position.x = 320 + 16
if position.x > 320 + 16:
position.x = 0 - 16</p>
<p>if position.y < 0 - 16:
position.y = 240 + 16
if position.y > 240 + 16:
position.y = 0 - 16</p>
<p>The first line, <code>extends KinematicBody2D</code>, is telling us that our script is an extension of the “KinematicBody2D” class,
meaning we will be able to access any methods and variables that the “KinematicBody2D” class offers, plus any variables
and methods that we introduce here in this file. We then define the variables <code>speed</code> and <code>velocity</code>. We will use <code>velocity</code>
to mean the velocity of the player at any given time, and <code>speed</code> to mean the maximum horizontal or vertical speed of the
player when we move the player.</p>
<p>Next comes the method <code>_physics_process(_delta)</code>. This is a method accessible to many Godot nodes, and is executed
roughly 60 times per second, allowing us to alter objects in a way that the physics engine can understand.
The “delta” argument is the amount of time that has passed since the last call to <code>_physics_process</code>, but here we
are not using it, so we place an underscore in front of the argument name to avoid a warning.</p>
<p>In this method, we check if the <code>WASD</code> keys are pressed, and modify the player’s velocity accordingly (“W” to move up,
“A” to move left, “S” to move down, and “D” to move right). Note that to move up, we set the “y” velocity to <code>-speed</code> - this
is because Godot, like many game engines, considers <em>down</em> to be the positive y-direction.</p>
<p>After adjusting the player’s velocity, we call the <code>move_and_slide</code> method, specifying the velocity as one of its arguments
(the others don’t matter for now). This method does a lot of logic internally and can handle collisions with static bodies
and rigid bodies, of any shape or size, and correctly move the player along the surface of bodies instead of bouncing
off of them (hence the “slide”). The method returns the resulting velocity of the player after any collisions/slides,
but since we won’t be using this, we place an underscore to avoid a warning.</p>
<p>Lastly, we check and modify the position of the player to wrap around the window - i.e. if the player moves too far to the left,
have them wrap to the right side of the window.</p>
<p>Save, and finally go back to the “Game” scene, and click the button at the top of the “Scene” tab to “Instance Child Scene”:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646548728/blog/2022/03/deepgram-godot-tutorial/assets/instance_child_scene.png" alt="Instance a child scene." style="max-width: 626px;display: block;margin-left: auto;margin-right: auto;">
<p>Select the <code>Player.tscn</code> we just created. Now our main “Game” scene has a “Player” scene as a child node! Click the “Play” button
and now the game boots up with a skull in the corner - you can move the skull around with <code>WASD</code>! Feel free to reposition the skull
in the “Game” scene - you can either click and drag the player in the 2D view, or you can directly enter the x and y position
in <code>Node2D -&gt; Transform -&gt; Position</code> in the “Inspector” tab when the “Player” node is selected in the “Game” scene:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646785008/blog/2022/03/deepgram-godot-tutorial/assets/player_position_in_editor.png" alt="Setting the Player's position." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">
<h2 id="creating-a-fireball">Creating a Fireball</h2>
<p>Let’s make a fireball scene which we will use to have the player shooting fireballs across the screen.
Create a new scene, for the root node click “Other Node” and pick “Area2D”. Rename this root node “Fireball”.
Add two child nodes: an “AnimatedSprite” and a “CollisionShape2D”.</p>
<p>Next, import into your “Assets” directory <a href="https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_1.png">fireball_1.png</a>
and <a href="https://res.cloudinary.com/deepgram/image/upload/v1646850119/blog/2022/03/deepgram-godot-tutorial/assets/fireball_2.png">fireball_2.png</a>.
The two sprites will make up our fireball animation. For each of the imported fireball sprites, go to the “Import” tab,
uncheck “Filter” and click “Reimport” - just like for our pixel art player sprite, this will ensure that these sprites
maintain their blocky pixel form even on high-resolution displays.</p>
<p>Now, click the “AnimatedSprite” node, and on the right in the “Frames” field, click where it says “[empty]” and select
“New SpriteFrames”. Then click the field again and you should be brought to an editor view where we can add our animation.
Click and drag the <code>fireball_1.png</code> and <code>fireball_2.png</code> files from the “Assets” directory into the “Animation Frames” box:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_animation.png" alt="Create the fireball animation." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">
<p>Next, click the “AnimatedSprite” node again to bring up the “Inspector” tab for this node again, check the box titled “Playing”.
In the lower-left of the “Animations” tab, change the “Speed” field to “12 FPS”. The fireball should now be animated in the editor:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646784180/blog/2022/03/deepgram-godot-tutorial/assets/fireball_editor_cropped_animated.gif" alt="The fireball animation in the editor." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">
<p>There are certainly several tabs and fields to navigate through in this process, but I hope you find some of these operations intuitive!
To create animations, you drag the individual frames into the “Animation Frames”
box, you can then change the speed of the animation just left of this box, and you can set which animation plays by default
in the “Animation” field of the “Inspector” tab for the “AnimatedSprite” node - here you can also set whether the animation
is turned on or off with the “Playing” check box.</p>
<p>Now, click the “CollisionShape2D” node, and in the “Inspector” tab for the “Shape” field select “New CircleShape2D”. Then
click the “CicleShape2D” to edit it’s properties and change its radius to 4:</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646613234/blog/2022/03/deepgram-godot-tutorial/assets/fireball_hitbox.png" alt="Setting the fireball's hit-box." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">
<p>Now, save the scene as <code>Fireball.tscn</code> in the “Scenes” directory, and then attach a script to the root node. Make the contents
of the script as follows:</p>
<p>extends Area2D</p>
<p>export var speed = 220
var direction = Vector2(0, 0)</p>
<p>func _physics_process(delta):
var velocity = direction.normalized() * speed</p>
<p>rotation = velocity.angle()
position += velocity * delta</p>
<p>if position.x > 320 + 16:
get_tree().queue_delete(self)
if position.x < 0 - 16:
get_tree().queue_delete(self)
if position.y > 240 + 16:
get_tree().queue_delete(self)
if position.y < 0 - 16:
get_tree().queue_delete(self)</p>
<p>Like with the “Player” scene, we are extending the root node’s class, in this case an “Area2D.” We will give each fireball object
a speed and a direction. When <code>_physics_process</code> is called, we will update the fireball’s position and angle according to
the fireball’s direction and speed. If the fireball goes off-screen, we will destroy it using <code>get_tree().queue_delete(self)</code>.</p>
<p>That’s all there is to the “Fireball” scene, but we haven’t actually added any fireballs to our game. We could do this by instancing
a “Fireball” scene in our “Game” scene, but for these kinds of objects, there’s a better way - we should spawn them via code!</p>
<h2 id="triggering-the-fireball-with-keystrokes">Triggering the Fireball With Keystrokes</h2>
<p>Go to the “Game” scene and add a script to the root node, just like we did for the “Player” scene.
Then edit <code>Game.gd</code> to have the following contents:</p>
<p>extends Node2D</p>
<p>var rng = RandomNumberGenerator.new()</p>
<p>func _ready():
rng.randomize()</p>
<p>func _input(event):
if event is InputEventKey and event.pressed:
if event.scancode == KEY_F:
for i in rng.randi_range(2, 5):
spawn_fireball()</p>
<p>func spawn_fireball():
var fireball = load(“res://Scenes/Fireball.tscn”).instance()
add_child(fireball)</p>
<p>var random_angle = rng.randf_range(0.0, 2 * PI)
fireball.direction = Vector2(cos(random_angle), sin(random_angle))
fireball.rotation = fireball.direction.angle()
fireball.position = $Player.position</p>
<p>The first line, <code>extends Node2D</code>, is essentially saying that this object is extending the “Node2D” class.
Then, we create a global variable for this object called <code>rng</code> which will be used for random number generation.
Next, we define the <code>_ready()</code> method which is called when an instance of this scene gets created - in this
method we are initializing our random number generator.</p>
<p>The <code>_input(event)</code> method gets called every time there was an input event such as a keystroke, a mouse click,
a touch, a game-pad button press, etc. In our case, we are looking to see if the “F” key was pressed, and if
so, we want to spawn 2-5 fireballs!</p>
<p>The logic handling the spawning of fireballs occurs in the method <code>spawn_fireball()</code>. Here we create an instance
of our “Fireball” scene, add it as a child of the current scene, and then initialize the fireball’s direction,
rotation, and position. We are setting the fireball to spawn exactly where the player object is located,
and we are setting the fireball’s direction to be totally random.</p>
<p>The syntax <code>$Player</code> is syntax sugar
for <code>get_node("Player")</code> and requires that our “Game” scene has a child node named “Player” (which it does!).
However, since GDScript is very much like Python, the game will build and run just fine if one makes
a reference to a non-existent object - this will be caught only when the program reaches that line of code,
and it will cause a crash. As Python developers are likely aware, this is sometimes one of the trade-offs of
having a “quick and easy” language.</p>
<p>You should now be able to play the game, move the player around, and press “F” to fire off fireballs! Now
that the basic game is complete, let’s add the juicy part by triggering the fireballs not with key presses,
but with your voice!</p>
<h2 id="triggering-the-fireball-with-your-voice">Triggering the Fireball With Your Voice</h2>
<p>Finally, let’s do our Deepgram integration so that we can spawn fireballs by saying “fire” into the microphone instead
of pressing a key. To do this, grab the <code>DeepgramIntegration</code> directory from <code>Scenes/DeepgramIntegration</code>
from the <a href="https://github.com/deepgram/SpeechSpells">the SpeechSpells repository</a> and place it in the <code>Scenes/</code> directory in the Godot editor.</p>
<p>This integration contains two Godot scenes with accompanying scripts: <code>MicrophoneInstance</code> and <code>DeepgramInstance</code>.
We won’t go over the inner-workings of these scripts in detail, but feel free to have a look as they have
a fair amount of descriptive comments to help explain what is going on. In a nutshell, the <code>MicrophoneInstance</code>
interfaces with your device’s microphone and streams the raw audio from the microphone via Godot signals
to the <code>DeepgramInstance</code> which handles connecting to Deepgram via Websockets.
The <code>DeepgramInstance</code> then forwards the raw microphone audio to Deepgram, receives ASR results from Deepgram,
and then forwards those results via Godot signals to some other node. In our case, this other node will be
our “Game” scene’s root node.</p>
<hr>
<p><em><strong>Note</strong></em>: A common issue which causes the microphone capture to fail on Mac is if Godot’s audio sample rate is set to
something different then the OS’s audio sample rate. If you experience issues with microphone capture on Mac, you
can check your OS’s audio sample rate under <code>Utilities -&gt; Audio Midi Setup</code>.</p>
<img src="https://res.cloudinary.com/deepgram/image/upload/v1646351903/blog/2022/03/deepgram-godot-tutorial/assets/mac_sample_rate_settings.png" alt="Mac audio sample rate settings." style="max-width: 1850px;display: block;margin-left: auto;margin-right: auto;">
<hr>
<hr>
<p><em><strong>Note</strong></em>: This integration will not work for Godot’s HTML5 builds out-of-the-box
as authenticating websockets connections with headers is not supported for these builds due to
some authentication limitations of browsers. If you plan on making an HTML5 game with the Deepgram
integration, you will have to deploy a proxy server for authentication and make some minor adjustments
of the <code>DeepgramInstance</code> scene. This may be a topic of a future guide!</p>
<hr>
<p>In your “Game” scene, add as a child an instance of the “DeepgramInstance” scene, then modify <code>Game.gd</code> as follows:</p>
<p>extends Node2D</p>
<p>var rng = RandomNumberGenerator.new()</p>
<p>func _ready():
rng.randomize()
$DeepgramInstance.initialize(“INSERT_YOUR_API_KEY_HERE”)</p>
<p>func _on_DeepgramInstance_message_received(message):
var message_json = JSON.parse(message)
if message_json.error == OK:
if typeof(message_json.result) == TYPE_DICTIONARY:
if message_json.result.has(“is_final”):
if message_json.result[“is_final”] == true:
var message_transcript = message_json.result[“channel”][“alternatives”][0][“transcript”]
print(“Transcript received: ” + message_transcript)
for _i in message.count(“fire”):
spawn_fireball()</p>
<p>else:
print(“Failed to parse Deepgram message!“)</p>
<p>func spawn_fireball():
var fireball = load(“res://Scenes/Fireball.tscn”).instance()
add_child(fireball)</p>
<p>var random_angle = rng.randf_range(0.0, 2 * PI)
fireball.direction = Vector2(cos(random_angle), sin(random_angle))
fireball.rotation = fireball.direction.angle()
fireball.position = $Player.position</p>
<p>Remember to replace <code>INSERT_YOUR_API_KEY_HERE</code> with your Deepgram API Key.</p>
<p>Now, to finish up, click your “Game” scene’s “DeepgramInstance” node and in the right panel click the “Node” tab (it should be right next
to the “Inspector” tab). You should see a <code>message_received()</code> signal listed under <code>DeepgramInstance.gd</code> - double click this,
make sure that the “Game” node is highlighted, and click “connect”.</p>
<p>What is this signal doing? Signals are a useful way to organize the transmission of events in game engines.
In this particular case, the “DeepgramInstance” node is signaling to its parent “Game” node that it has received a message from Deepgram.
It passes this message with the signal, the parent “Game” node can then react to the signal to trigger further logic.</p>
<p>In our case, the “Game” node handles this signal in the <code>_on_DeepgramInstance_message_received</code> method where tries to parse
the JSON message from Deepgram into a data structure similar to a Dictionary using <code>JSON.parse(message)</code>.</p>
<p>After verifying that the message successfully parsed as a Dictionary, it checks to see whether this is a final result or an interim result.
To understand the difference between final and interim results in the Deepgram realtime streaming API, check out <a href="https://developers.deepgram.com/documentation/features/interim-results/">this page</a>.
For our purposes, we are only considering final results. We then grab the transcript from the first alternative in the
ASR result, and count how many times the word “fire” appears in the transcript, spawning one fireball for each occurrence.</p>
<h2 id="build-new-features">Build New Features</h2>
<p>So now you can walk around and cast fireball spells with your voice! Here are some ideas for next steps
you may want to try out to make a more fully-featured game:</p>
<ul>
<li>Implement more spells! Try a thunder spell, or an ice beam spell.</li>
<li>Add enemies and implement collision detection to destroy enemies when your spells hit them.</li>
<li>Try using <a href="https://developers.deepgram.com/documentation/features/interim-results/">interim results</a> instead of just final results - this should decrease the latency of the spells substantially, but you will need to watch out for
double-counting as multiple interim results will give transcripts for the same section of audio!</li>
<li>Play around with Deepgram’s <code>keyword</code>, <code>search</code>, and/or <code>phoneme</code> features to implement spells for out-of-vocab words.</li>
<li>If you are feeling ambitious, work through some Godot networking tutorials to create a multiplayer game where you and your friends cast spells at each other!</li>
</ul>
<h2 id="final-thoughts">Final Thoughts</h2>
<p>Speech-enhanced games have actually been around for quite some time, with popular titles such as “Hey You, Pikachu!” and “Seaman”,
but it hasn’t been until more recently that ASR engines have really taken off and can start to offer gameplay experiences which are deeper
than the simple command-based games of the past which only understood a few phrases. With modern ASR engines like Deepgram’s, understanding
thousands of commands has become trivial, and much more interesting and complex uses for speech in games is now possible. I encourage anyone
interested to try things out and explore with us what the future of speech in games might look like! Off the top of my head, I want to lastly
share some game ideas to get the creative juices flowing in the community:</p>
<ul>
<li>An RPG where warriors fight with swords, archers fight with bows, and mages fight with… speech! Take the “casting spells” approach of this
tutorial and expand it to a game about incantations! (See “In Verbis Virtus” for even more inspiration here!)</li>
<li>Speech-enhanced mini-games: imagine playing a Zelda-esque game where you walk into a town and go to the nearest mini-game building and have
to play word games ala “Wheel of Fortune” to win your next upgrade!</li>
<li>Games fully controllable via speech: traditional turn-based games are a great candidate to integrate speech controls, and this could greatly
increase the accessibility of such games! This type of technology does exist, but it can likely be greatly improved with new powerful ASR engines
like Deepgram.</li>
<li>Casual social games: imagine playing word and speech-based games in an environment like VR chat!</li>
<li>AI-based visual novels: imagine playing a visual novel where instead of picking from a list of phrases to progress, you simply say what’s on your mind!</li>
<li>AAA AI-enhanced experiences: take the visual novel idea to the next level and enhance AI components of AAA titles by allowing your character to
talk to NPCs with a microphone! (Check out games like “Phasmophobia” for even more inspiration here!)</li>
</ul>
<p>If you have any questions, please feel free to reach out on Twitter - we’re @DeepgramDevs.</p>`;
}, "/Users/sandrarodgers/web-next/blog/src/content/blog/posts/deepgram-godot-tutorial/index.md");

export { compiledContent, $$Index as default, frontmatter, metadata, rawContent };
